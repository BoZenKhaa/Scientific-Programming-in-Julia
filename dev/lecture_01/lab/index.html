<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lab · Scientific Programming in Julia</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://JuliaTeachingCTU.github.io/Scientific-Programming-in-Julia/lecture_01/lab/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Scientific Programming in Julia logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Scientific Programming in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scientific Programming in Julia</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">1: Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../motivation/">Motivation</a></li><li><a class="tocitem" href="../outline/">Outline</a></li><li class="is-active"><a class="tocitem" href>Lab</a><ul class="internal"><li><a class="tocitem" href="#Testing-Julia-installation"><span>Testing Julia installation</span></a></li><li><a class="tocitem" href="#Polynomial-evaluation-example"><span>Polynomial evaluation example</span></a></li><li><a class="tocitem" href="#How-to-use-code-from-other-people"><span>How to use code from other people</span></a></li><li><a class="tocitem" href="#Useful-resources"><span>Useful resources</span></a></li></ul></li><li><a class="tocitem" href="../hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">2: The power of Type System &amp; multiple dispatch</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_02/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_02/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_02/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">3: Design patterns</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_03/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_03/hw/">Homework</a></li></ul></li><li><span class="tocitem">4: Packages development, environments, etc...</span></li><li><span class="tocitem">5: Benchmarking, profiling, and performance gotchas</span></li><li><span class="tocitem">6: Language introspection</span></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">7: Macros</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/macros/">Macros</a></li></ul></li><li><span class="tocitem">8: Introduction to automatic differentiation</span></li><li><span class="tocitem">9: Manipulating intermediate representation</span></li><li><span class="tocitem">10: Different levels of parallel programming</span></li><li><span class="tocitem">11: Julia for GPU programming</span></li><li><span class="tocitem">12: Uncertainty propagation in ODE</span></li><li><span class="tocitem">13: Learning ODE from data</span></li><li><a class="tocitem" href="../../how_to_submit_hw/">How to submit homeworks</a></li><li><a class="tocitem" href="../../howto/">How To ...</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">1: Introduction</a></li><li class="is-active"><a href>Lab</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lab</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaTeachingCTU/Scientific-Programming-in-Julia/blob/master/docs/src/lecture_01/lab.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Lab-01:-Introduction-to-Julia"><a class="docs-heading-anchor" href="#Lab-01:-Introduction-to-Julia">Lab 01: Introduction to Julia</a><a id="Lab-01:-Introduction-to-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Lab-01:-Introduction-to-Julia" title="Permalink"></a></h1><p>This lab should get everyone up to speed in the basics of Julia&#39;s installation, syntax and basic coding. For more detailed introduction you can check out Lectures 1-3 of the bachelor <a href="https://juliateachingctu.github.io/Julia-for-Optimization-and-Learning/stable/">course</a>.</p><h2 id="Testing-Julia-installation"><a class="docs-heading-anchor" href="#Testing-Julia-installation">Testing Julia installation</a><a id="Testing-Julia-installation-1"></a><a class="docs-heading-anchor-permalink" href="#Testing-Julia-installation" title="Permalink"></a></h2><p>In order to proceed further let&#39;s run a simple script to see, that the setup described in chapter <a href="../../installation/#install">Installation</a> is working properly. After spawning a terminal run this command:</p><pre><code class="language-bash hljs">julia ./test_setup.jl</code></pre><p>The script does the following </p><ul><li>&quot;Tests&quot; if Julia is added to path and can be run with <code>julia</code> command from anywhere</li><li>Prints Hello World and Julia version info</li><li>Creates an environment configuration files</li><li>Installs a basic pkg called BenchmarkTools, which we will use for benchmarking a simple function later in the labs.</li></ul><p>There are some quality of life improvements over long term support versions of Julia and thus for the course of these lectures we will use the latest stable release of Julia 1.6.x.</p><h2 id="Polynomial-evaluation-example"><a class="docs-heading-anchor" href="#Polynomial-evaluation-example">Polynomial evaluation example</a><a id="Polynomial-evaluation-example-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomial-evaluation-example" title="Permalink"></a></h2><p>Let&#39;s consider a common mathematical example for evaluation of nth-degree polynomial</p><p class="math-container">\[f(x) = a_{n}x^{n} + a_{n-1}x^{n-1} + \dots + a_{0}x^{0},\]</p><p>where <span>$x \in \mathbb{R}$</span> and <span>$\vec{a} \in \mathbb{R}^{n+1}$</span>.</p><p>The simplest way of writing this is just realizing that essentially the function <span>$f$</span> is really implicitly containing argument <span>$\vec{a}$</span>, i.e. <span>$f \equiv f(\vec{a}, x)$</span>, yielding the following function</p><pre><code class="language-julia hljs">function polynomial(a, x)
    accumulator = 0
    for i in length(a):-1:1
        accumulator += x^(i-1) * a[i] # ! 1-based indexing for arrays
    end
    return accumulator
end</code></pre><div class="admonition is-category-exercise">
<header class="admonition-header">Exercise</header>
<div class="admonition-body"><p>Evaluate the code of the function called <code>polynomial</code> in Julia REPL and evaluate the function itself with the following arguments.</p><pre><code class="language-julia hljs">a = [-19, 7, -4, 6] # list coefficients a from a^0 to a^n
x = 3               # point of evaluation</code></pre></div></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>The simplest way is to just copy&amp;paste into an already running terminal manually. As opposed to the default Python REPL, Julia can deal with the blocks of code and different indentation much better without installation of an <code>ipython</code>-like REPL. There are ways to make this much easier in different text editors/IDEs:</p><ul><li><code>VSCode</code> - when using Julia extension, by default <code>Ctrl+Enter</code> will spawn Julia REPL, when a <code>.jl</code> file is opened</li><li><code>Sublime Text</code> - <code>Send Code</code> pkg (works well with Linux terminal or tmux, support for Windows is poor)</li><li><code>Vim</code> - there is a Julia language <a href="https://github.com/JuliaEditorSupport/julia-vim">plugin</a>, which can be combine with <a href="https://github.com/jalvesaq/vimcmdline">vimcmdline</a></li></ul><p>Either way, you should see the following:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function polynomial(a, x)
           accumulator = 0
           for i in length(a):-1:1
               accumulator += x^(i-1) * a[i] # ! 1-based indexing for arrays
           end
           return accumulator
       end</code><code class="nohighlight hljs ansi" style="display:block;">polynomial (generic function with 1 method)</code></pre><p>Similarly we enter the arguments of the function <code>a</code> and <code>x</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = [-19, 7, -4, 6]</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Int64}:
 -19
   7
  -4
   6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = 3</code><code class="nohighlight hljs ansi" style="display:block;">3</code></pre><p>Function call intuitively takes the name of the function with round brackets as arguments, i.e. works in the same way as majority of programming languages. The result is printed unless a <code>;</code> is added at the end of the statement.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; polynomial(a, x)    # function call</code><code class="nohighlight hljs ansi" style="display:block;">128</code></pre></p></details><p>Thanks to the high level nature of Julia language it is often the case that examples written in pseudocode are almost directly rewritable into the language itself without major changes and the code can be thus interpreted easily.</p><p><img src="../polynomial.svg" alt="polynomial_explained"/></p><p>The indentation is not necessary as opposed to other languages such as Python, due to the existence of the <code>end</code> keyword, however it is strongly recommended to use it, see <a href="https://docs.julialang.org/en/v1/manual/style-guide/#Style-Guide">style guide</a>. Furthermore the return keyword can be omitted if the last line being evaluated contains the result, unless the line ends with <code>;</code>.</p><p>Though there are libraries/IDEs that allow us to step through Julia code (<code>Rebugger.jl</code> <a href="https://github.com/timholy/Rebugger.jl">link</a> and <code>VSCode</code> <a href="https://www.julia-vscode.org/docs/stable/userguide/debugging/">link</a>), we can (having defined the arguments with the same name as inside the actual function) evaluate pieces of code separately. </p><div class="admonition is-category-exercise">
<header class="admonition-header">Exercise</header>
<div class="admonition-body"><p>Evaluate the following pieces of code and check their type with <code>typeof</code> function, e.g. <code>typeof(a)</code> or <code>typeof([-19, 7, -4, 6])</code></p><p><em>BONUS</em>: Try to &quot;call for help&quot; by accessing the build in help terminal by typing <code>?</code> followed by a keyword to explain. Use this for basic functions such as <code>length</code>, <code>typeof</code>, <code>^</code>.</p><pre><code class="language-julia hljs">a = [-19, 7, -4, 6]
x = 3
accumulator = 0
length(a):-1:1

i = length(a)
accumulator += x^(i-1) * a[i]
accumulator

polynomial
^
*</code></pre></div></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>When defining a variable through an assignment we get the representation of the right side, again this is different from the default  behavior in Python, where the output of <code>a = [-19, 7, -4, 6]</code>, prints nothing. In Julia REPL we get the result of the <code>display</code> function.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; julia&gt; a = [-19, 7, -4, 6]</code><code class="nohighlight hljs ansi" style="display:block;">&gt; (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; julia&gt; display(a) # should return the same thing as the line above</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: julia not defined</code></pre><p>As you can see, the string that is being displayed contains information about the contents of a variable along with it&#39;s type in this case this is a <code>Vector</code> of <code>Int</code> types. Which can be checked further with the <code>typeof</code> function</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(a)</code><code class="nohighlight hljs ansi" style="display:block;">Vector{Int64} (alias for Array{Int64, 1})</code></pre><p>The other two assignments are exactly the same as they both generate an instance of <code>Int</code> type with different values. Though now one has to call for hell the <code>typeof</code> function, because by default this information is omitted in the display of simple types.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = 3</code><code class="nohighlight hljs ansi" style="display:block;">3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; accumulator = 0</code><code class="nohighlight hljs ansi" style="display:block;">0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(x), typeof(accumulator)</code><code class="nohighlight hljs ansi" style="display:block;">(Int64, Int64)</code></pre><p>The next expression creates an instance of a range, which are <em>inclusive</em> in Julia, i.e. containing number from start to end - in this case running from <code>4</code> to <code>1</code> with negative step <code>-1</code>, thus counting down.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; length(a):-1:1</code><code class="nohighlight hljs ansi" style="display:block;">4:-1:1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(length(a):-1:1)</code><code class="nohighlight hljs ansi" style="display:block;">StepRange{Int64, Int64}</code></pre><p>Let&#39;s confirm the fact that the update operator <code>+=</code> really does update the variable <code>accumulator</code> by running the following</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; i = length(a) #</code><code class="nohighlight hljs ansi" style="display:block;">4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; accumulator += x^(i-1) * a[i]</code><code class="nohighlight hljs ansi" style="display:block;">162</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; accumulator</code><code class="nohighlight hljs ansi" style="display:block;">162</code></pre><p>Notice that evaluating a variable, which can be used instead of the return keyword at the end of a function.</p><p>We have already seen the output of evaluating <code>polynomial</code> function name in the REPL By creating the function <code>polynomial</code> we have defined a variable <code>polynomial</code>, that from now on always refers to a function and cannot be redefined with a different type.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; polynomial</code><code class="nohighlight hljs ansi" style="display:block;">polynomial (generic function with 1 method)</code></pre><p>This is cause by the fact that each function defines essentially a new type, the same like <code>Int ~ Int64</code> or <code>Vector{Int}</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(polynomial)</code><code class="nohighlight hljs ansi" style="display:block;">typeof(Main.polynomial)</code></pre><p>You can check that it is a subtype of the <code>Function</code> abstract type, with the subtyping operator <code>&lt;:</code></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(polynomial) &lt;: Function</code><code class="nohighlight hljs ansi" style="display:block;">true</code></pre><p>These concepts will be expanded further in the type <a href="lecture_01/@ref type_lecture">lecture</a>, however for now note that this construction is quite useful for example if we wanted to create derivative rules for our function <code>derivativeof(::typeof(polynomial), ...)</code>.</p><p>Looking at the last two functions <code>+</code>, <code>*</code></p><p><em>BONUS</em>: Accessing help terminal <code>?</code> and looking up a keyword, searches for documentation of individual methods/functions in the source code. When creating a pkg, it is desirable to create so called <code>docstrings</code> for each method that is going to be exported. <code>docstrings</code> are multiline strings written above a function. More on this in <a href="lecture_01/@ref pkg_lecture">lecture</a> on pkg development.</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    polynomial(a, x)

Returns value of a polynomial with coefficients `a` at point `x`.
&quot;&quot;&quot;
function polynomial(a, x)
    # function body
end</code></pre></p></details><p>As the arguments of the <code>polynomial</code> functions are untyped, i.e. they do not specify the allowed types like for example <code>polynomial(a, x::Number)</code> does, the following exercise explores how wide range of arguments does the</p><div class="admonition is-category-exercise">
<header class="admonition-header">Exercise</header>
<div class="admonition-body"><p>What happens if you call our polynomial function with with the following coefficients?</p><pre><code class="language-julia hljs">af = [-19.0, 7.0, -4.0, 6.0]
at = (-19, 7, -4, 6)
ant = (a₀ = -19, a₁ = 7, a₂ = -4, a₃ = 6)
a2d = [-19 -4; 7 6]
ach = [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;]
ac = [2i^2 + 1 for i in -2:1]
ag = (2i^2 + 1 for i in -2:1)</code></pre><p>Check first the types of each of these coefficients by calling <code>typeof</code> and <code>eltype</code>.</p><p><em>BONUS</em>: In the case of <code>ag</code>, use the <code>collect</code> function to get the desirable result. What does it do? Check again the type of the result.</p></div></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>As opposed to the basic definition of <code>a</code> type the array is filled with <code>Float64</code> types and the resulting value gets promoted as well to the <code>Float64</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(at), eltype(at)</code><code class="nohighlight hljs ansi" style="display:block;">(NTuple{4, Int64}, Int64)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; polynomial(at, x)</code><code class="nohighlight hljs ansi" style="display:block;">128</code></pre><p>With round brackets over a fixed length vector we get the <code>Tuple</code> type, which is a fixed size, so called immutable &quot;array&quot; of a fixed size (its elements cannot be changed, unless initialized from scratch). Each element can be of a different type, but here we have only one and thus the <code>Tuple</code> is aliased into <code>NTuple</code>. There are some performance benefits for using immutable structure, which will be discussed <a href="lecture_01/@ref type_lecture">later</a> or <a href="lecture_01/@ref perf_lecture">even later</a>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(ant), eltype(ant)</code><code class="nohighlight hljs ansi" style="display:block;">(NamedTuple{(:a₀, :a₁, :a₂, :a₃), NTuple{4, Int64}}, Int64)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; polynomial(ant, x)</code><code class="nohighlight hljs ansi" style="display:block;">128</code></pre><p>Defining a 2D array is a simple change of syntax, which initialized a matrix row by row separated by <code>;</code> with spaces between individual elements. The function works in the same way because linear indexing works in 2d arrays in column major fashion.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(a2d), eltype(a2d)</code><code class="nohighlight hljs ansi" style="display:block;">(Matrix{Int64}, Int64)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; polynomial(a2d, x)</code><code class="nohighlight hljs ansi" style="display:block;">128</code></pre><p>Consider the vector/array of characters, which themselves have numeric values (you can check by converting them to Int <code>Int(&#39;1&#39;)</code> or <code>convert(Int, &#39;l&#39;)</code>). In spite of that, our untyped function cannot process such input, as there isn&#39;t an operation/method that would allow  multiplication of <code>Char</code> and <code>Int</code> type. Julia tries to promote the argument types to some common type, however checking the <code>promote_type(Int, Char)</code> returns <code>Any</code> (union of all types), which tells us that the conversion is not possible automatically.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(ach), eltype(ach)</code><code class="nohighlight hljs ansi" style="display:block;">(Vector{Char}, Char)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; polynomial(ach, x)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching *(::Int64, ::Char)
Closest candidates are:
  *(::Any, ::Any, !Matched::Any, !Matched::Any...) at operators.jl:560
  *(::T, !Matched::T) where T&lt;:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8} at int.jl:88
  *(!Matched::Union{AbstractChar, AbstractString}, ::Union{AbstractChar, AbstractString}...) at strings/basic.jl:260
  ...</code></pre><p>In the stacktrace we can see the location of each function call. If we include the function <code>polynomial</code> from some file <code>poly.jl</code> using <code>include(&quot;poly.jl&quot;)</code>, we will see that the location changes from <code>REPL[X]:10</code> to the the actual file name.</p><p>The next example shows so called array comprehension syntax, where we define and array of known length using and for loop iteration. Resulting array/vector has integer elements, however even mixed type is possible yielding <code>Any</code>, if there isn&#39;t any other common supertype to <code>promote</code> every entry into. (Use <code>?</code> to look what <code>promote</code> and <code>promote_type</code> does.)</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(ac), eltype(ac)</code><code class="nohighlight hljs ansi" style="display:block;">(Vector{Int64}, Int64)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; polynomial(ac, x)</code><code class="nohighlight hljs ansi" style="display:block;">108</code></pre><p>By swapping square brackets for round we have defined so called generator/iterator, which as opposed to the previous example does not allocate an array, only the structure that produces it. You may notice that the element type in this case is <code>Any</code>, which means that a function using such generator as an argument cannot specialize based on the type and has to infer it every time an element is generated/returned. We will touch on how this affects performance in one of the later <a href="lecture_01/@ref perf_lecture">lectures</a>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(ag), eltype(ag)</code><code class="nohighlight hljs ansi" style="display:block;">(Base.Generator{UnitRange{Int64}, Main.var&quot;#3#4&quot;}, Any)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; polynomial(ag, x)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: MethodError: no method matching getindex(::Base.Generator{UnitRange{Int64}, Main.var&quot;#3#4&quot;}, ::Int64)</code></pre><p><em>BONUS</em>: In general generators may have unknown length which is useful, for example in batch processing of files, where we do not know beforehand how many files are in a folder. However the problem here originated from the problem of missing indexing operation <code>getindex</code>, which can be easily solved by collecting the generator with <code>collect</code> and thus transforming it into and array.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; agc = ag |&gt; collect # pipe syntax, equivalent to collect(ag)</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{Int64}:
 9
 3
 1
 3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; typeof(agc), eltype(agc)</code><code class="nohighlight hljs ansi" style="display:block;">(Vector{Int64}, Int64)</code></pre><p>You can see now that <code>eltype</code> is no longer <code>Any</code> and a proper type for the whole container has been found in the <code>collect</code> function.</p></p></details><h2 id="How-to-use-code-from-other-people"><a class="docs-heading-anchor" href="#How-to-use-code-from-other-people">How to use code from other people</a><a id="How-to-use-code-from-other-people-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-use-code-from-other-people" title="Permalink"></a></h2><p>The script that we have run at the beginning of this lab has created a folder <code>test</code> with the following files.</p><pre><code class="nohighlight hljs">./test/
    ├── Manifest.toml
    ├── Project.toml
    └── src
        └── test.jl</code></pre><p>Every folder with a toml file called <code>Project.toml</code>, can be used by Julia&#39;s pkg manager into setting so called environment. Each of these environments has a specific name, unique identifier and most importantly a list of pkgs to be installed. Setting up or more often called activating an environment can be done either before starting Julia itself by running julia with the <code>--project XXX</code> flag or from withing the Julia REPL, by switching to Pkg mode with <code>]</code> key (similar to the help mode activated by pressing <code>?</code>).</p><p>So far we have used the general environment, which by default does not come with any 3rd party packages and includes only the base and standard libraries - <a href="https://docs.julialang.org/en/v1/base/arrays/">already</a> <a href="https://docs.julialang.org/en/v1/base/multi-threading/">quite</a> <a href="https://docs.julialang.org/en/v1/stdlib/Distributed/">powerful</a> <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/">on its own</a>. </p><p>In order to find which environment is currently active, run the following:</p><pre><code class="language-julia hljs">] status</code></pre><p>And the output of such command usually indicates the general environment located at <code>.julia/</code> folder (<code>${HOME}/.julia/</code> or <code>${APPDATA}/.julia/</code> in case of Unix/Windows based systems respectively)</p><pre><code class="language-julia hljs">(@v1.6) pkg&gt; status
Status `~/.julia/environments/v1.6/Project.toml` (empty project)</code></pre><p>Generally one should avoid installing project specific pkg into general environment with the exception of some generic pkgs, which do not create much conflics such as <code>PkgTemplates.jl</code>, which is used for generating pkg templates/folder structure like the one above (<a href="https://github.com/invenia/PkgTemplates.jl">link</a>), more on this in the <a href="lecture_01/@ref pkg_lecture">lecture</a> on pkg development. </p><div class="admonition is-category-exercise">
<header class="admonition-header">Exercise</header>
<div class="admonition-body"><p>Activate the test environment inside <code>./test</code> and check that the <code>BenchmarkTools</code> package has been installed. Use <code>BenchmarkTools</code> pkg&#39;s <code>@btime</code> to benchmark our <code>polynomial</code> function with the following arguments.</p><pre><code class="language-julia hljs">aexp = ones(10) ./ factorial.(0:9)
x = 1.1</code></pre><p>In pkg mode use the command <code>activate</code> and <code>status</code> to check the presence. In order to import the functionality from other package, lookup the keyword <code>using</code> in the repl help mode <code>?</code>. The functionality that we want to use is the <code>@btime</code> macro (it acts almost like a function but with a different syntax <code>@macro arg1 arg2 arg3 ...</code>). More on macros in the corresponding <a href="lecture_01/@ref macro_lecture">lecture</a>.</p><p><em>BONUS</em>: Compare the output of <code>polynomial(aexp, x)</code> with the value of <code>exp(x)</code>, which it approximates.</p></div></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><p>There are other options to import a function/macro from a different package, however for now let&#39;s keep it simple with the <code>using Module</code> syntax, that brings to the REPL, all the variables/function/macros exported by the <code>BenchmarkTools</code> pkg. If <code>@btime</code> is exported, which it is, it can be accessed without specification i.e. just by calling <code>@btime</code> without the need for <code>BenchmarkTools.@btime</code>. More on the architecture of pkg/module loading in the package developement <a href="lecture_01/@ref pkg_lecture">lecture</a>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using BenchmarkTools</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @btime polynomial(aexp, x)</code><code class="nohighlight hljs ansi" style="display:block;">  572.826 ns (1 allocation: 16 bytes)
3.004165230550543</code></pre><p>The output gives us the time of execution averaged over multiple runs (the number of samples is defined automatically based on run time) as well as the number of allocations and the output of the function, that is being benchmarked.</p><p><em>BONUS</em>: The difference between our approximation and the &quot;actual&quot; function value computed as a difference of the two. </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; polynomial(aexp, x) - exp(x)</code><code class="nohighlight hljs ansi" style="display:block;">-7.933958903194593e-7</code></pre><p>The apostrophes in the previous sentece are on purpose, because implementation of <code>exp</code> also relies too on a finite sum, though much more sophisticated than the basic Taylor expansion.</p></p></details><h2 id="Useful-resources"><a class="docs-heading-anchor" href="#Useful-resources">Useful resources</a><a id="Useful-resources-1"></a><a class="docs-heading-anchor-permalink" href="#Useful-resources" title="Permalink"></a></h2><ul><li>Getting Started tutorial from JuliaLang documentation - <a href="https://docs.julialang.org/en/v1/manual/getting-started/">Docs</a></li><li>Converting syntax between MATLAB ↔ Python ↔ Julia - <a href="https://cheatsheets.quantecon.org/">Cheatsheet</a></li><li>Bachelor course for refreshing your knowledge - <a href="https://juliateachingctu.github.io/Julia-for-Optimization-and-Learning/stable/">Course</a></li><li>Stylistic conventions - <a href="https://docs.julialang.org/en/v1/manual/style-guide/#Style-Guide">Style Guide</a></li><li>Reserved keywords - <a href="https://docs.julialang.org/en/v1/base/base/#Keywords">List</a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../outline/">« Outline</a><a class="docs-footer-nextpage" href="../hw/">Homework »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Tuesday 31 August 2021 08:02">Tuesday 31 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
