<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lecture · Scientific Programming in Julia</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://JuliaTeachingCTU.github.io/Scientific-Programming-in-Julia/lecture_03/lecture/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Scientific Programming in Julia logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Scientific Programming in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scientific Programming in Julia</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">1: Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/motivation/">Motivation</a></li><li><a class="tocitem" href="../../lecture_01/basics/">Basics</a></li><li><a class="tocitem" href="../../lecture_01/demo/">Examples</a></li><li><a class="tocitem" href="../../lecture_01/outline/">Outline</a></li><li><a class="tocitem" href="../../lecture_01/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_01/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">2: The power of Type System &amp; multiple dispatch</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_02/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_02/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_02/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">3: Design patterns</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Lecture</a></li><li><a class="tocitem" href="../lab/">Lab</a></li><li><a class="tocitem" href="../hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">4: Packages development, environments, etc...</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_04/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_04/lab/">Lab</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">5: Benchmarking, profiling, and performance gotchas</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_05/lecture/">Lecture</a></li></ul></li><li><span class="tocitem">6: Language introspection</span></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">7: Macros</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/lecture/">Lecture</a></li></ul></li><li><span class="tocitem">8: Introduction to automatic differentiation</span></li><li><span class="tocitem">9: Manipulating intermediate representation</span></li><li><span class="tocitem">10: Different levels of parallel programming</span></li><li><span class="tocitem">11: Julia for GPU programming</span></li><li><span class="tocitem">12: Uncertainty propagation in ODE</span></li><li><span class="tocitem">13: Learning ODE from data</span></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">3: Design patterns</a></li><li class="is-active"><a href>Lecture</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lecture</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaTeachingCTU/Scientific-Programming-in-Julia/blob/master/docs/src/lecture_03/lecture.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Design-patterns:-good-practices-and-structured-thinking"><a class="docs-heading-anchor" href="#Design-patterns:-good-practices-and-structured-thinking">Design patterns: good practices and structured thinking</a><a id="Design-patterns:-good-practices-and-structured-thinking-1"></a><a class="docs-heading-anchor-permalink" href="#Design-patterns:-good-practices-and-structured-thinking" title="Permalink"></a></h1><p>Design guiding principles:</p><ul><li>SOLID: Single Responsibility, Open/Closed, Liskov Substitution, Interface</li><li>Segregation, Dependency Inversion</li><li>DRY: Don&#39;t Repeat Yourself</li><li>KISS: Keep It Simple, Stupid!</li><li>POLA: Principle of Least Astonishment</li><li>YAGNI: You Aren&#39;t Gonna Need It (overengineering)</li><li>POLP: Principle of Least Privilege </li></ul><p>Julia does not fit into any methodological classes like <em>object-oriented</em> or <em>functional</em> programming. The key concept of julia is the <em>multiple dispatch</em>, which has <em>zero</em> runtime cost.</p><p>Many popular design concepts from other languages are solved using this simple principle. Multiple dispatch allows to </p><ul><li>composition vs. inheritance (L02?)</li><li>generalization problem</li><li>reusability (composition, @forward)</li><li>access restrictions (getter functions, redefining getproperty)<ul><li>closures - functions with states(), accepting </li></ul></li><li>piracy?</li><li>traits, multiple-inheritance</li></ul><h3 id="Design-patterns:-scoping-/-closure-/-opaque-closures-/-interfaces-/-traits"><a class="docs-heading-anchor" href="#Design-patterns:-scoping-/-closure-/-opaque-closures-/-interfaces-/-traits">Design patterns: scoping / closure / opaque closures / interfaces / traits</a><a id="Design-patterns:-scoping-/-closure-/-opaque-closures-/-interfaces-/-traits-1"></a><a class="docs-heading-anchor-permalink" href="#Design-patterns:-scoping-/-closure-/-opaque-closures-/-interfaces-/-traits" title="Permalink"></a></h3><ul><li>Anonymous functions</li><li>Closures for abstraction</li><li>Lecture example: monitoring gradient descend.<ul><li>function to create minibatch</li><li>callbacks for monitoring / early stopping / storing stuff / timed printing</li></ul></li><li>How type system allows efficient closures (most of the time, there is no performance penalty)</li><li>do syntax for readability</li><li>The poor state of interfaces: traits</li><li>LABS<ul><li>Small examples (GD?, Minibatching, )</li><li>Performance issues ()</li></ul></li></ul><h3 id="Implementation-of-closures-in-julia:-documentation"><a class="docs-heading-anchor" href="#Implementation-of-closures-in-julia:-documentation">Implementation of closures in julia: documentation</a><a id="Implementation-of-closures-in-julia:-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Implementation-of-closures-in-julia:-documentation" title="Permalink"></a></h3><p>Closure is a record storing a function together with an environment. The environment is a mapping associating each <em>free</em> variable of the function (variables that are used locally, but defined in an enclosing scope) with the value or reference to which the name was bound when the closure was created.</p><pre><code class="nohighlight hljs">function adder(x)
    return y-&gt;x+y
end</code></pre><p>is lowered to (roughly):</p><pre><code class="nohighlight hljs">struct ##1{T}
    x::T
end

(_::##1)(y) = _.x + y

function adder(x)
    return ##1(x)
end</code></pre><p>Note that the structure ##1 is not directly accessible. Allowing access restriction. </p><p>Usage of closures:</p><ul><li>callbacks: the function can also modify the enclosed variable.</li><li>abstraction: partial evaluation </li><li>can be used to imitate objects: </li></ul><p>https://stackoverflow.com/questions/39133424/how-to-create-a-single-dispatch-object-oriented-class-in-julia-that-behaves-l/39150509#39150509</p><div class="admonition is-category-theorem"><header class="admonition-header">Beware: Performance of captured variables</header><div class="admonition-body"><p>Inference of types may be difficult in closures: https://github.com/JuliaLang/julia/issues/15276    </p></div></div><h3 id="Expression-Problem"><a class="docs-heading-anchor" href="#Expression-Problem">Expression Problem</a><a id="Expression-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Expression-Problem" title="Permalink"></a></h3><p>Matrix of methods/types(data-structures)</p><p>| data \ methods | find_food | eat! |  |  | new | | –- | –– | –– | –- | –– | – | | Wolf |  | | | | | | Sheep | | | | | | | Grass | | | | | | | new |</p><p>We want to multiply matrices of different types.</p><p>Matmul make sense for all other types! matmul(Full,Full), matmul(Sparse,SVD)</p><p>OOP = define classes of matrices (maybe inheriting from abstract class Matrix) FP = define operations &quot;add&quot;, &quot;scalarmult&quot;, etc.</p><p>Solutions:</p><ol><li>multiple-dispatch = julia</li><li>open classes (monkey patching) = add methods to classes on the fly</li><li>visitor pattern = partial fix for OOP [extended visitor pattern using dynamic_cast]</li></ol><p>Julia multiple dispatch:</p><ul><li>special cases: <ul><li>method A^T*A: straightforward in general, specialized for SVD.</li><li>diagonal: </li><li>multiplication by a permutation matrix</li></ul></li></ul><h3 id="Subtyping,-Unions"><a class="docs-heading-anchor" href="#Subtyping,-Unions">Subtyping, Unions</a><a id="Subtyping,-Unions-1"></a><a class="docs-heading-anchor-permalink" href="#Subtyping,-Unions" title="Permalink"></a></h3><ul><li>the power of subtyping: Array{Float64} &lt;/: Array{Real}</li></ul><h3 id="Traits-multiple-inheritance"><a class="docs-heading-anchor" href="#Traits-multiple-inheritance">Traits = multiple inheritance</a><a id="Traits-multiple-inheritance-1"></a><a class="docs-heading-anchor-permalink" href="#Traits-multiple-inheritance" title="Permalink"></a></h3><p>https://github.com/JuliaLang/julia/issues/2345#issuecomment-54537633 https://github.com/andyferris/Traitor.jl https://github.com/mauro3/SimpleTraits.jl https://github.com/tk3369/BinaryTraits.jl</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../lecture_02/hw/">« Homework</a><a class="docs-footer-nextpage" href="../lab/">Lab »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.6 on <span class="colophon-date" title="Thursday 30 September 2021 12:11">Thursday 30 September 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
