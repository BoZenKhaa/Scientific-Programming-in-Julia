<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lab · Scientific Programming in Julia</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://JuliaTeachingCTU.github.io/Scientific-Programming-in-Julia/lecture_03/lab/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Scientific Programming in Julia logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Scientific Programming in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scientific Programming in Julia</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">1: Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/motivation/">Motivation</a></li><li><a class="tocitem" href="../../lecture_01/outline/">Outline</a></li><li><a class="tocitem" href="../../lecture_01/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_01/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">2: The power of Type System &amp; multiple dispatch</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_02/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_02/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_02/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">3: Design patterns</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Lab</a><ul class="internal"><li><a class="tocitem" href="#Reproduction"><span>Reproduction</span></a></li><li><a class="tocitem" href="#One-step-at-a-time"><span>One step at a time</span></a></li><li><a class="tocitem" href="#Simulate-the-world!"><span>Simulate the world!</span></a></li><li><a class="tocitem" href="#Smarter-callbacks-through-closures"><span>Smarter callbacks through closures</span></a></li><li><a class="tocitem" href="#Poisoned-Grass"><span>Poisoned Grass</span></a></li></ul></li><li><a class="tocitem" href="../hw/">Homework</a></li></ul></li><li><span class="tocitem">4: Packages development, environments, etc...</span></li><li><span class="tocitem">5: Benchmarking, profiling, and performance gotchas</span></li><li><span class="tocitem">6: Language introspection</span></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">7: Macros</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/macros/">Macros</a></li></ul></li><li><span class="tocitem">8: Introduction to automatic differentiation</span></li><li><span class="tocitem">9: Manipulating intermediate representation</span></li><li><span class="tocitem">10: Different levels of parallel programming</span></li><li><span class="tocitem">11: Julia for GPU programming</span></li><li><span class="tocitem">12: Uncertainty propagation in ODE</span></li><li><span class="tocitem">13: Learning ODE from data</span></li><li><a class="tocitem" href="../../how_to_submit_hw/">How to submit homeworks</a></li><li><a class="tocitem" href="../../howto/">How To ...</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">3: Design patterns</a></li><li class="is-active"><a href>Lab</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lab</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaTeachingCTU/Scientific-Programming-in-Julia/blob/master/docs/src/lecture_03/lab.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Lab-3:-Predator-Prey-Agents"><a class="docs-heading-anchor" href="#Lab-3:-Predator-Prey-Agents">Lab 3: Predator-Prey Agents</a><a id="Lab-3:-Predator-Prey-Agents-1"></a><a class="docs-heading-anchor-permalink" href="#Lab-3:-Predator-Prey-Agents" title="Permalink"></a></h1><p>In this lab we will finalize our predator-prey agent simulation such that we can simulate a number of steps in order to get a plot like below.</p><p><img src="../pred-prey.png" alt="img"/></p><h2 id="Reproduction"><a class="docs-heading-anchor" href="#Reproduction">Reproduction</a><a id="Reproduction-1"></a><a class="docs-heading-anchor-permalink" href="#Reproduction" title="Permalink"></a></h2><div class="admonition is-category-exercise">
<header class="admonition-header">Exercise</header>
<div class="admonition-body"><p>The only other thing that our animals are able to do apart from eating will be reproducing. Write a function <code>reproduce!</code> that take an <code>AbstractAnimal</code> and a <code>World</code>. Reproducing will cost an animal half of its energy and add an identical copy of the given animal to the world.</p></div></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><pre><code class="language-julia hljs">function reproduce!(a::AbstractAnimal, w::World)
    a.energy /= 2
    push!(w.agents, deepcopy(a))
end</code></pre></p></details><h2 id="One-step-at-a-time"><a class="docs-heading-anchor" href="#One-step-at-a-time">One step at a time</a><a id="One-step-at-a-time-1"></a><a class="docs-heading-anchor-permalink" href="#One-step-at-a-time" title="Permalink"></a></h2><div class="admonition is-category-exercise">
<header class="admonition-header">Exercise</header>
<div class="admonition-body"><p>One iteration of our simulation will be carried out by a function called <code>agent_step!(::AbstractAgent, ::World)</code>. Implement one method for <code>AbstractPlant</code>s and one for <code>AbstractAnimal</code>s.</p><p>An <code>AbstractPlant</code> will grow if it is not fully grown (i.e. decrease growth counter).  If the growth counter has reached zero, the <code>fully_grown</code> flag has to be set to zero and the counter reset to <code>regrowth_time</code>.</p><p>An <code>AbstractAnimal</code> will loose one unit of energy in every step.  Then it will try to find food and eat. After eating, if its energy is less than zero, the animal dies.  If it is still alive, it will try to reproduce with the probablitiy <span>$p_r$</span>.</p></div></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><pre><code class="language-julia hljs">function agent_step!(a::AbstractPlant, w::World)
    if !a.fully_grown
        if a.countdown &lt;= 0
            a.fully_grown = true
            a.countdown = a.regrowth_time
        else
            a.countdown -= 1
        end
    end
    return a
end

function agent_step!(a::A, w::World) where A&lt;:AbstractAnimal
    a.energy -= 1
    dinner = find_food(a,w)
    eat!(a, dinner, w)
    if a.energy &lt; 0
        kill_agent!(a,w)
        return
    end
    if rand() &lt;= a.reproduction_prob
        reproduce!(a,w)
    end
    return a
end</code></pre></p></details><h2 id="Simulate-the-world!"><a class="docs-heading-anchor" href="#Simulate-the-world!">Simulate the world!</a><a id="Simulate-the-world!-1"></a><a class="docs-heading-anchor-permalink" href="#Simulate-the-world!" title="Permalink"></a></h2><div class="admonition is-category-exercise">
<header class="admonition-header">Exercise</header>
<div class="admonition-body"><p>The last function we need to run our simulation just needs to run a number of steps. In practice we often want varying logging behaviour which we can implement nicely using <em>callbacks</em>. Implement a function <code>simulate!(w::World, iters::Int; callbacks=[])</code> which applies a number of callbacks of the form <code>callback(::World)</code> after each iteration.</p><p>An exemplary callback could just log the agent count at ever step:</p><pre><code class="language-julia hljs">log_count(w::World) = @info agent_count(w)</code></pre></div></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><pre><code class="language-julia hljs">function simulate!(w::World, iters::Int; callbacks=[])
    for i in 1:iters
        for a in w.agents
            agent_step!(a,w)
        end
        for cb in callbacks
            cb(w)
        end
    end
end</code></pre></p></details><p>Now lets try to run our first fully fledged simulation!  Below you can find some parameters that will often result in nice oscillations like in the plot at the beginning of the lab.</p><pre><code class="language-julia hljs">n_grass       = 500
regrowth_time = 17.0

n_sheep         = 100
Δenergy_sheep   = 5.0
sheep_reproduce = 0.5
sheep_foodprob  = 0.4

n_wolves       = 8
Δenergy_wolf   = 17.0
wolf_reproduce = 0.03
wolf_foodprob  = 0.02

gs = [Grass(true,regrowth_time,regrowth_time) for _ in 1:n_grass]
ss = [Sheep(2*Δenergy_sheep,Δenergy_sheep,sheep_reproduce, sheep_foodprob) for _ in 1:n_sheep]
ws = [Wolf(2*Δenergy_wolf,Δenergy_wolf,wolf_reproduce, wolf_foodprob) for _ in 1:n_wolves]

w = World(vcat(gs,ss,ws))

cbs = [w-&gt;(@info agent_count(w))]
simulate!(w, 10, callbacks=cbs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">[ Info: Dict(:Wolf =&gt; 8, :Grass =&gt; 411, :Sheep =&gt; 211)
[ Info: Dict(:Wolf =&gt; 8, :Grass =&gt; 294, :Sheep =&gt; 368)
[ Info: Dict(:Wolf =&gt; 8, :Grass =&gt; 220, :Sheep =&gt; 477)
[ Info: Dict(:Wolf =&gt; 8, :Grass =&gt; 156, :Sheep =&gt; 495)
[ Info: Dict(:Wolf =&gt; 8, :Grass =&gt; 101, :Sheep =&gt; 528)
[ Info: Dict(:Wolf =&gt; 8, :Grass =&gt; 70, :Sheep =&gt; 492)
[ Info: Dict(:Wolf =&gt; 8, :Grass =&gt; 56, :Sheep =&gt; 410)
[ Info: Dict(:Wolf =&gt; 8, :Grass =&gt; 45, :Sheep =&gt; 333)
[ Info: Dict(:Wolf =&gt; 8, :Grass =&gt; 38, :Sheep =&gt; 257)
[ Info: Dict(:Wolf =&gt; 9, :Grass =&gt; 33, :Sheep =&gt; 205)</code></pre><h2 id="Smarter-callbacks-through-closures"><a class="docs-heading-anchor" href="#Smarter-callbacks-through-closures">Smarter callbacks through closures</a><a id="Smarter-callbacks-through-closures-1"></a><a class="docs-heading-anchor-permalink" href="#Smarter-callbacks-through-closures" title="Permalink"></a></h2><div class="admonition is-category-exercise">
<header class="admonition-header">Exercise</header>
<div class="admonition-body"><p>Often we want our callbacks to be executed only every <span>$N$</span>th step.  Implement a function <code>every_nth(f::Function,n::Int)</code> that takes a function and uses a closure to construct another function that only calls <code>f</code> every <code>n</code> calls to the function <code>fn</code> that is returned by <code>every_nth(f,n)</code>.</p><p>Use <code>every_nth</code> to log the agent count every 5th step of your simulation and to save every second agent count.</p></div></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><pre><code class="language-julia hljs">function every_nth(f::Function, n::Int)
    i = 1
    function callback(w::World)
        # display(i) # comment this out to see how the counter increases
        if i == n
            f(w)
            i = 1
        else
            i += 1
        end
    end
end

# construct a global variable to store the trajectories
counts = Dict(n=&gt;[c] for (n,c) in agent_count(w))
# callback to save current counts
function _save(w::World)
    for (n,c) in agent_count(w)
        push!(counts[n],c)
    end
end

# create callbacks
logcb = every_nth(w-&gt;(@info agent_count(w)), 5)
savecb = every_nth(_save, 2)

simulate!(w, 200, callbacks=[logcb, savecb])

# you can now plot the trajectories like this
using Plots
plt = plot()
for (n,c) in counts
    plot!(plt, c, label=&quot;$n&quot;, lw=2)
end
display(plt)</code></pre></p></details><h2 id="Poisoned-Grass"><a class="docs-heading-anchor" href="#Poisoned-Grass">Poisoned Grass</a><a id="Poisoned-Grass-1"></a><a class="docs-heading-anchor-permalink" href="#Poisoned-Grass" title="Permalink"></a></h2><div class="admonition is-category-exercise">
<header class="admonition-header">Exercise</header>
<div class="admonition-body"><p>In the previous exercises you have seen that multiple dispatch makes it easy to add new methods to a given type (much easier than in OOP!).  In this exercise you will see that it is just as easy to add a completely new type to our hierarchy and reuse the methods that we have already defined (similar to inheritance in OOP).</p><p>We have a few essential functions: <code>agent_step!</code>, <code>reproduce!</code>, <code>find_food</code>, <code>eats</code>, and <code>eat!</code>. If you look at their type signatures you can see that the first three already operate on any <code>AbstractAnimal</code>/<code>AbstractPlant</code>. This means that for any subtype that has the expected fields (<code>energy</code>, <code>Δenergy</code>, <code>food_prob</code>, and <code>reproduction_prob</code>) these functions already work.</p><p>The only methods we have to implement for a new animal or plant are the <code>eats</code> and <code>eat!</code> methods.  So, lets implement a <code>PoisonedGrass</code> which will <em>decrease</em> the energy of a sheep that ate it.</p><p>How much poisoned grass can you add to the simulation without wiping out the sheep population?</p></div></div>
<details class = "solution-body">
<summary class = "solution-header">Solution:</summary><p><pre><code class="language-julia hljs">mutable struct PoisonedGrass &lt;: AbstractPlant
    fully_grown::Bool
    regrowth_time::Int
    countdown::Int
end
PoisonedGrass(t) = PoisonedGrass(false, t, rand(1:t))

function eat!(sheep::Sheep, grass::PoisonedGrass, w::World)
     if grass.fully_grown
        grass.fully_grown = false
        sheep.energy -= sheep.Δenergy
    end
end

eats(::Sheep,::PoisonedGrass) = true</code></pre></p></details></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../lecture_02/hw/">« Homework</a><a class="docs-footer-nextpage" href="../hw/">Homework »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Wednesday 1 September 2021 13:11">Wednesday 1 September 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
