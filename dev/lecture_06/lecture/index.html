<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lecture · Scientific Programming in Julia</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://JuliaTeachingCTU.github.io/Scientific-Programming-in-Julia/lecture_06/lecture/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Scientific Programming in Julia logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Scientific Programming in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scientific Programming in Julia</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">1: Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/motivation/">Motivation</a></li><li><a class="tocitem" href="../../lecture_01/basics/">Basics</a></li><li><a class="tocitem" href="../../lecture_01/demo/">Examples</a></li><li><a class="tocitem" href="../../lecture_01/outline/">Outline</a></li><li><a class="tocitem" href="../../lecture_01/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_01/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">2: The power of Type System &amp; multiple dispatch</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_02/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_02/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_02/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">3: Design patterns</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_03/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_03/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_03/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">4: Packages development, Unit Tests &amp; CI</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_04/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_04/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_04/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">5: Benchmarking, profiling, and performance gotchas</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_05/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_05/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_05/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox" checked/><label class="tocitem" for="menuitem-8"><span class="docs-label">6: Language introspection</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Lecture</a><ul class="internal"><li><a class="tocitem" href="#Stages-of-compilation"><span>Stages of compilation</span></a></li><li><a class="tocitem" href="#General-notes-on-metaprogramming"><span>General notes on metaprogramming</span></a></li><li><a class="tocitem" href="#Expressions"><span>Expressions</span></a></li><li><a class="tocitem" href="#Computer-algebra-system"><span>Computer algebra system</span></a></li></ul></li><li><a class="tocitem" href="../lab/">Lab</a></li><li><a class="tocitem" href="../hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">7: Macros</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_07/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_07/hw/">Homework</a></li></ul></li><li><span class="tocitem">8: Introduction to automatic differentiation</span></li><li><span class="tocitem">9: Manipulating intermediate representation</span></li><li><span class="tocitem">10: Different levels of parallel programming</span></li><li><span class="tocitem">11: Julia for GPU programming</span></li><li><span class="tocitem">12: Uncertainty propagation in ODE</span></li><li><span class="tocitem">13: Learning ODE from data</span></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">6: Language introspection</a></li><li class="is-active"><a href>Lecture</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lecture</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaTeachingCTU/Scientific-Programming-in-Julia/blob/master/docs/src/lecture_06/lecture.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="introspection"><a class="docs-heading-anchor" href="#introspection">Language introspection</a><a id="introspection-1"></a><a class="docs-heading-anchor-permalink" href="#introspection" title="Permalink"></a></h1><p>Materials:</p><ul><li>Julia&#39;s manula on <a href="https://docs.julialang.org/en/v1/manual/metaprogramming/">metaprogramming</a></li><li>Steven Johnson&#39;s <a href="https://www.youtube.com/watch?v=mSgXWpvQEHE">keynote talk @ JuliaCon 2019</a></li><li>Andy Ferris&#39;s <a href="https://www.youtube.com/watch?v=SeqAQHKLNj4">workshop @ JuliaCon 2018</a></li><li><a href="https://github.com/johnmyleswhite/julia_tutorials">From Macros to DSL</a> by John Myles White </li></ul><h2 id="Stages-of-compilation"><a class="docs-heading-anchor" href="#Stages-of-compilation">Stages of compilation</a><a id="Stages-of-compilation-1"></a><a class="docs-heading-anchor-permalink" href="#Stages-of-compilation" title="Permalink"></a></h2><p>Julia (as any modern compiler) uses several stages to convert source code to native code. Let&#39;s recap them</p><ul><li>parsing the source code to <strong>abstract syntax tree</strong> (AST)</li><li>lowering the abstract syntax tree <strong>static single assignment</strong> form (SSA) <a href="https://en.wikipedia.org/wiki/Static_single_assignment_form">see wiki</a></li><li>assigniting types to variables and performing type inference on called functions</li><li>lowering the typed code to LLVM intermediate representation (LLVM Ir)</li><li>using LLVM compiler to produce a native code.</li></ul><h3 id="Example:-Fibonacci-numbers"><a class="docs-heading-anchor" href="#Example:-Fibonacci-numbers">Example: Fibonacci numbers</a><a id="Example:-Fibonacci-numbers-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Fibonacci-numbers" title="Permalink"></a></h3><p>Example taken from <a href="https://stackoverflow.com/questions/43453944/what-is-the-difference-between-code-native-code-typed-and-code-llvm-in-julia">StackOverflow</a> Consider function for example a function computing the fibonacci</p><pre><code class="language-julia hljs">function nextfib(n)
	a, b = one(n), one(n)
	while b &lt; n
		a, b = b, a + b
	end
	return b
end</code></pre><ul><li><strong>Parsing</strong> The first thing the compiler do is that it will parse the source code (represented as a string) to the abstract syntax tree. We can inspect the results of this stage as </li></ul><pre><code class="language-julia hljs">julia&gt; parsed_fib = Meta.parse(
&quot;&quot;&quot;
	function nextfib(n)
		a, b = one(n), one(n)
		while b &lt; n
			a, b = b, a + b
		end
		return b
	end
&quot;&quot;&quot;)
:(function nextfib(n)
      #= none:1 =#
      #= none:2 =#
      (a, b) = (one(n), one(n))
      #= none:3 =#
      while b &lt; n
          #= none:4 =#
          (a, b) = (b, a + b)
      end
      #= none:6 =#
      return b
  end)</code></pre><p>AST is a tree representation of the source code, where the parser has already identified what is function call, argument blocks, etc. The parsed code can be read and modified from Julia at your wish (the homoiconicity of the language). Using <code>TreeView</code></p><pre><code class="language-julia hljs">using TreeView, TikzPictures
g = tikz_representation(walk_tree(parsed_fib))
TikzPictures.save(SVG(&quot;parsed_fib.svg&quot;), g)</code></pre><p><img src="../parsed_fib.svg" alt="parsed_fib.svg"/></p><p>We can see that the AST is indeed a tree, with <code>function</code> being a root node (caused by us parsing a function). Each inner node represents a function call with childrens of the inner node being its arguments. An interesting inner node is the <code>Block</code> representing a sequence of statements, where we can also see inserted information about lines in the source code. Lisp-like S-Expression can be printed using <code>Meta.show_sexpr(parsed_fib)</code>.</p><ul><li>The next stage is <strong>lowering</strong>, where AST is converted to Static Single Assignment Form (SSA), in which &quot;each variable is assigned exactly once, and every variable is defined before it is used&quot;. Loops and conditionals are transformed into gotos and labels using a single unless/goto construct (this is not exposed in user-level Julia). </li></ul><pre><code class="language-julia hljs">julia&gt; @code_lowered nextfib(3)
CodeInfo(
1 ─ %1 = Main.one(n)
│   %2 = Main.one(n)
│        a = %1
└──      b = %2
2 ┄ %5 = b &lt; n
└──      goto #4 if not %5
3 ─ %7 = b
│   %8 = a + b
│        a = %7
│        b = %8
└──      goto #2
4 ─      return b
)</code></pre><p>or alternatively <code>lowered_fib = Meta.lower(@__MODULE__, parsed_fib)</code>. For inserted debugging informations, there is an option <code>@code_lowered debuginfo=:source nextfib(123)</code>. We can see that  	- compiler has introduced a lot of variables  	- <code>while</code> (and <code>for</code>) loops has been replaced by a <code>goto</code> prepended by conditional statements</p><ul><li><strong>Code typying</strong> is the process in which the compiler attaches types to variables and tries to infer types of objects returned from called functions. If the compiler fails to infer the returned type, it will give the variable type <code>Any</code>, in which case a dynamic dispatch will be used in subsequent operations with the variable. Inspecting typed code is therefore important for detecting type instabilities (the process can be difficult and error prone, fortunatelly, new tools like <code>Jet.jl</code> might simplify this task). The output of typing can be inspected using <code>@code_typed</code> macro (<code>@code_warntype</code> further highlights type instabilities.) The macro is used to simplify the call, as you need to know the type of parameters, you can directly call <code>InteractiveUtils.code_typed(nextfib, (typeof(3),))</code>.</li></ul><pre><code class="language-julia hljs">julia&gt; @code_typed nextfib(3)
CodeInfo(
1 ─      nothing::Nothing
2 ┄ %2 = φ (#1 =&gt; 1, #3 =&gt; %6)::Int64
│   %3 = φ (#1 =&gt; 1, #3 =&gt; %2)::Int64
│   %4 = Base.slt_int(%2, n)::Bool
└──      goto #4 if not %4
3 ─ %6 = Base.add_int(%3, %2)::Int64
└──      goto #2
4 ─      return %2
) =&gt; Int64</code></pre><p>We can see that  	- some calls have been inlined, e.g. <code>one(n)</code> was replaced by <code>1</code> and the type was inferred as <code>Int</code>.  	-  The expression <code>b &lt; n</code> has been replaced with its implementation in terms of the <code>slt_int</code> intrinsic (&quot;signed integer less than&quot;) and the result of this has been annotated with return type <code>Bool</code>.  	- The expression <code>a + b</code> has been also replaced with its implementation in terms of the <code>add_int</code> intrinsic and its result type annotated as Int64.  	- And the return type of the entire function body has been annotated as <code>Int64</code>. 	- The phi-instruction <code>%2 = φ (#1 =&gt; 1, #3 =&gt; %6)</code> is a selector function, which returns the value depending on from which branch do you come from. In this case, variable <code>%2</code> will have value 1, if the control was transfered from block <code>#1</code> and it will have value copied from variable <code>%6</code> if the control was transferreed from block <code>3</code> <a href="https://llvm.org/docs/LangRef.html#phi-instruction">see also</a>. 	When we have called <code>@code_lower</code>, the role of types of the argument was in selecting the approapriate function body, they are needed for multiple dispatch. Contrary in <code>@code_typed</code>, the types of parameters determine the choice if inner methods that needs to be called (again the multiple dispatch), which can trigger other optimization, such as inlining, which seen in <code>One(n)</code>. </p><ul><li>** Lowering to LLVM IR** LLVM IR. Julia uses the LLVM compiler framework to generate machine code. LLVM stands for low-level virtual machine and it is basis of many modern compilers (see <a href="https://en.wikipedia.org/wiki/LLVM">wiki</a>).</li></ul><p>We can see the textual form of code lowered to LLVM IR by invoking </p><pre><code class="language-julia hljs">julia&gt; @code_llvm nextfib(3)
;  @ REPL[10]:1 within `nextfib&#39;
define i64 @julia_nextfib_890(i64 signext %0) {
top:
  br label %L2

L2:                                               ; preds = %L2, %top
  %value_phi = phi i64 [ 1, %top ], [ %1, %L2 ]
  %value_phi1 = phi i64 [ 1, %top ], [ %value_phi, %L2 ]
;  @ REPL[10]:3 within `nextfib&#39;
; ┌ @ int.jl:83 within `&lt;&#39;
   %.not = icmp slt i64 %value_phi, %0
; └
;  @ REPL[10]:4 within `nextfib&#39;
; ┌ @ int.jl:87 within `+&#39;
   %1 = add i64 %value_phi1, %value_phi
; └
;  @ REPL[10]:3 within `nextfib&#39;
  br i1 %.not, label %L2, label %L8

L8:                                               ; preds = %L2
;  @ REPL[10]:6 within `nextfib&#39;
  ret i64 %value_phi
}</code></pre><p>LLVM code can be tricky to understand first, but one get used to it. Notice references to the source code, which helps orientation. We can read 	- code start by jumping to label L2, from where it reads values of two variables to two &quot;registers&quot; <code>value_phi</code> and <code>value_phi1</code> (variables in LLVM starts with <code>%</code>).  	- Both registers are treated as <code>int64</code> and initialized by <code>1</code>.  	- <code>[ 1, %top ], [ %value_phi, %L2 ]</code> means that values are initialized as <code>1</code> if you come from the label <code>top</code> and as value <code>value_phi</code> if you come from <code>%2</code>. 	- <code>icmp slt i64 %value_phi, %0</code> compares the variable <code>%value_phi</code> to the content of variable <code>%0</code>. Notice the anotation that we are comparing <code>Int64</code>. 	- <code>%1 = add i64 %value_phi1, %value_phi</code> adds two variables <code>%value_phi1</code> and <code>%value_phi</code>. Notce again than we are using <code>Int64</code> addition.  	- <code>br i1 %.not, label %L2, label %L8</code> implements a conditional jump depending on the content of <code>%.not</code> variable.  	- <code>ret i64 %value_phi</code> returns the value indicating it to be an <code>Int64</code>. It is not expected you will be directly operating on the LLVM code, though there are libraries which does that. For example <code>Enzyme.jl</code> performs automatic differentiation of LLVM code, which has the benefit of being able to take a gradeint through <code>setdiff</code>.</p><ul><li><strong>Native code</strong> The last stage is generation of the native code, which Julia executes. The native code can depend on your platform, especially if you use SIMD registers. The compiled code can be viewed as</li></ul><pre><code class="language-julia hljs">julia&gt; @code_native nextfib(3)
	.section	__TEXT,__text,regular,pure_instructions
; ┌ @ REPL[10]:1 within `nextfib&#39;
	movl	$1, %ecx
	movl	$1, %eax
	nopw	(%rax,%rax)
L16:
	movq	%rax, %rdx
	movq	%rcx, %rax
; │ @ REPL[10]:4 within `nextfib&#39;
; │┌ @ int.jl:87 within `+&#39;
	addq	%rcx, %rdx
	movq	%rdx, %rcx
; │└
; │ @ REPL[10]:3 within `nextfib&#39;
; │┌ @ int.jl:83 within `&lt;&#39;
	cmpq	%rdi, %rax
; │└
	jl	L16
; │ @ REPL[10]:6 within `nextfib&#39;
	retq
	nopw	%cs:(%rax,%rax)
; └</code></pre><p>and the output is used mainly for debugging / inspection. </p><h2 id="General-notes-on-metaprogramming"><a class="docs-heading-anchor" href="#General-notes-on-metaprogramming">General notes on metaprogramming</a><a id="General-notes-on-metaprogramming-1"></a><a class="docs-heading-anchor-permalink" href="#General-notes-on-metaprogramming" title="Permalink"></a></h2><p>According to an excellent talk of Steven Johnson mentioned above, you shoul use metaprogramming sparingly, as it is very powerfull, but it is generally difficult to read and it can lead to unexpected errors. Julia allows you to interact with the compiler at two levels.</p><ol><li>After the code is parsed to AST, you can modify it through <strong>macros</strong>.</li><li>When SSA form is being typed, you can create custom functions trough the <strong>generated functions</strong>.</li><li>More functionalities are coming from through the <a href="https://github.com/JuliaCompilerPlugins">JuliaCompilerPlugins</a> project, but we will not talk about them (yet). </li></ol><h2 id="Expressions"><a class="docs-heading-anchor" href="#Expressions">Expressions</a><a id="Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Expressions" title="Permalink"></a></h2><p>Abstract Syntax Tree, the output of Julia&#39;s parser, is expressed using Julia&#39;s own datastructures, which means that you can freely manipulate it (and constructed) from the language itself. This property is called <strong>homoiconicity</strong>. Julia&#39;s compiler allows you to intercept compilation just after it has parsed the source code, but before we will take advantage of it, we will spent time with just AST and how it is constructed.</p><p>The best way to inspect the AST is through the combination </p><ul><li><code>Meta.parse,</code>  which parses the source code to AST, </li><li><code>dump</code> which print AST to terminal, </li><li><code>eval</code> which evaluates the AST within the current module.</li></ul><p>Let&#39;s start by investigating a very simple statement <code>1+1</code>. An alternative to <code>Meta.parse(&quot;1 + 1&quot;)</code> is <code>:(1 + 1)</code> or <code>quote ... end</code></p><pre><code class="language-julia hljs">julia&gt; p = :(1+1)
:(1 + 1)

julia&gt; typeof(p)
Expr

julia&gt; dump(p)
Expr
  head: Symbol call
  args: Array{Any}((3,))
    1: Symbol +
    2: Int64 1
    3: Int64 1</code></pre><p>Notice that the parsed code <code>p</code> is of type <code>Expr</code>. From Julia&#39;s help: <em>A type representing compound expressions in parsed julia code (ASTs). Each expression consists: of a head Symbol identifying which kind of expression it is (e.g. a call, for loop, conditional statement, etc.), and subexpressions (e.g. the arguments of a call). The subexpressions are stored in a Vector{Any} field called args.</em> Since <code>Expr</code> is a Julia structure, we can construct it manually as we can construct any other structure</p><pre><code class="language-julia hljs">julia&gt; Expr(:call, :+, 1 , 1) |&gt; dump
Expr
  head: Symbol call
  args: Array{Any}((3,))
    1: Symbol +
    2: Int64 1
    3: Int64 1</code></pre><p>yielding to the same structure as we have created above. In the above, you will notice that instead of denoting names with <code>Strings</code>, we use <code>Symbol</code>s, which is a name for string prepend with <code>:</code> and which can be constructed also by <code>Symbol(call)</code>. Symbols are &quot;interned strings&quot;, which means that compiler attaches each string a unique identifier (integer), such that it can quickly compare them. Compiler uses Symbols exclusively and the important feature is that they can be quickly compared. To conclude, <code>Symbol</code> is the compiler&#39;s <code>String</code> –- u unique identifier. Expressions can be evaluated using <code>eval</code>, as has been said. to programmatically evaluate our expression, let&#39;s do </p><pre><code class="language-julia hljs">e = Expr(:call, :+, 1, 1)
eval(e)</code></pre><p>We are free to use variables (identified by symbols) inside the expression </p><pre><code class="language-julia hljs">e = Expr(:call, :+, :x, 5)
eval(e)</code></pre><p>but unless they are not defined within the scope, the expression cannot produce a meaningful result</p><pre><code class="nohighlight hljs">x = 3
eval(e)</code></pre><p>Since the expression is a Julia structure, we are free to manipulate. Let&#39;s for example substitutue <code>x</code> in  <code>e = :(x + 5)</code> with <code>2x</code>.</p><pre><code class="language-julia hljs">e = :(x + 5)
e.args = map(e.args) do a 
	a == :x ? :(2*x) : a 
end</code></pre><p>and verify that the results are correct.</p><pre><code class="nohighlight hljs">julia&gt; dump(e)
Expr
  head: Symbol call
  args: Array{Any}((3,))
    1: Symbol +
    2: Expr
      head: Symbol call
      args: Array{Any}((3,))
        1: Symbol *
        2: Int64 2
        3: Symbol x
    3: Int64 5

julia&gt; eval(e)
11</code></pre><p>As mentioned, the manipulation with Expression can be arbitrary and we can go arbitrarily deep. In the above example, we have been operating directly on the arguments. But what if <code>x</code> would be deeper in the expression, as is for example in <code>2(3 + x) + 2(2 - x)</code>? We can implement the substitution using multiple dispatch as we would do when implementing any other function in Julia.</p><pre><code class="language-julia hljs">replace_x(x::Symbol) = x == :x ? :(2*x) : x
replace_x(e::Expr) = Expr(e.head, map(replace_x, e.args)...)
replace_x(u) = u</code></pre><p>which works as has been promissed.</p><pre><code class="nohighlight hljs">julia&gt; e = :(2(3 + x) + 2(2 - x))
:(2 * (3 + x) + 2 * (2 - x))
julia&gt; f = replace_x(e)
:(2 * (3 + 2x) + 2 * (2 - 2x))</code></pre><p>Sometimes, we want to operate on the block of code. This is easiest to do with <code>quote ... end</code>. We demonstrate the functionality with the above example</p><pre><code class="language-julia hljs">e = quote 
	a = x + 3
	b = 2 - x
	2a + 2b
end</code></pre><pre><code class="language-julia hljs">julia&gt; replace_x(e)
quote
    #= REPL[66]:2 =#
    a = 2x + 3
    #= REPL[66]:3 =#
    b = 2 - 2x
    #= REPL[66]:4 =#
    2a + 2b
end</code></pre><p>https://github.com/FluxML/MacroTools.jl</p><h2 id="Computer-algebra-system"><a class="docs-heading-anchor" href="#Computer-algebra-system">Computer algebra system</a><a id="Computer-algebra-system-1"></a><a class="docs-heading-anchor-permalink" href="#Computer-algebra-system" title="Permalink"></a></h2><ul><li>Metatheory</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../lecture_05/hw/">« Homework</a><a class="docs-footer-nextpage" href="../lab/">Lab »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Monday 1 November 2021 17:37">Monday 1 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
