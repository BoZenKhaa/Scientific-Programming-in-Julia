<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lecture · Scientific Programming in Julia</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://JuliaTeachingCTU.github.io/Scientific-Programming-in-Julia/lecture_12/lecture/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Scientific Programming in Julia logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Scientific Programming in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scientific Programming in Julia</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation/">Installation</a></li><li><a class="tocitem" href="../../projects/">Projects</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">1: Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/motivation/">Motivation</a></li><li><a class="tocitem" href="../../lecture_01/basics/">Basics</a></li><li><a class="tocitem" href="../../lecture_01/demo/">Examples</a></li><li><a class="tocitem" href="../../lecture_01/outline/">Outline</a></li><li><a class="tocitem" href="../../lecture_01/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_01/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">2: The power of Type System &amp; multiple dispatch</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_02/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_02/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_02/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">3: Design patterns</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_03/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_03/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_03/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">4: Packages development, Unit Tests &amp; CI</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_04/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_04/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_04/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">5: Benchmarking, profiling, and performance gotchas</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_05/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_05/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_05/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">6: Language introspection</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_06/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_06/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_06/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox"/><label class="tocitem" for="menuitem-10"><span class="docs-label">7: Macros</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_07/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_07/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-11" type="checkbox"/><label class="tocitem" for="menuitem-11"><span class="docs-label">8: Introduction to automatic differentiation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_08/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_08/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_08/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-12" type="checkbox"/><label class="tocitem" for="menuitem-12"><span class="docs-label">9: Manipulating intermediate representation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_09/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_09/lab/">Lab</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-13" type="checkbox"/><label class="tocitem" for="menuitem-13"><span class="docs-label">10: Different levels of parallel programming</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_10/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_10/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_10/hw/">Homework</a></li></ul></li><li><span class="tocitem">11: Julia for GPU programming</span></li><li><input class="collapse-toggle" id="menuitem-15" type="checkbox" checked/><label class="tocitem" for="menuitem-15"><span class="docs-label">12: Uncertainty propagation in ODE</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Lecture</a><ul class="internal"><li><a class="tocitem" href="#Uncertainty-propagation"><span>Uncertainty propagation</span></a></li><li><a class="tocitem" href="#Vector-uncertainty"><span>Vector uncertainty</span></a></li><li class="toplevel"><a class="tocitem" href="#Manipulating-ODEs"><span>Manipulating ODEs</span></a></li></ul></li></ul></li><li><span class="tocitem">13: Learning ODE from data</span></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">12: Uncertainty propagation in ODE</a></li><li class="is-active"><a href>Lecture</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lecture</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaTeachingCTU/Scientific-Programming-in-Julia/blob/master/docs/src/lecture_12/lecture.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p>Ordinary Differencial equation</p><p>Differential equations are commonly used in science to describe many aspects of the physical world, ranging from dynamical systems, curves in space, to a complex multi-physics phenomena. </p><p>As an example, consider a simple non-linear ordinary differential equation:</p><p class="math-container">\[\begin{align}
\dot{x}&amp;=\alpha x-\beta xy,\\\dot{y}&amp;=-\delta y+\gamma xy, 
\end{align}\]</p><p>Which describes behavior of a predator-pray models in continuous times:</p><ul><li>x is the population of prey (sheep),</li><li>y is the population of predator (wolfes)</li><li>derivatives represent instantaneous growth rates of the populations</li><li><span>$t$</span> is the time and <span>$\alpha, \beta, \gamma, \delta$</span> are parameters.</li></ul><p>Can be written in vector arguments <span>$\mathbf{x}=[x,y]$</span>:</p><p class="math-container">\[\frac{d\mathbf{x}}{dt}=f(\mathbf{x},\theta)\]</p><p>with arbitrary function <span>$f$</span> with vector of parameters <span>$\theta$</span>.</p><p>The first steps we may want to do with an ODE is to see it&#39;s evolution in time. The most simple approach is to discretize the time axis into steps: <span>$t = [t_1, t_2, t_3, \ldots t_T]$</span> and evaluate solution at these points.</p><p>Replacing derivatives by differences:</p><p class="math-container">\[\dot x \leftarrow \frac{x_t-x_{t-1}}{\Delta t}\]</p><p>we can derive a general  scheme (Euler solution):</p><p class="math-container">\[\mathbf{x}_t = \mathbf{x}_{t-1} + \Delta{}t f(\mathbf{x}_t,\theta)\]</p><p>which can be written genericaly in julia :</p><pre><code class="language-julia hljs">
function f(x,θ)
  α,β,γ,δ = θ
  x1,x2=x
   dx1 = α*x1 - β*x1*x2
   dx2 = δ*x1*x2 - γ*x2
  [dx1,dx2]
end

function solve(f,x0::AbstractVector,θ,dt,N)
  X = hcat([zero(x0) for i=1:N]...)
  X[:,1]=x0
  for t=1:N-1
     X[:,t+1]=X[:,t]+dt*f(X[:,t],θ)
  end
  X
end</code></pre><p>Is trivial but works:</p><p><img src="../lotka.svg" alt/></p><h2 id="Uncertainty-propagation"><a class="docs-heading-anchor" href="#Uncertainty-propagation">Uncertainty propagation</a><a id="Uncertainty-propagation-1"></a><a class="docs-heading-anchor-permalink" href="#Uncertainty-propagation" title="Permalink"></a></h2><p>Prediction of the ODE model is valid only if all parameters and all initial conditions are accurate. This is almost never the case. While the number of sheep can be known, the number of wolfes in a forest is more uncertain. The same model holds for predator-prey in insects where the number of individuals can be only estimated.</p><p>Uncertain initial conditions:</p><ul><li>number given by a probability distribution </li><li>interval <span>$[0.8,1.2]$</span> corresponds to uniform distribution <span>$U(0.8,1.2)$</span></li><li>gaussian <span>$N(\mu,\sigma)$</span>, with mean <span>$\mu$</span> and standard deviation <span>$\sigma$</span> e.g. <span>$N(1,0.1)$</span></li><li>more complicated distributins are more realistic (the number of animals is not negative!)</li></ul><h3 id="Ensemble-approach"><a class="docs-heading-anchor" href="#Ensemble-approach">Ensemble approach</a><a id="Ensemble-approach-1"></a><a class="docs-heading-anchor-permalink" href="#Ensemble-approach" title="Permalink"></a></h3><p>The most simple approach is to represent distribution by an empirical density = discrete samples.</p><p class="math-container">\[p(x)\approx \frac{1}{K}\sum_{k=1}^{K} \delta(x-x^{(k)})\]</p><p>In the case of a Gaussian, we just sample:</p><pre><code class="language-julia hljs">K = 10
X0 = [x0 .+ 0.1*randn(2) for _=1:K]
Xens=[X=solve(f,X0[i],θ0,dt,N) for i=1:K]</code></pre><p>(can be implemented more elegantly using multiple dispatch on Vector{Vector})</p><p>While it is very simple and universal, it may become hard to intepret. - What is the probability that it will higher than <span>$x_{max}$</span>?</p><ul><li>Improving accuracy with higher number of samples (expensive!)</li></ul><h3 id="Propagating-a-Gaussian"><a class="docs-heading-anchor" href="#Propagating-a-Gaussian">Propagating a Gaussian</a><a id="Propagating-a-Gaussian-1"></a><a class="docs-heading-anchor-permalink" href="#Propagating-a-Gaussian" title="Permalink"></a></h3><p>Propagation of uncertainty has been studied in many areas of science. Relation between accuracy and computational speed is always a tradeoff.</p><p>A common appoach to propagation of uncertainty is linearized Gaussian:</p><ul><li>variable <span>$x$</span> is represented by gaussian <span>$N(\mu,\sigma)$</span></li><li>transformation of addition: <span>$x+a\sim N(\mu+a,\sigma)$</span></li><li>transformation of multiplication: <span>$a*x\sim N(a*\mu,a*\sigma)$</span></li><li>general transformation approximated:</li></ul><p class="math-container">\[g(x)\sim N(g(\mu),g&#39;(x)*\sigma)\]</p><p>This can be efficienty implemneted in Julia:</p><pre><code class="language-julia hljs">struct GNum{T} where T&lt;:Real
  μ::T
  σ::T
end
import Base: +, *
+(x::GaussNum{T},a::T) where T =GaussNum(x.μ+a,x.σ)
+(a::T,x::GaussNum{T}) where T =GaussNum(x.μ+a,x.σ)
*(x::GaussNum{T},a::T) where T =GaussNum(x.μ*a,a*x.σ)
*(a::T,x::GaussNum{T}) where T =GaussNum(x.μ*a,a*x.σ)</code></pre><p>For the ODE we need multiplication of two Gaussians. Using Taylor expansion:</p><p class="math-container">\[g(x_1,x_2)=N(g(\mu_1,\mu_2), \sqrt{(dg/dx_1(\mu_1,\mu_2)\sigma_1)^2 + (dg/dx_1(\mu_1,\mu_2)\sigma_1)^2})\]</p><p>which trivially applies to sum: <span>$x_1+x_2=N(\mu_1+\mu_2, \sqrt{\sigma_1^2 + \sigma_1^2})$</span></p><pre><code class="language-julia hljs">+(x1::GaussNum{T},x2::GaussNum{T}) where T =GaussNum(x1.μ+x2.μ,sqrt(x1.σ.^2 + x2.σ.^2))
*(x1::GaussNum{T},x2::GaussNum{T}) where T =GaussNum(x1.μ*x2.μ, sqrt(x1.σ.^2 + x2.σ.^2))
</code></pre><ul><li>TODO: can we make this more fancy? Automatic generation</li></ul><h2 id="Vector-uncertainty"><a class="docs-heading-anchor" href="#Vector-uncertainty">Vector uncertainty</a><a id="Vector-uncertainty-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-uncertainty" title="Permalink"></a></h2><p>The approach above competely ignores the covariances between variables. While it is possible to do it linearnly in the same fashion, the approach suffer from a loss of precision under non-linearity.</p><p>A more sophisticated approach is based on decomposition of the covariance matrix </p><h1 id="Manipulating-ODEs"><a class="docs-heading-anchor" href="#Manipulating-ODEs">Manipulating ODEs</a><a id="Manipulating-ODEs-1"></a><a class="docs-heading-anchor-permalink" href="#Manipulating-ODEs" title="Permalink"></a></h1><p>So far, we have considered first-order ODEs. Many ODEs are defined in higher order form, e.g. </p><ul><li>check Chris Raucausacc latest blog https://julialang.org/blog/2021/10/DEQ/</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../lecture_10/hw/">« Homework</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Monday 6 December 2021 11:33">Monday 6 December 2021</span>. Using Julia version 1.7.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
