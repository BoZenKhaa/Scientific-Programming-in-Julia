<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lecture · Scientific Programming in Julia</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://JuliaTeachingCTU.github.io/Scientific-Programming-in-Julia/lecture_07/lecture/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Scientific Programming in Julia logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Scientific Programming in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scientific Programming in Julia</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation/">Installation</a></li><li><a class="tocitem" href="../../projects/">Projects</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">1: Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/motivation/">Motivation</a></li><li><a class="tocitem" href="../../lecture_01/basics/">Basics</a></li><li><a class="tocitem" href="../../lecture_01/demo/">Examples</a></li><li><a class="tocitem" href="../../lecture_01/outline/">Outline</a></li><li><a class="tocitem" href="../../lecture_01/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_01/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">2: The power of Type System &amp; multiple dispatch</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_02/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_02/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_02/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">3: Design patterns</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_03/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_03/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_03/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">4: Packages development, Unit Tests &amp; CI</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_04/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_04/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_04/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">5: Benchmarking, profiling, and performance gotchas</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_05/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_05/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_05/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">6: Language introspection</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_06/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_06/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_06/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-10" type="checkbox" checked/><label class="tocitem" for="menuitem-10"><span class="docs-label">7: Macros</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Lecture</a><ul class="internal"><li><a class="tocitem" href="#What-goes-under-the-hood?"><span>What goes under the hood?</span></a></li><li><a class="tocitem" href="#Calling-macros"><span>Calling macros</span></a></li><li><a class="tocitem" href="#Notes-on-quotation"><span>Notes on quotation</span></a></li><li><a class="tocitem" href="#Macro-hygiene"><span>Macro hygiene</span></a></li><li><a class="tocitem" href="#Write-@exfiltrate-macro"><span>Write @exfiltrate macro</span></a></li><li><a class="tocitem" href="#sources"><span>sources</span></a></li></ul></li><li><a class="tocitem" href="../lab/">Lab</a></li><li><a class="tocitem" href="../hw/">Homework</a></li></ul></li><li><span class="tocitem">8: Introduction to automatic differentiation</span></li><li><span class="tocitem">9: Manipulating intermediate representation</span></li><li><span class="tocitem">10: Different levels of parallel programming</span></li><li><span class="tocitem">11: Julia for GPU programming</span></li><li><span class="tocitem">12: Uncertainty propagation in ODE</span></li><li><span class="tocitem">13: Learning ODE from data</span></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">7: Macros</a></li><li class="is-active"><a href>Lecture</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lecture</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaTeachingCTU/Scientific-Programming-in-Julia/blob/master/docs/src/lecture_07/lecture.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="macro_lecture"><a class="docs-heading-anchor" href="#macro_lecture">Macros</a><a id="macro_lecture-1"></a><a class="docs-heading-anchor-permalink" href="#macro_lecture" title="Permalink"></a></h1><p>What is macro? In its essence, macro is a function, which </p><ol><li>takes as an input an expression (parsed input)</li><li>modify the expressions in argument</li><li>insert the modified expression at the same place as the one that is parsed.</li></ol><p>Macros are necessary because they execute when code is parsed, therefore, macros allow the programmer to generate and include fragments of customized code before the full program is run. To illustrate the difference, consider the following example:</p><p>One of the very conveninet ways to write macros is to write functions modifying the <code>Expr</code>ession and then call that function in macro as </p><pre><code class="language-julia hljs">replace_sin(x::Symbol) = x == :sin ? :cos : x
replace_sin(e::Expr) = Expr(e.head, map(replace_sin, e.args)...)
replace_sin(u) = u

macro replace_sin(ex)
	replace_sin(esc(ex))
end

@replace_sin(cosp1(x) = 1 + sin(x))
cosp1(1) == 1 + cos(1)</code></pre><p>notice the following</p><ul><li>the definition of the macro is similar to the definition of the function with the exception that instead of the keyword <code>function</code> we use keyword <code>macro</code></li><li>when calling the macro, we signal to the compiler our intention by prepending the name of the macro with <code>@</code>. </li><li>the macro receives the expression(s) as the argument instead of the evaluated argument and also returns an expression that is placed on the position where the macro has been called</li><li>when you are invoking the macro, you should be aware that the code you are entering can be arbitrarily modified and you can receive something completely different. This meanst that <code>@</code> should also serve as a warning that you are leaving Julia&#39;s syntax. In practice, it make sense to make things akin to how they are done in Julia or to write Domain Specific Language with syntax familiar in that domain.</li></ul><p>We have mentioned above that macros are indispensible in the sense they intercept the code generation after parsing. You might object that I can achieve the above using the following combination of <code>Meta.parse</code> and <code>eval</code></p><pre><code class="language-julia hljs">ex = Meta.parse(&quot;cosp1(x) = 1 + sin(x)&quot;)
ex = replace_sin(ex)
eval(ex)</code></pre><p>in the following we cannot do the same trick</p><pre><code class="language-julia hljs">function cosp2(x)
	@replace_sin 2 + sin(x)
end
cosp2(1) ≈ (2 + cos(1))</code></pre><pre><code class="language-julia hljs">function parse_eval_cosp2(x)
	ex = Meta.parse(&quot;2 + sin(x)&quot;)
	ex = replace_sin(ex)
	eval(ex)
end

julia&gt; @code_lowered parse_eval_cosp2(1)
CodeInfo(
1 ─ %1 = Base.getproperty(Main.Meta, :parse)
│        ex = (%1)(&quot;2 + sin(x)&quot;)
│        ex = Main.replace_sin(ex)
│   %4 = Main.eval(ex)
└──      return %4
)</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><h3>Scope of eval</h3><p><code>eval</code> function is always evaluated in the global scope of the <code>Module</code> in which the macro is called (note that there is that by default you operate in the <code>Main</code> module). Moreover, <code>eval</code> takes effect <strong>after</strong> the function has been has been executed. This can be demonstrated as </p><pre><code class="language-julia hljs">add1(x) = x + 1
function redefine_add(x)
	eval(:(add1(x) = x - 1))
	add1(x)
end
julia&gt; redefine_add(1)
2

julia&gt; redefine_add(1)
0</code></pre></div></div><p><code>@macroexpand</code> can allow use to observe, how the macro will be expanded. We can use it for example </p><pre><code class="language-julia hljs">@macroexpand @replace_sin(sinp1(x) = 1 + sin(x))</code></pre><h2 id="What-goes-under-the-hood?"><a class="docs-heading-anchor" href="#What-goes-under-the-hood?">What goes under the hood?</a><a id="What-goes-under-the-hood?-1"></a><a class="docs-heading-anchor-permalink" href="#What-goes-under-the-hood?" title="Permalink"></a></h2><p>Let&#39;s consider what the compiler is doing in this call</p><pre><code class="language-julia hljs">function cosp2(x)
	@replace_sin 2 + sin(x)
end</code></pre><p>First, Julia parses the code into the AST as</p><pre><code class="language-julia hljs">ex = Meta.parse(&quot;&quot;&quot;
   function cosp2(x)
	   @replace_sin 2 + sin(x)
end
&quot;&quot;&quot;) |&gt; Base.remove_linenums!
dump(ex)</code></pre><p>We observe that there is a macrocall in the AST, which means that Julia will expand the macro and put it in place</p><pre><code class="language-julia hljs">ex.args[2].args[1].head 	# the location of the macrocall
ex.args[2].args[1].args[1]  # which macro to call
ex.args[2].args[1].args[2]  # line number
ex.args[2].args[1].args[3]	# on which expression</code></pre><p>let&#39;s run the <code>replace_sin</code> and insert it back</p><pre><code class="language-julia hljs">ex.args[2].args[1] = replace_sin(ex.args[2].args[1].args[3])
ex |&gt; dump</code></pre><p>now, <code>ex</code> contains the expanded macro and we can see that it correctly defines the function</p><pre><code class="language-julia hljs">eval(ex)</code></pre><h2 id="Calling-macros"><a class="docs-heading-anchor" href="#Calling-macros">Calling macros</a><a id="Calling-macros-1"></a><a class="docs-heading-anchor-permalink" href="#Calling-macros" title="Permalink"></a></h2><p>Macros can be called without parentheses</p><pre><code class="language-julia hljs">macro showarg(ex)
	println(&quot;single argument version&quot;)
	@show ex
	ex
end
@showarg 1 + 1
@showarg(1 + 1)</code></pre><p>but they use the very same multiple dispatch as functions</p><pre><code class="language-julia hljs">macro showarg(x1, x2::Symbol)
	println(&quot;two argument version, second is Symbol&quot;)
	x1
end
macro showarg(x1, x2::Expr)
	println(&quot;two argument version, second is Symbol&quot;)
	x1
end
@showarg(1 + 1, x)
@showarg(1 + 1, 1 + 3)
@showarg 1 + 1, 1 + 3
@showarg 1 + 1  1 + 3</code></pre><p>(the <code>@showarg(1 + 1, :x)</code> raises an error, since <code>:(:x)</code> is of Type <code>QuoteNode</code>).</p><p>Observe that macro dispatch is based on the types of AST that are handed to the macro, not the types that the AST evaluates to at runtime.</p><h2 id="Notes-on-quotation"><a class="docs-heading-anchor" href="#Notes-on-quotation">Notes on quotation</a><a id="Notes-on-quotation-1"></a><a class="docs-heading-anchor-permalink" href="#Notes-on-quotation" title="Permalink"></a></h2><p>In the previous lecture we have seen that we can <em>quote a block of code</em>, which tells the compiler to treat the input as an data and parse it. We have talked about three ways of quoting code.</p><ol><li><code>:(quoted code)</code></li><li>Meta.parse(input_string)</li><li><code>quote ... end</code></li></ol><p>The truth is that Julia does not do full quotation, but a <em>quasiquotation</em> is it allows you to <strong>interpolate</strong> expressions inside the quoted code using <code>$</code> symbol similar to the string. This is handy, as sometimes, when we want to insert into the quoted code an result of some computation / preprocessing. Observe the following difference in returned code</p><pre><code class="language-julia hljs">a = 5
:(x = a)
:(x = $(a))
let y = :x
    :(1 + y), :(1 + $y)
end</code></pre><p>In contrast to the behavior of <code>:()</code> (or <code>quote ... end</code>, true quotation would not perform interpolation where unary <code>$</code> occurs. Instead, we would capture the syntax that describes interpolation and produce something like the following:</p><pre><code class="language-julia hljs">(
    :(1 + x),                        # Quasiquotation
    Expr(:call, :+, 1, Expr(:$, :x)), # True quotation
)</code></pre><p>When we need true quoting, i.e. we need something to stay quoted, we can use <code>QuoteNode</code> as</p><pre><code class="language-julia hljs">macro true_quote(e)
    QuoteNode(e)
end
let y = :x
    (
        @true_quote(1 + $y),
        :(1 + $y),
    )
end</code></pre><p>At first glance, <code>QuoteNode</code> wrapper seems to be useless. But <code>QuoteNode</code> has clear value when it&#39;s used inside a macro to indicate that something should stay quoted even after the macro finishes executing. Also notice that the expression received by macro was quoted, not quasiquoted, since in the latter case <code>$y</code> would be replaced. We can demonstate it using the <code>@showarg</code> macro introduced earlier, as</p><pre><code class="language-julia hljs">@showarg(1 + $x)</code></pre><p>The error is raised after the macro was evaluated and the output has been inserted to parsed AST.</p><p>Macros do not know about runtime values, they only know about syntax trees. When a macro receives an expression with a x in it, it can&#39;t interpolate the value of x into the syntax tree because it reads the syntax tree before x ever has a value! So the interpolation syntax in macros is not given any actual meaning in julia.</p><p>Instead, when a macro is given an expression with $ in it, it assumes you&#39;re going to give your own meaning to x. In the case of BenchmarkTools.jl they return code that has to wait until runtime to receive the value of x and then splice that value into an expression which is evaluated and benchmarked. Nowhere in the actual body of the macro do they have access to the value of x though.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><h3>Why <code>$</code> for interpolation?</h3><p>The <code>$</code> string for interpolation was used as it identifies the interpolation inside the string and inside the command. For example</p><pre><code class="language-julia hljs">a = 5
s = &quot;a = $(5)&quot;
typoef(s)
println(s)
filename = &quot;/tmp/test_of_interpolation&quot;
run(`touch $(filename)`)</code></pre></div></div><h2 id="Macro-hygiene"><a class="docs-heading-anchor" href="#Macro-hygiene">Macro hygiene</a><a id="Macro-hygiene-1"></a><a class="docs-heading-anchor-permalink" href="#Macro-hygiene" title="Permalink"></a></h2><p>Macro hygiene is a term coined in 1986 and it says that the evaluation of the macro should not have an effect on the surrounding call. By default, all macros in Julia are hygienic which means that variables introduced in the macro are <code>gensym</code>ed to have unique names and function points to global functions.</p><p>Let&#39;s demonstrate it on our own version of an macro <code>@elapsed</code> which will return the time that was needed to evaluate the block of code.</p><pre><code class="language-julia hljs">macro tooclean_elapsed(ex)
	quote
		tstart = time()
		$(ex)
		time() - tstart
	end
end

fib(n) = n &lt;= 1 ? n : fib(n-1) + fib(n - 2)
let 
	t = @tooclean_elapsed r = fib(10)
	println(&quot;the evaluation of fib took &quot;, t, &quot;s and result is &quot;, r)
end</code></pre><p>We see that variable <code>r</code> has not been assigned during the evaluation of macro. We have also used <code>let</code> block in orders not to define any variables in the global scope. Why is that? Let&#39;s observe how the macro was expanded</p><pre><code class="language-julia hljs">julia&gt; Base.remove_linenums!(@macroexpand @tooclean_elapsed r = fib(10))
quote
    var&quot;#12#tstart&quot; = Main.time()
    var&quot;#13#r&quot; = Main.fib(10)
    Main.time() - var&quot;#12#tstart&quot;
end</code></pre><p>We see that <code>tstart</code> in the macro definition was replaced by <code>var&quot;#12#tstart&quot;</code>, which is a name generated by Julia&#39;s gensym to prevent conflict. The same happens to <code>r</code>, which was replaced by <code>var&quot;#13#r&quot;</code>. Notice that in the case of <code>tstart</code>, we actually want to replace <code>tstart</code> with a unique name, such that if we by a bad luck define <code>tstart</code> in our code, it would not be affected, as we can see in this example.</p><pre><code class="language-julia hljs">let 
	tstart = &quot;should not change the value and type &quot;
	t = @tooclean_elapsed r = fib(10)
	println(tstart, &quot;  &quot;, typeof(tstart))
end</code></pre><p>But in the second case, we would actually very much like the variable <code>r</code> to retain its name, such that we can accesss the results (and also, <code>ex</code> can access and change other local variables). Julia offer a way to <code>escape</code> from the hygienic mode, which means that the variables will be used and passed as-is. Notice the effect if we escape jus the expression <code>ex</code> </p><pre><code class="language-julia hljs">macro justright_elapsed(ex)
	quote
		tstart = time()
		$(esc(ex))
		time() - tstart
	end
end

let 
	tstart = &quot;should not change the value and type &quot;
	t = @justright_elapsed r = fib(10)
	println(&quot;the evaluation of fib took &quot;, t, &quot;s and result is &quot;, r)
	println(tstart, &quot;  &quot;, typeof(tstart))
end</code></pre><p>which now works as intended. We can inspect the output again using <code>@macroexpand</code></p><pre><code class="language-julia hljs">julia&gt; Base.remove_linenums!(@macroexpand @justright_elapsed r = fib(10))
quote
    var&quot;#19#tstart&quot; = Main.time()
    r = fib(10)
    Main.time() - var&quot;#19#tstart&quot;
end</code></pre><p>and compare it to <code>Base.remove_linenums!(@macroexpand @justright_elapsed r = fib(10))</code>. We see that the experssion <code>ex</code> has its symbols intact. To use the escaping / hygience correctly, you need to have a good understanding how the macro evaluation works and what is needed. Let&#39;s now try the third version of the macro, where we escape everything as</p><pre><code class="language-julia hljs">macro toodirty_elapsed(ex)
	ex = quote
		tstart = time()
		$(ex)
		time() - tstart
	end
	esc(ex)
end

let 
	tstart = &quot;should not change the value and type &quot;
	t = @toodirty_elapsed r = fib(10)
	println(&quot;the evaluation of fib took &quot;, t, &quot;s and result is &quot;, r)
	println(tstart, &quot;  &quot;, typeof(tstart))
end</code></pre><pre><code class="language-julia hljs">julia&gt; Base.remove_linenums!(@macroexpand @toodirty_elapsed r = fib(10))
quote
    tstart = time()
    r = fib(10)
    time() - tstart
end</code></pre><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><h3>gensym</h3><p><code>gensym([tag])</code> Generates a symbol which will not conflict with other variable names. ```julia julia&gt; gensym(&quot;hello&quot;) Symbol(&quot;##hello#257&quot;)</p></div></div><pre><code class="nohighlight hljs">


but if we look, how the function is expanded, we see that it is not as we have expected</code></pre><p>julia</p><p>macro replace<em>sin(ex) 	replace</em>sin(esc(ex)) end</p><p>function cosp2(x) 	@replace_sin 2 + sin(x) end</p><p>julia&gt; @code_lowered(cosp2(1.0)) CodeInfo( 1 ─ %1 = Main.cos(Main.x) │   %2 = 2 + %1 └──      return %2 )</p><pre><code class="nohighlight hljs">why is that

## DSL
## non-standard string literals</code></pre><p>macro r_str(p)     Regex(p) end ```</p><h2 id="Write-@exfiltrate-macro"><a class="docs-heading-anchor" href="#Write-@exfiltrate-macro">Write @exfiltrate macro</a><a id="Write-@exfiltrate-macro-1"></a><a class="docs-heading-anchor-permalink" href="#Write-@exfiltrate-macro" title="Permalink"></a></h2><p><code>Base.@locals</code></p><h2 id="sources"><a class="docs-heading-anchor" href="#sources">sources</a><a id="sources-1"></a><a class="docs-heading-anchor-permalink" href="#sources" title="Permalink"></a></h2><p>Great discussion on evaluation of macros https://discourse.julialang.org/t/interpolation-in-macro-calls/25530</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../lecture_06/hw/">« Homework</a><a class="docs-footer-nextpage" href="../lab/">Lab »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Monday 8 November 2021 11:03">Monday 8 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
