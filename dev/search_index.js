var documenterSearchIndex = {"docs":
[{"location":"lecture_04/lab/#Lab-4:-Packages,-Tests,-Continuous-Integration","page":"Lab","title":"Lab 4: Packages, Tests, Continuous Integration","text":"","category":"section"},{"location":"lecture_04/lab/#TODO","page":"Lab","title":"TODO","text":"","category":"section"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"demonstrate versioning","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"In this lab you will practice common development workflows in Julia. At the end of the labe you will have","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"Your own package called Ecosystem.jl which you can conveniently install in any Julia REPL\nTests for the major functionality of your package\nSet up continuous integration (CI) via Github Actions to automatically execute your tests","category":"page"},{"location":"lecture_04/lab/#Separating-core-and-extended-functionality","page":"Lab","title":"Separating core and extended functionality","text":"","category":"section"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"To practice working with multiple packages that build on top of each other we first separate the core functionality of our ecosystem into a package called EcosystemCore.jl. This core package already exists and defines the interface to AbstractAnimal and AbstractPlant. It also contains the three basic types Grass, Sheep, and Wolf, as well as the most important functions: eat!, agent_step!, find_food and reproduce!.","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"Your task is to create your own package Ecosystem.jl which will contain the utitlity functions simulate!, agent_count, every_nth that we created, as well as the new types PoisonedGrass and ⚥Sheep.","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"Create a new package by starting a julia REPL, typing ] to enter the Pkg REPL and writing generate Ecosystem. This will create a new package called Ecosystem with a Project.toml and one file src/Ecosystem.jl\nExit julia, navigate into the newly created Ecosystem folder and restart julia in the Ecosystem environment by typing julia --project.\nAdd EcosystemCore.jl as a dependency by running\n]add https://github.com/JuliaTeachingCTU/EcosystemCore.jl.git","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"You should now be able to run using EcosystemCore in your REPL to precomplie the core package.","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"using EcosystemCore\ngrass = Grass(true,5.0,5.0);\nsheep = Sheep(10.0,5.0,0.1,0.1);\nworld = World([grass, sheep])\neat!(sheep,grass,world);\nworld","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"Next, lets add the utility functions simulate!, agent_count, and every_nth, as well as the two new types PoisonedGrassc and ⚥Sheep along with the necessary functions and method overloads.\nNote that you either have to import a method to overload it or do something like this\nEcosystemCore.eats(::Sheep, ::PoisonedGrass) = true\nExport all types and functions that should be accessible from outside your package.","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"In a fresh REPL you should now be able to run one of your simulation scripts like below","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"# only load the Ecosystem package which depends on EcosystemCore\nusing Ecosystem\n\nn_grass       = 500\nregrowth_time = 17.0\n\nn_sheep         = 100\nΔenergy_sheep   = 5.0\nsheep_reproduce = 0.5\nsheep_foodprob  = 0.4\n\nn_wolves       = 8\nΔenergy_wolf   = 17.0\nwolf_reproduce = 0.03\nwolf_foodprob  = 0.02\n\ngs = [Grass(true,regrowth_time,regrowth_time) for _ in 1:n_grass]\nss = [Sheep(2*Δenergy_sheep,Δenergy_sheep,sheep_reproduce, sheep_foodprob) for _ in 1:n_sheep]\nws = [Wolf(2*Δenergy_wolf,Δenergy_wolf,wolf_reproduce, wolf_foodprob) for _ in 1:n_wolves]\n\nw = World(vcat(gs,ss,ws))\n\nlogcb = every_nth(w->(@info agent_count(w)), 5)\nsimulate!(w, 10, callbacks=[logcb])","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_04/lab/#Testing-the-Ecosystem","page":"Lab","title":"Testing the Ecosystem","text":"","category":"section"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"Every well maintained package should contain tests. In Julia the tests have to be located in the test folder of package root folder. The test folder has to contain at least one file called runtests.jl which can include more files. A minimal package structure can look like the EcosystemCore package below.","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":".\n├── Project.toml\n├── README.md\n├── src\n│   └── EcosystemCore.jl\n└── test\n    └── runtests.jl","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"Write at least one test for each function/method you added to your package.","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"As an example of how to write tests in Julia you can take a look at the runtests.jl file of EcosystemCore.jl.","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_04/lab/#Github-and-Continuous-Integration","page":"Lab","title":"Github & Continuous Integration","text":"","category":"section"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"Another good standard is to use a versioning tool like git. It will save you tons of headaches and you will never have to worry again that you could loose some of your work.","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"Create a new repository called Ecosystem.jl on Github (public or private, however you want). A good repo should also contain a README.md file which briefly describes what it is about.","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"You can turn a folder into a git repo by running git init. After you created a new repo on Github you can connect your local repo to the empty Github repo like below","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"# turn folder into git repo\ngit init\n# point local repo to empty github repo\ngit remote add origin https://github.com/username/Ecosystem.jl.git\n# rename master branch->main\ngit branch -M main\n# create your initial commit\ngit add .\ngit commit -m \"init commit\"\n# push your contents\ngit push -u origin main","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"As a last step, we will add a Github Action to your repository, which will run your test on every commit to the main branch (or for every pull request).","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"Create a file (in a hidden subdirectory) .github/workflows/RunTests.yml with the contents below","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"name: Run tests\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n\njobs:\n  test:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        julia-version: ['1.6']\n        julia-arch: [x64]\n        os: [ubuntu-latest]\n\n    steps:\n      - uses: actions/checkout@v2\n      - uses: julia-actions/setup-julia@v1\n        with:\n          version: ${{ matrix.julia-version }}\n      - uses: julia-actions/julia-buildpkg@v1\n      - uses: julia-actions/julia-runtest@v1","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"Pushing this file to your repository should result in github automatically running your julia tests.","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"</div></div>","category":"page"},{"location":"lecture_04/lab/#Code-coverage","page":"Lab","title":"Code coverage","text":"","category":"section"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"If you still have time you can add code coverage reports to your repository. They will show you which parts of your repo have been covered by a test and which have not. To get coverage reports you have to give codecov.io access to your repository and add a few steps to your RunTests.yml that upload the coverage report during the Github Action.","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise (optional)</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"Add the codecov steps below to your RunTests.yml and get a code coverage above 95%. Note that code coverage does not mean that your code is properly tested!  It is simply measuring which lines have been hit during the execution of your tests, which does not mean that your code (or your tests) are correct.","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"steps:\n  - uses: julia-actions/julia-processcoverage@v1\n  - uses: codecov/codecov-action@v2\n    with:\n      file: lcov.info","category":"page"},{"location":"lecture_04/lab/","page":"Lab","title":"Lab","text":"</div></div>","category":"page"},{"location":"lecture_03/lab/#Lab-3:-Predator-Prey-Agents","page":"Lab","title":"Lab 3: Predator-Prey Agents","text":"","category":"section"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"using Scientific_Programming_in_Julia\nusing Scientific_Programming_in_Julia.Ecosystem: eat!, find_food, count","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"In this lab we will finalize our predator-prey agent simulation such that we can simulate a number of steps and get a plot like below.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"(Image: img)","category":"page"},{"location":"lecture_03/lab/#Reproduction","page":"Lab","title":"Reproduction","text":"","category":"section"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"Currently our animals can only eat. In our simulation we also want them to reproduce. We will do this by adding a reproduce! method to AbstractAnimal.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"Write a function reproduce! that takes an AbstractAnimal and a World. Reproducing will cost an animal half of its energy and then add an identical copy of the given animal to the world.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"function reproduce!(a::AbstractAnimal, w::World)\n    energy!(a, energy(a)/2)\n    push!(w.agents, deepcopy(a))\nend","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_03/lab/#One-step-at-a-time","page":"Lab","title":"One step at a time","text":"","category":"section"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"One iteration of our simulation will be carried out by a function called agent_step!(::AbstractAgent, ::World). Implement one method for AbstractPlants and one for AbstractAnimals.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"An AbstractPlant will grow if it is not fully grown (i.e. decrease growth counter).  If the growth counter has reached zero, the fully_grown flag has to be set to true and the counter reset to regrowth_time.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"An AbstractAnimal will loose one unit of energy in every step.  Then it will try to find food and eat. After eating, if its energy is less than zero, the animal dies.  If it is still alive, it will try to reproduce with the probablitiy p_r.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"Implement the function agent_step! with specialized methods for AbstractAnimals and AbstractPlants.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"function agent_step!(a::AbstractPlant, w::World)\n    if !fully_grown(a)\n        if countdown(a) <= 0\n            fully_grown!(a,true)\n            reset!(a)\n        else\n            incr_countdown!(a,-1)\n        end\n    end\n    return a\nend\n\nfunction agent_step!(a::AbstractAnimal, w::World)\n    incr_energy!(a,-1)\n    dinner = find_food(a,w)\n    eat!(a, dinner, w)\n    if energy(a) < 0\n        kill_agent!(a,w)\n        return\n    end\n    if rand() <= reproduction_prob(a)\n        reproduce!(a,w)\n    end\n    return a\nend","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_03/lab/#Simulate-the-world!","page":"Lab","title":"Simulate the world!","text":"","category":"section"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"The last function we need for our simulation just needs to run a number of steps. In practice we often want varying logging behaviour which we can implement nicely using callbacks.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"An exemplary callback could just log the agent count at every step:","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"log_count(w::World) = @info agent_count(w)","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"Implement a function simulate!(w::World, iters::Int; callbacks=[]) which runs a number of iterations (i.e. agent_step!s) and applies passed callbacks of the form callback(::World) after each iteration.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"function simulate!(w::World, iters::Int; callbacks=[])\n    for i in 1:iters\n        for a in w.agents\n            agent_step!(a,w)\n        end\n        for cb in callbacks\n            cb(w)\n        end\n    end\nend","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"Now lets try to run our first fully fledged simulation!  Below you can find some parameters that will often result in nice oscillations like in the plot at the beginning of the lab.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"n_grass       = 500\nregrowth_time = 17.0\n\nn_sheep         = 100\nΔenergy_sheep   = 5.0\nsheep_reproduce = 0.5\nsheep_foodprob  = 0.4\n\nn_wolves       = 8\nΔenergy_wolf   = 17.0\nwolf_reproduce = 0.03\nwolf_foodprob  = 0.02\n\ngs = [Grass(true,regrowth_time,regrowth_time) for _ in 1:n_grass]\nss = [Sheep(2*Δenergy_sheep,Δenergy_sheep,sheep_reproduce, sheep_foodprob) for _ in 1:n_sheep]\nws = [Wolf(2*Δenergy_wolf,Δenergy_wolf,wolf_reproduce, wolf_foodprob) for _ in 1:n_wolves]\n\nw = World(vcat(gs,ss,ws))\n\n# construct a global variable to store agent counts at every step\ncounts = Dict(n=>[c] for (n,c) in agent_count(w))\n# callback to save current counts\nfunction save_agent_count(w::World)\n    for (n,c) in agent_count(w)\n        push!(counts[n],c)\n    end\nend\n\ncbs = [\n    w->(@info agent_count(w)),\n    save_agent_count\n]\n\nsimulate!(w, 200, callbacks=cbs)\n\n# plot the count trajectories for every type of agent\nusing Plots\nplt = plot()\nfor (n,c) in counts\n    plot!(plt, c, label=\"$n\", lw=2)\nend\nplt","category":"page"},{"location":"lecture_03/lab/#Female-and-Male-Sheep","page":"Lab","title":"Female & Male Sheep","text":"","category":"section"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"The goal of the last part of the lab is to demonstrate the forwarding method by implementing a sheep that can have two different sexes and can only reproduce with another sheep of opposite sex.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"This new type of sheep needs an additonal field sex::Symbol which can be either :male or :female. In OOP we would now simply inherit from Sheep and create a ⚥Sheep with an additional field. In Julia there is no inheritance - only subtyping of abstract types. As you cannot inherit from a concrete type in Julia, we will have to create a wrapper type and forward all necessary methods. This is typically a sign of unfortunate type tree design and should be avoided, but if you want to extend a code base by an unforeseen type this forwarding of methods is a nice work-around.  Our ⚥Sheep type will simply contain a classic sheep and a sex field","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"struct ⚥Sheep{T<:Real} <: AbstractAnimal\n    sheep::Sheep{T}\n    sex::Symbol\nend\n⚥Sheep(E,ΔE,pr,pf,sex) = ⚥Sheep(Sheep(E,ΔE,pr,pf),sex)","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"⚥Sheep(1.0,1.0,1.0,1.0,:female)","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"In our case, the methods that have to be forwarded are agent_step!, reproduce!, eats and eat!.  The custom reproduction behaviour will of course be taken care of by a reproduce! function that does not just forward but also contains specialized behaviour for the ⚥Sheep.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"Forward the accessors energy, energy!, reproduction_prob, and food_prob, as well as our core methods eats and eat! to Sheep.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"energy(g::⚥Sheep) = energy(g.sheep)\nenergy!(g::⚥Sheep, ΔE) = energy!(g.sheep, ΔE)\nreproduction_prob(g::⚥Sheep) = reproduction_prob(g.sheep)\nfood_prob(g::⚥Sheep) = food_prob(g.sheep)\n\neats(::⚥Sheep, ::Grass) = true\neats(::⚥Sheep, ::PoisonedGrass) = true\neat!(s::⚥Sheep, g::AbstractPlant, w::World) = eat!(s.sheep, g, w)","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"Implement the reproduce! method for the ⚥Sheep.  Note that you first have to find another sheep of opposite sex in your World, and only if you can find one you can reproduce.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"mates(a::AbstractPlant, ::⚥Sheep) = false\nmates(a::AbstractAnimal, ::⚥Sheep) = false\nmates(g1::⚥Sheep, g2::⚥Sheep) = g1.sex != g2.sex\nfunction find_mate(g::⚥Sheep, w::World)\n    ms = filter(a->mates(a,g), w.agents)\n    isempty(ms) ? nothing : sample(ms)\nend\n\nfunction reproduce!(s::⚥Sheep, w::World)\n    m = find_mate(s,w)\n    if !isnothing(m)\n        energy!(s, energy(s)/2)\n        # TODO: should probably mix s/m\n        push!(w.agents, deepcopy(s))\n    end\nend","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_02/lecture/#Motivation","page":"Lecture","title":"Motivation","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Before going into details about Julia type system, we spent few minutes motivating the two main role of type system, which is (i) structuring the code and (ii) and communicating to the compiler your intentions how the type will be used. While the first aspect is very important for the convenience of programmer and possible abstraction in the language, the latter aspect is very important for speed. ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"What Wikipedia tells about type and type system?","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"In computer science and computer programming, a data type or simply type is an attribute of data which tells the compiler or interpreter how the programmer intends to use the data (see (Image: wiki)). ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"A type system is a logical system comprising a set of rules that assigns a property called a type to the various constructs of a computer program, such as variables, expressions, functions or modules. These types formalize and enforce the otherwise implicit categories the programmer uses for algebraic data types, data structures, or other components (see (Image: wiki)).","category":"page"},{"location":"lecture_02/lecture/#Structuring-the-code","page":"Lecture","title":"Structuring the code","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"The main role is therefore aiding help to structure the code and impose semantic restriction. Consider for example two types with the same definition but different names.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"struct Wolf\n\tname::String\n  energy::Int\nend\n\nstruct Sheep\n\tname::String\n  energy::Int\nend","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"This allows us to define functions applicable only to the corresponding type","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"howl(wolf::Wolf) = println(wolf.name, \" has howled.\")\nbaa(sheep::Sheep) = println(sheep.name, \" has baaed.\")","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"and therefore the compiler (or interpretter) enforces that wolf can only howl and never baa and vice versa sheep can only baa. In this sense, it ensures that howl(sheep) and baa(wolf) never happen. Unlike if we define  those functions as ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"bark(animal) = println(animal.name, \" has howled.\")\nbaa(animal)  = println(animal.name, \" has baaed.\")","category":"page"},{"location":"lecture_02/lecture/#Intention-of-use-and-restrictions-on-compilers","page":"Lecture","title":"Intention of use and restrictions on compilers","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"The intention of use in types is related to how efficient code can compiler produce for that given intention. As an example, consider a following two alternatives to represent a set of animals:","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"a = [Wolf(\"1\", 1), Wolf(\"2\", 2), Sheep(\"3\", 3)]\nb = (Wolf(\"1\", 1), Wolf(\"2\", 2), Sheep(\"3\", 3))","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"and define a function to sum energy of all animals as ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"energy(animals) = mapreduce(x -> x.energy, +, animals)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Inspecting the compiled code using ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"@code_native energy(a)\n@code_native energy(b)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"one observes the second version produces more optimal code. Why is that?","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"In the first representation, a, animals are stored in Array which can have arbitrary size and can contain arbitrary animals. This means that compiler has to compile energy(a) such that it works on such arrays.\nIn the second representation, b, animals are stored in Tuple, which specializes for lengths and types of items. This means that the compiler knows the number of animals and the type of each animal on each position within the tuple, which allows him to specialize.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"This difference will be indeed measurable On my i5-8279U CPU, the difference is visible in performance","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"using BenchmarkTools\njulia> @btime energy(a);\n  86.944 ns (0 allocations: 0 bytes)\n\njulia> @btime energy(b);\n  16.206 ns (0 allocations: 0 bytes)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Which nicely demonstrates that smart choice of types can greatly affect the performance.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Does it mean that we should always use Tuples instead of Arrays? Surely not, it is just that each is better for different use-case. Using Tuples means that compiler will compile special function for each tuple it observes, which is clearly wasteful.","category":"page"},{"location":"lecture_02/lecture/#The-type-system","page":"Lecture","title":"The type system","text":"","category":"section"},{"location":"lecture_02/lecture/#Julia-is-dynamicaly-typed","page":"Lecture","title":"Julia is dynamicaly typed","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Julia's type system is dynamic, which means that all types are resolved during runtime. But, if the compiler can infer type of all variables of a function, it can specialize it leading to a very efficient code. Consider a slightly modified example where we represent two wolfpacks:","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"wolfpack_a =  [Wolf(\"1\", 1), Wolf(\"2\", 2), Wolf(\"3\", 3)]\nwolfpack_b =  Any[Wolf(\"1\", 1), Wolf(\"2\", 2), Wolf(\"3\", 3)]","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"wolfpack_a carries a type Vector{Wolf} while wolfpack_b has a type Vector{Any}. This means that in the first case, the compiler know that all items are of the type Wolf and it can specialize functions using this information. In case of wolfpack_b, he does not know which animal he will encounter (although all are of the same type), and therefore it needs to dynamically resolve the type of each item upon its use. This ultimately leads to less performant code.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"julia> @btime energy(wolfpack_a)\n  15.498 ns (0 allocations: 0 bytes)\njulia> @btime energy(wolfpack_b)\n  91.152 ns (0 allocations: 0 bytes)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"To conclude, julia is indeed dynamically typed language, but if the compiler can infer all types in called function in advance, it does not have to perform a type resolution during execution, which produces a performant code.","category":"page"},{"location":"lecture_02/lecture/#Types-of-types","page":"Lecture","title":"Types of types","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Julia divides types into three classes: primitive, composite, and abstract.","category":"page"},{"location":"lecture_02/lecture/#Primitive-types","page":"Lecture","title":"Primitive types","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Citing the (Image: documentation): A primitive type is a concrete type whose data consists of plain old bits. Classic examples of primitive types are integers and floating-point values. Unlike most languages, Julia lets you declare your own primitive types, rather than providing only a fixed set of built-in ones. In fact, the standard primitive types are all defined in the language itself:","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"The definition of primitive types look as follows","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"primitive type Float16 <: AbstractFloat 16 end\nprimitive type Float32 <: AbstractFloat 32 end\nprimitive type Float64 <: AbstractFloat 64 end","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"and they are mainly used to jump-start julia's type system. It rarely make a sense to define a special primitive type, as it make sense only if you define special functions operating on its bits, which makes mostly sense if you want to expose special operations provided by underlying CPU / LLVM compiler. For example + for Int32 is different from + for Float32 as they call a different intrinsic operation. You can inspect this jump-starting of type system by yourself by inspecting Julia's source.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"julia> @which +(1,2)\n+(x::T, y::T) where T<:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8} in Base at int.jl:87","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"At int.jl:87 ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"(+)(x::T, y::T) where {T<:BitInteger} = add_int(x, y)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"we seen that + of integers is calling function add_int(x, y), which is defined in a core part of the compiler in Intrinsics.cpp (yes, in C++).","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"From Julia docs: Core is the module that contains all identifiers considered \"built in\" to the language, i.e. part of the core language and not libraries. Every module implicitly specifies using Core, since you can't do anything without those definitions.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Primitive types are rarely used, and they will not be used in this course. We touch them for the sake of completness and refer reader to the official Documentation (and source code of Julia).","category":"page"},{"location":"lecture_02/lecture/#composite_types","page":"Lecture","title":"Composite types","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"The composite types are similar to struct in C (they even have the same memory layout). It is not a great idea to think about them as objects (in OOP sense), because objects tie together data and functions over owned data. Contrary in Julia (as in C), the function operates over data, but are not tied to them. Composite types are a workhorses of Julia's type system, as most user-defined types are composite.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"The composite type is defined as","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"struct Position\n  x::Float64\n  y::Float64\nend","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"which defines a structure with two fields x and y of type Float64. Julia compiler creates a default constructor, where both (but generally all) arguments are converted using (convert(Float64, x), convert(Float64, y) to the correct type. This means that we can construct a Position with numbers of different type that are convertable to Float, e.g. Position(1,1//2).","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Composite types do not have to have a specified type, e.g.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"struct VaguePosition\n  x \n  y \nend","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"which would work as the definition above and allows to store different values in x, for example String. But it would limit compiler's ability to specialize, which can have a negative impact on the performance. For example","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"using BenchmarkTools\nmove(a::T, b::T) where {T} = T(a.x + b.x, a.y + b.y)\nx = [Position(rand(), rand()) for _ in 1:100]\ny = [VaguePosition(rand(), rand()) for _ in 1:100]\njulia> @btime reduce(move, x);\n  114.105 ns (1 allocation: 32 bytes)\n\njulia> @btime reduce(move, y);\n  3.879 μs (199 allocations: 3.12 KiB)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"The same holds if the Composite type contains field with AbstractType, for example","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"struct LessVaguePosition\n  x::Real\n  y::Real \nend\nz = [LessVaguePosition(rand(), rand()) for _ in 1:100];\njulia> @btime reduce(move, z);\n  16.260 μs (496 allocations: 9.31 KiB)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"A recommended way to fix this is to parametrize the struct is to parametrize the type definition as follows","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"struct Position2{T}\n  x::T\n  y::T \nend\nu = [Position2(rand(), rand()) for _ in 1:100];\njulia> @btime reduce(move, u);\n  110.043 ns (1 allocation: 32 bytes)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"and notice that the compiler can take advantage of specializing for differenty types (which does not have effect as in modern processrs have addition of Float and Int takes the same time)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"v = [Position2(rand(1:100), rand(1:100)) for _ in 1:100];\n@btime reduce(move, v);\n  110.043 ns (1 allocation: 32 bytes)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"All structs defined above are immutable (as we have seen above in the case of Tuple), which means that one cannot change a field (unless the struct wraps a container, like and array, which allows that). For example this raises an error","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"a = Position(1, 2)\na.x = 2","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"If one needs to make a struct mutable, use the keyword mutable as follows","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"mutable struct MutablePosition{T}\n  x::T\n  y::T\n\nend\n\na = MutablePosition(1e0, 2e0)\na.x = 2","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"but there might be some performance penalty(not observable at this simple demo).","category":"page"},{"location":"lecture_02/lecture/#Abstract-Type","page":"Lecture","title":"Abstract Type","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"((Image: Julia documentation)) Abstract types cannot be instantiated, which means that we cannot create a variable that would have an abstract type (try typeof(Number(1f0))). Also, Abstract types cannot have any fields (therefore there is no composition). The most important use of abstract type is for structuring the code and defining general functions over semantically similar entities with different implementation. ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"An abstract types are defined by preceding a definition of a type (declared using struct keyword) with a keyword abstract. For example following set of abstract types defines part of julia's number systems.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"abstract type Number end\nabstract type Real     <: Number end\nabstract type AbstractFloat <: Real end\nabstract type Integer  <: Real end\nabstract type Signed   <: Integer end\nabstract type Unsigned <: Integer end","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"The <: means \"is a subtype of\" and it is used in declarations where the right-hand is an immediate sypertype of a given type (Integer has an immediate supertype Real.) The abstract type Number is derived from Any which is a default supertype of any type (this means all subtypes are derived from Any).  ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"The type hiearchy is used for defining general functions, that are known to provide a correct output on all subtypes of a given abstract type. For example a sgn function can be defined for all real numbers as ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"sgn(x::Real) = x > 0 ? 1 : x < 0 ? -1 : 0","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"and we know it would be correct for all real numbers. This means that if anyone creates a new subtype of Real, the above function can be used.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"For unsigned numbers, the sgn can be simplified, as it is sufficient to verify if they are different (greated) then zeros, therefore the function can read","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"sgn(x::Unsigned) = Int(x > 0)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"and again, it applies to all numbers derived from Unsigned. Recall that Unsigned <: Integer <: Real, how does Julia decides, which version of the function sgn to use for UInt8(0)? It chooses the most specific version, and therefore for sgn(UInt8(0)) it will use sgn(x::Unsinged). If the compiler cannot decide, typically it encounters an ambiguity, it throws an error and recommend which function you should define to resolve it.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"The above behavior allows to define default \"fallback\" implementations and while allowing to specialize for sub-types. A usual example is a matrix multiplication, which has a generic (and slow) implementation with many specializations, which can take advantage of structure (sparse, banded), or of optimized implementations (e.g. blas implementation for dense matrices with eltype Float32 and Float64).","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Again, Julia does not make a difference between abstract types defined in Base libraries shipped with the language and those defined by you (the user). All are treated the same.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Like Composite types, Abstract types can have parameters. For example Julia defines an array of arbitrary dimension N and type T of its items as","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"abstract type AbstractArray{T,N} end","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Different T and N gives rise to different variants of AbstractArrays, therefore AbstractArray{Float32,2} is different from AbstractArray{Float64,2} and from AbstractArray{Float64,1}. Note that these are still Abstract types, which means you cannot instantiate them. They purpose is","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"to allow to define operations for broad class of concrete types\nto inform compiler about constant values, which can be used ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"For convenience, you can name some important partially instantiated Abstract types, for example AbstractVector as ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"const AbstractVector{T} = AbstractArray{T,1}","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"is defined in array.jl:23 (in Julia 1.6.2), which allows us to define for example general prescription for dot product of two abstract vectors as ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"function dot(a::AbstractVector, b::AbstractVector)\n  @assert length(a) == length(b)\n  mapreduce(*, +, a, b)\nend","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"You can verify that the above general function can be compiled to a performant code if specialized for a particular arguments.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"@code_native mapreduce(*,+, [1,2,3], [1,2,3])","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":".","category":"page"},{"location":"lecture_02/lecture/#More-on-Type-hierarchy-and-Parametric-types","page":"Lecture","title":"More on Type hierarchy and Parametric types","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"How types and functions comes together and what is the role of their parametrisation?","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"An interesting feature of Julia's type system is parametrisation of types, which we have slightly touched above. Abstract and Composite types can be parametrised, where the parameter can be other type, sets of types, or or a value of any bits type.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Let's look at some examples. Julia defines an abstract type of arrays of various sizes and shapes as ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"abstract type AbstractArray{T,N} end","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"where it is expected T to be a type of the element of arrays and and N the number of dimenctions. It is expected that every type derived from an abstract array will implement certain function (there is an expected interface)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Depending on the variance of the type constructor, the subtyping relation of the simple types may be either preserved, reversed, or ignored for the respective complex types. In the OCaml programming language, for example, \"list of Cat\" is a subtype of \"list of Animal\" because the list type constructor is covariant. This means that the subtyping relation of the simple types are preserved for the complex types. ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"On the other hand, \"function from Animal to String\" is a subtype of \"function from Cat to String\" because the function type constructor is contravariant in the parameter type. Here the subtyping relation of the simple types is reversed for the complex types. ","category":"page"},{"location":"lecture_02/lecture/#The-power-of-Type-System-\\-and-multiple-dispatch","page":"Lecture","title":"The power of Type System \\& multiple dispatch","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Zero cost abstraction the compiler has information about types and can freely inline x |> identity |> identity |> identity |> identity |> identity","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"julia> f(x) = x |> identity |> identity |> identity |> identity |> identity\n@code_lowered f(1)\n@code_lowered f(1)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Why the type system is important for efficiency\nBad practices \nLABS:\nNumber type-tree\nDesign Interval Aritmetics (for ODES)","category":"page"},{"location":"lecture_02/lecture/#VS-NOtes:","page":"Lecture","title":"VS NOtes:","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Basics:","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"type hierarchy\nsubtyping\nUnions","category":"page"},{"location":"lecture_02/lecture/#Pevnak's-idea","page":"Lecture","title":"Pevnak's idea","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Type hierarchy and rationale behind","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"* Why I cannot create an abstract struct with fields.\n* Why a type cannot subtype more than one types\n* How the type matching system works and what are the rules (Would take Jan Vitek's lecture or earlier) https://youtu.be/Y95fAipREHQ?t=958c","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"What types do in practice and how it matters?","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"* Allow to structure the program (example two types with the same memory layout (even empty) specializes methods)\n* Provides an information how to arrange variables in computer memory\n* Inform compiler how things can be stored (possibly on stack (bit types) vs strictly on heap (arrays))\n* Inform compiler about what is known (mutable vs non-mutable structs). Explain that when things are mutable, they have to be \"boxed\", meaning the variable is on stack and the structure contains pointer. \n* The effect of not strictly typed structs, where the type inference of objects is left to runtime","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Performance gotchas","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"- Why global is slow and how `const` comes to rescue","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Show the above with @codetyped, @codenative and @btime the effects, such that they can see that.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Stefans's C++ example of overloading https://discourse.julialang.org/t/claim-false-julia-isnt-multiple-dispatch-but-overloading/42370/16","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"_ Discussion about multiple inheritance https://github.com/JuliaLang/julia/issues/5","category":"page"},{"location":"lecture_02/lecture/#Examples","page":"Lecture","title":"Examples","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"why Vector{AbstractFloat} is a bad idea, while Vector{Float64} is a good one?\nwhy Vector{AbstractFloat} is different to Vector{<:AbstractFloat} or Vector{T} where {T<:AbstractFloat} ","category":"page"},{"location":"lecture_02/lecture/#Why-[1,2,3]-is-not-a-Vector{Number}","page":"Lecture","title":"Why [1,2,3] is not a Vector{Number}","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Vector{Number} is a concrete type, and [1, 2, 3] has type Vector{Int}, which is also a concrete type. One concrete type is never a subtype of another concrete type, they are the leaves of the type tree.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Vector{Number} is concrete, even though Number is not a concrete type. That’s because it has a concrete implementation which can store all types that are subtypes of Number, it has a specific memory layout etc. On the other hand, AbstractVector{Int} is the other way around and not a concrete type, because the container is abstract even though the element is concrete.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"What you can do instead is [1, 2, 3] isa Vector{<:Number} which is true. That’s because <:Number is a sort of placeholder which means “any type which is a subtype of Number”. This is often needed for dispatching on containers where you want to allow set of element types. f(x::Vector{Number}) can take only arguments of type Vector{Number}, whereas g(x::Vector{<:Number}) can take e.g. Vector{Int}, Vector{Float64}, Vector{Real}, Vector{Number}, etc.","category":"page"},{"location":"lecture_02/lecture/#Frequently-asked-(and-discussed)-questions","page":"Lecture","title":"Frequently asked (and discussed) questions","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Why Abstract type cannot have a fields. In OOP, abstract classes can define fields that would be common to all derived classes. \nWhy type cannot be derived from multiple abstract type (mimicking Multiple inheritance). It seems like the function resolution might be difficult. An example copied from discussion in a 5th issue of the language opened in 2011 (and still not closed) (Image: ) show this usecase","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"abstract type A end;\nabstract tyle B end;\n\nf(::A) = 1\nf(::B) = 2\n\nstruct C <: A,B end;  # read as multiple inheritance.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"with that, it is not clear which function the compiler should call when f(C()). A current consensus seems to favour trait system support on the language level then the multiple inheritance, but priorities are elsewhere at the moment.","category":"page"},{"location":"lecture_02/lecture/#A-Headache-examples","page":"Lecture","title":"A Headache examples","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"This is a great example for type resolution.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"function Base.reduce(::typeof(hcat), xs::Vector{TV})  where {T, L, TV<:OneHotLike{T, L}}\n  OneHotMatrix(reduce(vcat, map(_indices, xs)), L)\nend","category":"page"},{"location":"lecture_02/lecture/#Turning-multiple-distpatch-to-single-dispatch","page":"Lecture","title":"Turning multiple-distpatch to single dispatch","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"https://stackoverflow.com/questions/39133424/how-to-create-a-single-dispatch-object-oriented-class-in-julia-that-behaves-l/39150509#39150509","category":"page"},{"location":"lecture_02/lecture/#conversion-among-variables","page":"Lecture","title":"conversion among variables","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"reinterpret(Float32, ref_sketch)","category":"page"},{"location":"lecture_02/lecture/#Trivia","page":"Lecture","title":"Trivia","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"why this is true Vector{Int} <: AbstractVector{<:Any} why this is false Vector{Int} <: Vector{Any} why this is true Vector{Int} <: Vector{<:Any}","category":"page"},{"location":"installation/#install","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"In order to participate in the course, everyone should install a recent version of Julia together with some text editor of choice. Furthermore during the course we will introduce some best practices of creating/testing and distributing your own Julia code, for which we will require a GitHub account.","category":"page"},{"location":"installation/#Julia-IDE","page":"Installation","title":"Julia IDE","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"There is no one way to install/develop and run Julia, which may be strange users coming from MATLAB, but for users of general purpose languages such as Python, C++ this is quite common. As of 2020 the most widely adopted way is in combination with the VSCode editor, for which there is an officially supported Julia extension. Moreover this setup is the same as with our bachelor course, which has provided an extensive tutorial mainly in case of installation on Windows machines, here. If you are using any other supported platform, you can use the guide as well replacing some steps with your system specifics. When deciding which version to download we recommend the latest stable release as of August 2021, 1.6.x, which has some quality of life improvements mainly with regards to readability. ","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Note that this setup is not a strict requirement for the lectures/labs and any other text editor with the option to send code to the terminal, such as Sublime Text, Vim+tmux or Atom will suffice (a major convenience when dealing with programming languages that support interactivity through a Read-Eval-Print Loop - REPL).","category":"page"},{"location":"installation/#GitHub-registration-and-Git-setup","page":"Installation","title":"GitHub registration & Git setup","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"As one of the goals of the course is writing code that can be distributed to others, we require a GitHub account, which you can create here (unless you already have one). In order to interact with GitHub repositories, we will be using git client. For installation instruction (Windows only) see the section in the bachelor course.","category":"page"},{"location":"lecture_01/motivation/#Introduction-to-Scientific-Programming","page":"Motivation","title":"Introduction to Scientific Programming","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Loose def: a scientific programming language is designed and optimized for the use of mathematical formula and matrices wiki","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Examples of Scientific programming languages include ALGOL, APL, Fortran, J, Julia, Maple, MATLAB and R.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Key requirements:","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"fast execution of the code (complex algorithms)\nease of code reuse / restructuring \nreproducibility of the results","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Contrast to general-purpose language:","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"less concern with business models (library + header files)\nless concern with ABI \nless concern with public/private separation","category":"page"},{"location":"lecture_01/motivation/#TODO","page":"Motivation","title":"TODO","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Zero cost abstraction - Rackcaucas","category":"page"},{"location":"lecture_01/motivation/#Example","page":"Motivation","title":"Example","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"In many applications, we encounter the task of optimization a function given by a routine (e.g. engineering, finance, etc.)","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"using Optim\n\nP(x,y) = x^2 - 3x*y + 5y^2 - 7y + 3   # user defined function\n\nz₀ = [ 0.0\n       0.0 ]     # starting point for optimization algorithm\n\noptimize(z -> P(z...), z₀, Newton())\n#optimize(z -> P(z...), z₀, Newton();autodiff = :forward)\n#optimize(z -> P(z...), z₀, ConjugateGradient())\n","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Very simple for a user, very complicated for a programmer. The program should:","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"pick the right optimization method (easy by config-like approach)\ncompute gradient (Hessian) of a user function","category":"page"},{"location":"lecture_01/motivation/#Classical-thinking:-create-a-library,-call-it.","page":"Motivation","title":"Classical thinking: create a library, call it.","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Think of an experiment: main taking a configuration file. The configuration file can be simple: input file, what to do with it, output file.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"The more complicated experiments you want to do, the more complex your configuration file becomes. Sooner or later, you will create a new configuration language, or scripting language.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Ending up in 2 language problem. ","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Low-level programming = computer centric\nclose to the hardware\nallows excellent optimization for fast execution\nHigh-level programming = user centric\nexperimenting = running multiple configurations\nrunning code with many different parameters as easily as possible\nallowing high level of abstraction","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"In scientific programming, the most well known scipting languages are: Python,  Matlab, R","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"If you care about standard \"configurations\" they are just perfect. \nYou hit a problem with more complex experiments. ","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"The scripting language typically makes decisions (if) at runtime. Becomes slow.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"(Image: )","category":"page"},{"location":"lecture_01/motivation/#Other-approaches","page":"Motivation","title":"Other approaches","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Just in time compilation (HL -> LL)\nautomatic typing (auto in C++) (LL->HL)","category":"page"},{"location":"lecture_01/motivation/#Challenge","page":"Motivation","title":"Challenge","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Translate high-level thinking with as much abstraction as possible into fast machine code.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Indexing array x in Matlab:","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"y=x(4/2)\ny=x(5/2)","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"In the first case it works, in the second throws an error.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"function inde(x,n,m), x(n/m) can never be fast.","category":"page"},{"location":"lecture_01/motivation/#Julia-way","page":"Motivation","title":"Julia way","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"strong but flexible type system\nmultiple dispatch\nsingle language from high to low levels (as much as possible)\noptimize execution as much as you can during runtime\nfunctions are symbolic abstract layers\nabstraction should have zero computational cost","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"(Image: )","category":"page"},{"location":"lecture_01/motivation/#Example:","page":"Motivation","title":"Example:","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Function recursion with arbitrary number of arguments:","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"fsum(x) = x\nfsum(x,p...) = x+fsum(p[1],p[2:end]...)\n\nfsum(1,2,3)\n@code_llvm fsum(1,2,3)\n@code_llvm fsum(1.0,2.0,3.0)\nfz()=fsum(1,2,3)\n@code_llvm fz()","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"More involved example:","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"using Zygote\n\nf(x)=3x+1\n@code_llvm f'(10)","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Fuctions can act eiter as regular functions or like templates in C++.","category":"page"},{"location":"lecture_01/motivation/#Advantages-and-disadvantages","page":"Motivation","title":"Advantages and disadvantages","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"compilation of everything to \nvery fast code\nslow interaction (caching...)\ngenerating libraries is harder \nthink of fsum, \neverything is \".h\" file\ndebugging will be harder\nMultiple dispatch\nallows great extensibility and code composition\nnot (yet) mainstream thinking","category":"page"},{"location":"lecture_07/macros/#Macros","page":"Macros","title":"Macros","text":"","category":"section"},{"location":"lecture_07/macros/#Homework-example??","page":"Macros","title":"Homework example??","text":"","category":"section"},{"location":"lecture_07/macros/","page":"Macros","title":"Macros","text":"Let them implement the accessors of the Ecosystem from labs 2 & 3 via metaprogramming (i.e. show them how Lazy.jl works)?","category":"page"},{"location":"how_to_submit_hw/#homeworks","page":"How to submit homeworks","title":"Homework submission","text":"","category":"section"},{"location":"how_to_submit_hw/","page":"How to submit homeworks","title":"How to submit homeworks","text":"This document should describe the homework submission procedure.","category":"page"},{"location":"lecture_02/hw/#Homework-2:-Predator-Prey-Agents","page":"Homework","title":"Homework 2: Predator-Prey Agents","text":"","category":"section"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"using Scientific_Programming_in_Julia\nusing Scientific_Programming_in_Julia.Ecosystem: eat!, find_food, agent_count","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"In this homework we will continue working on our agent simulation.  All your code must be in a single file called Ecosystem.jl containing all the type definitions and functions we created in Lab 2 and the work you do in this homework. Additionally to your code file you need a Project.toml that contains all your dependencies. You will learn more on environments and .toml-files in the lectures. For now zip your Ecosystem.jl and a Project.toml with the contents below and upload it to BRUTE to get your points.","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"name = \"Ecosystem\"\n\n[deps]\nStatsBase = \"2913bbd2-ae8a-5f71-8c99-4fb6c76f3a91\"","category":"page"},{"location":"lecture_02/hw/#Counting-Agents","page":"Homework","title":"Counting Agents","text":"","category":"section"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"To monitor the different populations in our world we need a function that counts each type of agent. For AbstractAnimals we simply have to count how many of each type are currently in our World. In the case of AbstractPlants we only want to count the ones that are fully grown.","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"<div class=\"admonition is-category-homework\">\n<header class=\"admonition-header\">Homework (2 points)</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"Implement a function agent_count that can be called on a single AbstractAgent and returns either 0 or 1 (i.e. always 1 for animals; 1 for a fully grown plant and 0 if the plant is not fully grown).\nAdd a method for a vector of agents Vector{<:AbstractAgent}.\nAdd a method for a World which returns a dictionary that contains pairs of Symbols and the agent count like below:","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"grass1 = Grass(true,5.0,5.0);\ngrass2 = Grass(false,5.0,2.0);\nsheep = Sheep(10.0,5.0,1.0,1.0);\nwolf  = Wolf(20.0,10.0,1.0,1.0);\nworld = World([grass1, grass2, sheep, wolf]);\n\nagent_count(world)  # the grass that is not fully grown is not counted","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"Hint: You can get the name of a type by using the nameof function:","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"nameof(Grass)","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"Use as much dispatch as you can! ;)","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"</div></div>\n<details class = \"solution-body\" hidden>\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"# first solution using foldl instead of a for loop\nagent_count(g::AbstractPlant) = g.fully_grown ? 1 : 0\nagent_count(::AbstractAnimal) = 1\nagent_count(as::Vector{<:AbstractAgent}) = sum(agent_count,as)\n\nfunction agent_count(w::World)\n    function op(d::Dict,a::T) where T<:AbstractAgent\n        n = nameof(T)\n        if n in keys(d)\n            d[n] += agent_count(a)\n        else\n            d[n] = agent_count(a)\n        end\n        return d\n    end\n    foldl(op, w.agents, init=Dict{Symbol,Int}())\nend","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"# second solution with StastBase.countmap\ncountsym(g::T) where T<:AbstractPlant = g.fully_grown ? nameof(T) : :NoCount\ncountsym(::T) where T<:AbstractAnimal = nameof(T)\n\nfunction agent_count(w::World)\n    cs = StatsBase.countmap(countsym.(w.agents))\n    delete!(cs,:NoCount)\nend","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"</p></details>","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise (voluntary)</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"Using the world below, run a simple simulation with 7 iterations.  In each iteration the wolf has to find_food and eat!.  Plot trajectories of the agent count over time.","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"(Do not include this code in your submission to BRUTE)","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"grass = [Grass(true,5.0,5.0) for _ in 1:2];\nsheep = [Sheep(10.0,5.0,1.0,1.0) for _ in 1:5];\nwolf  = Wolf(20.0,10.0,1.0,1.0);\nworld = World(vcat([wolf], sheep, grass));","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"grass = [Grass(true,5.0,5.0) for _ in 1:2];\nsheep = [Sheep(10.0,5.0,1.0,1.0) for _ in 1:5];\nwolf  = Wolf(20.0,10.0,1.0,1.0);\nworld = World(vcat([wolf], sheep, grass));\n\nns = nameof.(unique(typeof.(world.agents)))\ncounts = Dict(n=>[] for n in ns);\nfor _ in 1:7\n    cs = agent_count(world)\n    eat!(wolf, find_food(wolf,world), world)\n    for (n,c) in cs\n        push!(counts[n], c)\n    end\nend\n\nusing Plots\nplt = plot();\nfor n in ns\n    plot!(plt, counts[n], label=\"$n\", lw=2, ylims=(0,5))\nend\nplt","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"</p></details>","category":"page"},{"location":"lecture_01/hw/#Homework-1:-Extending-polynomial-the-other-way","page":"Homework","title":"Homework 1: Extending polynomial the other way","text":"","category":"section"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"<div class=\"admonition is-category-homework\">\n<header class=\"admonition-header\">Homework (1+1 points)</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"Extend the original polynomial function to the case where x is a square matrix. Create a function called circlemat, that returns nxn matrix A(n) with the following elements","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"leftA(n)right_ij = \nbegincases\n   1 textif  (i = j-1 land j  1) lor (i = n land j=1) \n   1 textif  (i = j+1 land j  n) lor (i = 1 land j=n) \n   0  text  otherwise\nendcases","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"and evaluate the polynomial","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"f(A) = I + A + A^2 + A^3","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":", at point A = A(10).","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"HINTS for matrix definition: You can try one of these options:","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"create matrix with all zeros with zeros(n,n), use two nested for loops going in ranges 1:n and if condition with logical or ||, and && \nemploy array comprehension with nested loops [expression for i in 1:n, j in 1:n] and ternary operator condition ? true branch : false","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"HINTS for polynomial extension:","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"extend the original example (one with for-loop) to initialize the accumulator variable with matrix of proper size (use size function to get the dimension), using argument typing for x is preferred to distinguish individual implementations <: AbstractMatrix","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"or","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"test later defined polynomial methods, that may work out of the box","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"</div></div>\n<details class = \"solution-body\" hidden>\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"As always there are multiple options for the circlemat function definition. Here we show the two, that we have foreshadowed in the homework hints:","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"longer version using incremental definition in for loop","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"function circlemat(n)\n    A = zeros(Int, n, n) # creates nxn matrix of zeros\n    for i in 1:n\n        for j in 1:n\n            if (i == j-1 && j > 1) || (i == n && j == 1) || (i == j+1 && j < n) || (i == 1 && j == n)\n                A[i,j] = 1\n            end\n        end\n    end\n    return A\nend\ncirclemat(10)","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"short version with comprehension and ternary operator","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"circlemat(n) = [(i == j-1 && j > 1) || (i == n && j == 1) || (i == j+1 && j < n) || (i == 1 && j == n) ? 1 : 0 for i in 1:n, j in 1:n]\ncirclemat(10)","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"Both version should give the same answer.","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"Extending the original polynomial to matrix valued point x = A, requires only small changes to the initialization of accumulator variable. Running directly the original code fails on MethodError, because julia cannot add a matrix to an integer.","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"function polynomial(a, x::AbstractMatrix) # we are limiting this function to everything that is subtype of AbstractMatrix\n    accumulator = zeros(eltype(x), size(x)) # zeros of the same type and size as `x`\n    for i in length(a):-1:1\n        accumulator += x^(i-1) * a[i] # ! 1-based indexing for arrays\n    end\n    return accumulator\nend","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"A = circlemat(10) # matrix of size 10x10\ncoeffs = ones(4)  # coefficients of polynomial\npolynomial(coeffs, A)","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"The other option is to use the more abstract version that we have defined to work with generators/iterators. For example","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"polynomial(a, x) = sum(ia -> x^(ia[1]-1) * ia[2], enumerate(a))","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"works out of the box","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"circlemat(n) = [(i == j-1 && j > 1) || (i == n && j == 1) || (i == j+1 && j < n) || (i == 1 && j == n) ? 1 : 0 for i in 1:n, j in 1:n] #hide\nA = circlemat(10) #hide\ncoeffs = ones(4)  #hide\npolynomial(coeffs, A)","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"</p></details>","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise (voluntary)</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"Install GraphRecipes and Plots packages into our ./L1Env/ environment defined during the lecture and figure out, how to plot the graph defined by adjacency matrix A from the homework.","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"HINTS:","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"There is help command inside the the pkg mod of the REPL. Type ? add to find out how to install a package. Note that both pkgs are registered.\nFollow a guide in the Plots pkg's documentation, which is accessible through docs icon on top of the README in the GitHub repository. Direct link.","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"Activate L1Env environment in pkg mode, if it is not currently active.","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"pkg> activate ./L1Env","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"Installing pkgs is achieved using the add command. Running ] ? add returns a short piece of documentation for this command:","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"pkg> ? add\n[...]\n  Examples\n\n  pkg> add Example                                          # most commonly used for registered pkgs (installs usually the latest release)\n  pkg> add Example@0.5                                      # install with some specific version (realized through git tags)\n  pkg> add Example#master                                   # install from master branch directly\n  pkg> add Example#c37b675                                  # install from specific git commit\n  pkg> add https://github.com/JuliaLang/Example.jl#master   # install from specific remote repository (when pkg is not registered)\n  pkg> add git@github.com:JuliaLang/Example.jl.git          # same as above but using the ssh protocol\n  pkg> add Example=7876af07-990d-54b4-ab0e-23690620f79a     # when there are multiple pkgs with the same name","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"As the both Plots and GraphRecipes are registered and we don't have any version requirements, we will use the first option.","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"pkg> add Plots\npkg> add GraphRecipes","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"This process downloads the pkgs and triggers some build steps, if for example some binary dependencies are needed. The process duration depends on the \"freshness\" of Julia installation and the size of each pkg. With Plots being quite dependency heavy, expect few minutes. After the installation is complete we can check the updated environment with the status command.","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"pkg> status","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"The plotting itself as easy as calling the graphplot function on our adjacency matrix.","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"using GraphRecipes, Plots\ngraphplot(A)","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"graphplot(A) #hide","category":"page"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"</p></details>","category":"page"},{"location":"lecture_01/hw/#How-to-submit?","page":"Homework","title":"How to submit?","text":"","category":"section"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"The guide is located here.","category":"page"},{"location":"lecture_02/example/#from-introduction","page":"-","title":"from introduction","text":"","category":"section"},{"location":"lecture_02/example/","page":"-","title":"-","text":"Recursive call","category":"page"},{"location":"lecture_02/example/","page":"-","title":"-","text":"fsum(x) = x\nfsum(x,p...) = x+fsum(p[1],p[2:end]...)","category":"page"},{"location":"lecture_02/example/","page":"-","title":"-","text":"Is a template how to behave:","category":"page"},{"location":"lecture_02/example/","page":"-","title":"-","text":"julia is a typed language: x, and p are of type Any\nwhat happens when calling:","category":"page"},{"location":"lecture_02/example/","page":"-","title":"-","text":"fsum(1,2,3)\nfsum(1,'c')\nfsum(1,\"c\")","category":"page"},{"location":"lecture_02/example/","page":"-","title":"-","text":"Show what \"+\" function do, ","category":"page"},{"location":"lecture_02/example/","page":"-","title":"-","text":"methods(+)","category":"page"},{"location":"lecture_02/example/","page":"-","title":"-","text":"what is multiple dispatch, how differnt it is from operator overloading. (Stefans example from lecture)","category":"page"},{"location":"lecture_02/example/#Show-error-message:","page":"-","title":"Show error message:","text":"","category":"section"},{"location":"lecture_02/example/","page":"-","title":"-","text":"explain why fsum(1,\"c\") failed.","category":"page"},{"location":"lecture_02/example/#Introduce-type-hierarchy","page":"-","title":"Introduce type hierarchy","text":"","category":"section"},{"location":"lecture_02/example/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"lecture_02/example/","page":"-","title":"-","text":"Define fsum(x::Number,p...) = x+fsum(p[1],p[2:end]...)\nShow how to extend to Arrays\nDefine fsum(x::AbstractArray,p...) = x+fsum(p[1],p[2:end]...)\nUnion","category":"page"},{"location":"lecture_01/outline/#Course-outline","page":"Outline","title":"Course outline","text":"","category":"section"},{"location":"lecture_01/outline/","page":"Outline","title":"Outline","text":"type system\nuser: tool for abstraction\ncompiler: tool for memory layout\ndesign patterns (mental setup)\njulia is a type-based language\ngeneralizes OOP and FP\nPackages\nway how to organize code\ncode reuse (alternative to libraries)\nexperiment reproducibility\n","category":"page"},{"location":"lecture_01/outline/#How-to-write-fast-code:","page":"Outline","title":"How to write fast code:","text":"","category":"section"},{"location":"lecture_01/outline/","page":"Outline","title":"Outline","text":"(Image: )","category":"page"},{"location":"lecture_01/outline/","page":"Outline","title":"Outline","text":"cache misses.","category":"page"},{"location":"lecture_01/outline/#Syntax","page":"Outline","title":"Syntax","text":"","category":"section"},{"location":"lecture_01/outline/","page":"Outline","title":"Outline","text":"Syntactic Sugar: Cheat sheet: https://cheatsheets.quantecon.org/","category":"page"},{"location":"lecture_01/outline/#Typing-Lecture-2","page":"Outline","title":"Typing -> Lecture 2","text":"","category":"section"},{"location":"lecture_01/outline/","page":"Outline","title":"Outline","text":"static\ndynamic","category":"page"},{"location":"lecture_01/outline/#","page":"Outline","title":"","text":"","category":"section"},{"location":"lecture_03/hw/#Homework-3","page":"Homework","title":"Homework 3","text":"","category":"section"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"using Scientific_Programming_in_Julia\nusing Scientific_Programming_in_Julia.Ecosystem: eat!, find_food, count\n\nn_grass       = 500\nregrowth_time = 17.0\n\nn_sheep         = 100\nΔenergy_sheep   = 5.0\nsheep_reproduce = 0.5\nsheep_foodprob  = 0.4\n\nn_wolves       = 8\nΔenergy_wolf   = 17.0\nwolf_reproduce = 0.03\nwolf_foodprob  = 0.02\n\ngs = [Grass(true,regrowth_time,regrowth_time) for _ in 1:n_grass]\nss = [Sheep(2*Δenergy_sheep,Δenergy_sheep,sheep_reproduce, sheep_foodprob) for _ in 1:n_sheep]\nws = [Wolf(2*Δenergy_wolf,Δenergy_wolf,wolf_reproduce, wolf_foodprob) for _ in 1:n_wolves]\n\nw = World(vcat(gs,ss,ws))","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"In this homework we will extend our agent simulation with more powerful callbacks and add a second type of grass. You can use the following snippet from the labs as a base simulation script","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"n_grass       = 500\nregrowth_time = 17.0\n\nn_sheep         = 100\nΔenergy_sheep   = 5.0\nsheep_reproduce = 0.5\nsheep_foodprob  = 0.4\n\nn_wolves       = 8\nΔenergy_wolf   = 17.0\nwolf_reproduce = 0.03\nwolf_foodprob  = 0.02\n\ngs = [Grass(true,regrowth_time,regrowth_time) for _ in 1:n_grass]\nss = [Sheep(2*Δenergy_sheep,Δenergy_sheep,sheep_reproduce, sheep_foodprob) for _ in 1:n_sheep]\nws = [Wolf(2*Δenergy_wolf,Δenergy_wolf,wolf_reproduce, wolf_foodprob) for _ in 1:n_wolves]\n\nw = World(vcat(gs,ss,ws))\n\ncbs = [w->(@info agent_count(w))]\nsimulate!(w, 10, callbacks=cbs)","category":"page"},{"location":"lecture_03/hw/#Smarter-callbacks-through-closures","page":"Homework","title":"Smarter callbacks through closures","text":"","category":"section"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"Often we want our callbacks to be executed only every Nth step. This can be used to get less verbose logging or e.g. to write out checkpoints of your simulation.","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"<div class=\"admonition is-category-homework\">\n<header class=\"admonition-header\">Homework (1 point)</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"Implement a function every_nth(f::Function,n::Int) that takes a function and uses a closure to construct another function that only calls f every n calls to the function fn that is returned by every_nth(f,n).","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"You can use every_nth to log and save the agent count only every couple of steps of your simulation. Using every_nth will look like this:","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"# `@info agent_count(w)` is executed only every 5th call to logcb(w)\nlogcb = every_nth(w->(@info agent_count(w)), 5);\n\nfor i in 1:10\n    logcb(w)\nend","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"</div></div>\n<details class = \"solution-body\" hidden>\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"function every_nth(f::Function, n::Int)\n    i = 1\n    function callback(w::World)\n        # display(i) # comment this out to see how the counter increases\n        if i == n\n            f(w)\n            i = 1\n        else\n            i += 1\n        end\n    end\nend","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"</p></details>","category":"page"},{"location":"lecture_03/hw/#Poisoned-grass","page":"Homework","title":"Poisoned grass","text":"","category":"section"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"In the previous exercises you have seen that multiple dispatch makes it easy to add new methods to a given type (much easier than in OOP!).  In this exercise you will see that it is just as easy to add a completely new type to our hierarchy and reuse the methods that we have already defined (similar to inheritance in OOP).","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"As an example, lets implement a PoisonedGrass which will decrease the energy of a sheep that ate it. Apart from the accessors (like energy, energy!, etc.) we have a few essential functions: agent_step!, reproduce!, find_food, eats, and eat!. If you look at their type signatures you can see that the first three already operate on any AbstractAnimal/AbstractPlant. This means that for any subtype that has the expected fields (i.e. energy, reproduction_prob, etc.) these functions already work.","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"Therefore, the only methods we have to implement for a new animal or plant are the eats and eat! methods because they are specific for each concrete type.","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"<div class=\"admonition is-category-homework\">\n<header class=\"admonition-header\">Homework (2 points)</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"Define a new subtype of AbstractPlant called PoisonedGrass which will decrease a sheep's energy by Delta E if it is eaten.","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"Implement the functions eat! and eats in order to make the simulation work with PoisonedGrass.","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"How much poisoned grass can you add to the simulation without wiping out the sheep population?","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"</div></div>\n<details class = \"solution-body\" hidden>\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"mutable struct PoisonedGrass <: AbstractPlant\n    fully_grown::Bool\n    regrowth_time::Int\n    countdown::Int\nend\nPoisonedGrass(t) = PoisonedGrass(false, t, rand(1:t))\n\nfunction eat!(sheep::Sheep, grass::PoisonedGrass, w::World)\n     if grass.fully_grown\n        grass.fully_grown = false\n        sheep.energy -= sheep.Δenergy\n    end\nend\n\neats(::Sheep,::PoisonedGrass) = true","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"</p></details>","category":"page"},{"location":"lecture_01/lab/#Lab-01:-Introduction-to-Julia","page":"Lab","title":"Lab 01: Introduction to Julia","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"This lab should get everyone up to speed in the basics of Julia's installation, syntax and basic coding. For more detailed introduction you can check out Lectures 1-3 of the bachelor course.","category":"page"},{"location":"lecture_01/lab/#Testing-Julia-installation","page":"Lab","title":"Testing Julia installation","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"In order to proceed further let's run a simple script to see, that the setup described in chapter Installation is working properly. After spawning a terminal run this command:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"julia ./test_setup.jl","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The script does the following ","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"\"Tests\" if Julia is added to path and can be run with julia command from anywhere\nPrints Hello World and Julia version info\nCreates an environment configuration files\nInstalls a basic pkg called BenchmarkTools, which we will use for benchmarking a simple function later in the labs.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"There are some quality of life improvements over long term support versions of Julia and thus for the course of these lectures we will use the latest stable release of Julia 1.6.x.","category":"page"},{"location":"lecture_01/lab/#Polynomial-evaluation-example","page":"Lab","title":"Polynomial evaluation example","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Let's consider a common mathematical example for evaluation of nth-degree polynomial","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"f(x) = a_nx^n + a_n-1x^n-1 + dots + a_0x^0","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"where x in mathbbR and veca in mathbbR^n+1.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The simplest way of writing this is just realizing that essentially the function f is really implicitly containing argument veca, i.e. f equiv f(veca x), yielding the following function","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"function polynomial(a, x)\n    accumulator = 0\n    for i in length(a):-1:1\n        accumulator += x^(i-1) * a[i] # ! 1-based indexing for arrays\n    end\n    return accumulator\nend\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Evaluate the code of the function called polynomial in Julia REPL and evaluate the function itself with the following arguments.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"a = [-19, 7, -4, 6] # list coefficients a from a^0 to a^n\nx = 3               # point of evaluation\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The simplest way is to just copy&paste into an already running terminal manually. As opposed to the default Python REPL, Julia can deal with the blocks of code and different indentation much better without installation of an ipython-like REPL. There are ways to make this much easier in different text editors/IDEs:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"VSCode - when using Julia extension, by default Ctrl+Enter will spawn Julia REPL, when a .jl file is opened\nSublime Text - Send Code pkg (works well with Linux terminal or tmux, support for Windows is poor)\nVim - there is a Julia language plugin, which can be combine with vimcmdline","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Either way, you should see the following:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"function polynomial(a, x)\n    accumulator = 0\n    for i in length(a):-1:1\n        accumulator += x^(i-1) * a[i] # ! 1-based indexing for arrays\n    end\n    return accumulator\nend","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Similarly we enter the arguments of the function a and x:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"a = [-19, 7, -4, 6]\nx = 3","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Function call intuitively takes the name of the function with round brackets as arguments, i.e. works in the same way as majority of programming languages. The result is printed unless a ; is added at the end of the statement.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"polynomial(a, x)    # function call","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Thanks to the high level nature of Julia language it is often the case that examples written in pseudocode are almost directly rewritable into the language itself without major changes and the code can be thus interpreted easily.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"(Image: polynomial_explained)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The indentation is not necessary as opposed to other languages such as Python, due to the existence of the end keyword, however it is strongly recommended to use it, see style guide. Furthermore the return keyword can be omitted if the last line being evaluated contains the result, unless the line ends with ;.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Though there are libraries/IDEs that allow us to step through Julia code (Rebugger.jl link and VSCode link), we can (having defined the arguments with the same name as inside the actual function) evaluate pieces of code separately. ","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Evaluate the following pieces of code and check their type with typeof function, e.g. typeof(a) or typeof([-19, 7, -4, 6])","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"BONUS: Try to \"call for help\" by accessing the build in help terminal by typing ? followed by a keyword to explain. Use this for basic functions such as length, typeof, ^.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"a = [-19, 7, -4, 6]\nx = 3\naccumulator = 0\nlength(a):-1:1\n\ni = length(a)\naccumulator += x^(i-1) * a[i]\naccumulator\n\npolynomial\n^\n*","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"When defining a variable through an assignment we get the representation of the right side, again this is different from the default  behavior in Python, where the output of a = [-19, 7, -4, 6], prints nothing. In Julia REPL we get the result of the display function.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"julia> a = [-19, 7, -4, 6]\njulia> display(a) # should return the same thing as the line above","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"As you can see, the string that is being displayed contains information about the contents of a variable along with it's type in this case this is a Vector of Int types. Which can be checked further with the typeof function:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(a)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"In most cases variables store just a reference to a place in memory either stack/heap (exceptions are primitive types such as Int, Float) and therefore creating an array a, storing the reference in b with b = a and changing elements of b, e.g. b[1] = 2, changes also the values in a.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The other two assignments are exactly the same as they both generate an instance of Int type with different values. Though now one has to call for hell the typeof function, because by default this information is omitted in the display of simple types.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"x = 3\naccumulator = 0\ntypeof(x), typeof(accumulator)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The next expression creates an instance of a range, which are inclusive in Julia, i.e. containing number from start to end - in this case running from 4 to 1 with negative step -1, thus counting down.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"length(a):-1:1\ntypeof(length(a):-1:1)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Let's confirm the fact that the update operator += really does update the variable accumulator by running the following","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"i = length(a) # \naccumulator += x^(i-1) * a[i]\naccumulator","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Notice that evaluating a variable, which can be used instead of the return keyword at the end of a function.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"We have already seen the output of evaluating polynomial function name in the REPL By creating the function polynomial we have defined a variable polynomial, that from now on always refers to a function and cannot be redefined with a different type.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"polynomial","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"This is cause by the fact that each function defines essentially a new type, the same like Int ~ Int64 or Vector{Int}.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(polynomial)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"You can check that it is a subtype of the Function abstract type, with the subtyping operator <:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(polynomial) <: Function","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"These concepts will be expanded further in the type lecture, however for now note that this construction is quite useful for example if we wanted to create derivative rules for our function derivativeof(::typeof(polynomial), ...).","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Looking at the last two expersions +, *, we can see that in Julia, operators are also functions. ","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"+\n*","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The main difference from our polynomial function is that there are multiple methods, for each of these functions. Each one of the methods coresponds to a specific combination of arguments, for which the function can be specialized to. You can see the list by calling a methods function:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"julia> methods(+)\n# 190 methods for generic function \"+\":                                                                               \n[1] +(x::T, y::T) where T<:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8} in Base at\n int.jl:87                                                                                                            \n[2] +(c::Union{UInt16, UInt32, UInt64, UInt8}, x::BigInt) in Base.GMP at gmp.jl:528                                   \n[3] +(c::Union{Int16, Int32, Int64, Int8}, x::BigInt) in Base.GMP at gmp.jl:534\n...","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"One other notable difference is that these functions allow using both infix and postfix notation a + b and +(a,b), which is a speciality of elementary functions such as arithmetic operators or set operation such as ∩, ∪, ∈.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"BONUS: Accessing help terminal ? and looking up a keyword, searches for documentation of individual methods/functions in the source code. When creating a pkg, it is desirable to create so called docstrings for each method that is going to be exported. docstrings are multiline strings written above a function. More on this in lecture on pkg development.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"\"\"\"\n    polynomial(a, x)\n\nReturns value of a polynomial with coefficients `a` at point `x`.\n\"\"\"\nfunction polynomial(a, x)\n    # function body\nend","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"As the arguments of the polynomial functions are untyped, i.e. they do not specify the allowed types like for example polynomial(a, x::Number) does, the following exercise explores how wide range of arguments does the","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"What happens if you call our polynomial function with with the following coefficients?","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"af = [-19.0, 7.0, -4.0, 6.0]\nat = (-19, 7, -4, 6)\nant = (a₀ = -19, a₁ = 7, a₂ = -4, a₃ = 6)\na2d = [-19 -4; 7 6]\nach = ['1', '2', '3', '4']\nac = [2i^2 + 1 for i in -2:1]\nag = (2i^2 + 1 for i in -2:1)\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Check first the types of each of these coefficients by calling typeof and eltype.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"BONUS: In the case of ag, use the collect function to get the desirable result. What does it do? Check again the type of the result.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(af), eltype(af)\npolynomial(af, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"As opposed to the basic definition of a type the array is filled with Float64 types and the resulting value gets promoted as well to the Float64.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(at), eltype(at)\npolynomial(at, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"With round brackets over a fixed length vector we get the Tuple type, which is a fixed size, so called immutable \"array\" of a fixed size (its elements cannot be changed, unless initialized from scratch). Each element can be of a different type, but here we have only one and thus the Tuple is aliased into NTuple. There are some performance benefits for using immutable structure, which will be discussed later or even later.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Defining key=value pairs inside round brackets creates a structure called NamedTuple, which has the same properties as Tuple and furthermore it's elements can be conveniently accessed by dot syntax, e.g. ant.a₀.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(ant), eltype(ant)\npolynomial(ant, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Defining a 2D array is a simple change of syntax, which initialized a matrix row by row separated by ; with spaces between individual elements. The function works in the same way because linear indexing works in 2d arrays in the column major order.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(a2d), eltype(a2d)\npolynomial(a2d, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Consider the vector/array of characters, which themselves have numeric values (you can check by converting them to Int Int('1') or convert(Int, 'l')). In spite of that, our untyped function cannot process such input, as there isn't an operation/method that would allow  multiplication of Char and Int type. Julia tries to promote the argument types to some common type, however checking the promote_type(Int, Char) returns Any (union of all types), which tells us that the conversion is not possible automatically.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(ach), eltype(ach)\npolynomial(ach, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"In the stacktrace we can see the location of each function call. If we include the function polynomial from some file poly.jl using include(\"poly.jl\"), we will see that the location changes from REPL[X]:10 to the the actual file name.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The next example shows so called array comprehension syntax, where we define and array of known length using and for loop iteration. Resulting array/vector has integer elements, however even mixed type is possible yielding Any, if there isn't any other common supertype to promote every entry into. (Use ? to look what promote and promote_type does.)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(ac), eltype(ac)\npolynomial(ac, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"By swapping square brackets for round we have defined so called generator/iterator, which as opposed to the previous example does not allocate an array, only the structure that produces it. You may notice that the element type in this case is Any, which means that a function using such generator as an argument cannot specialize based on the type and has to infer it every time an element is generated/returned. We will touch on how this affects performance in one of the later lectures.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(ag), eltype(ag)\npolynomial(ag, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"BONUS: In general generators may have unknown length, this can be useful for example in batch processing of files, where we do not know beforehand how many files are in a given folder. However the problem here originated from a missing indexing operation getindex, which can be easily solved by collecting the generator with collect and thus transforming it into and array.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"agc = ag |> collect # pipe syntax, equivalent to collect(ag)\ntypeof(agc), eltype(agc)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"You can see now that eltype is no longer Any, as a proper type for the whole container has been found in the collect function, however we have lost the advantage of not allocating an array.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_01/lab/#Extending/limiting-the-polynomial-example","page":"Lab","title":"Extending/limiting the polynomial example","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Following up on the polynomial example, let's us expand it a little further in order to facilitate the the arguments, that have been throwing exceptions. The first direction, that we will move forward to, is providing the user with more detailed error message when an incorrect type of coefficients has been provided.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Design an if-else condition such that the array of Char example throws an error with custom string message, telling the user what went wrong and printing the incorrect input alongside it. Confirm that we have not broken the functionality of other examples from previous exercise.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"HINTS:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Throw the ArgumentError(msg) with throw function and string message msg. More details in help mode ? or at the end of this document.\nStrings are defined like this s = \"Hello!\"\nUse string interpolation to create the error message. It allows injecting an expresion into a string with the $ syntax b = 1; s = \"Hellow Number $(b)\"\nCompare eltype of the coefficients with Char type.\nThe syntax for if-else:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"if condition\n    println(\"true\") # true branch code\nelse\n    println(\"false\") # false branch code\nend","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Not equal condition can be written as a != b.\nThrowing an exception automatically returns from the function. Use return inside one of the branches to return the correct value.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The simplest way is to wrap the whole function inside an if-else condition and returning only when the input is \"correct\" (it will still fail in some cases).","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"function polynomial(a, x)\n    if eltype(a) != Char\n        accumulator = 0\n        for i in length(a):-1:1\n            accumulator += x^(i-1) * a[i] # ! 1-based indexing for arrays\n        end\n        return accumulator\n    else\n        throw(ArgumentError(\"Invalid coefficients $(a) of type Char!\"))\n    end\nend\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Now this should show our predefined error message.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"polynomial(ach, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Testing on other examples should pass without errors and give the same output as before.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"polynomial(a, x)\npolynomial(af, x)\npolynomial(at, x)\npolynomial(ant, x)\npolynomial(a2d, x)\npolynomial(ac, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The second direction concerns the limitation to index-able structures, which the generator example is not. For this we will have to rewrite the whole loop in a more functional programming approach using map, anonymous function and other concepts.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Rewrite the following code inside our original polynomial function with map, enumerate and anonymous function.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"accumulator = 0\nfor i in length(a):-1:1\n    accumulator += x^(i-1) * a[i] # ! 1-based indexing for arrays\nend","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Anonymous functions reminder:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"x -> x + 1              # unless the reference is stored it cannot be called\nplusone = x -> x + 1    # the reference can be stored inside a variable\nplusone(x)              # calling with the same syntax","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"HINTS:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Use enumerate to obtain iterator over a that returns a tuple of ia = (i, aᵢ). With Julia 1-based indexing i starts also from 1 and goes up to length(a).\nPass this into a map with either in-place or predefined anonymous function that does the operation of x^(i-1) * aᵢ.\nUse sum to collect the resulting array into accumulator variable or directly into the return command.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"BONUS: There is even shorter way how to write this using one line function syntax and recently added options to the sum function. See entry in the help mode ?.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Ordered from the longest to the shortest, here are three (and there are definitely more) examples with the same functionality. Using the map(iterable) do itervar ... end syntax, that creates anonymous function from the block of code.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"function polynomial(a, x)\n    powers = map(enumerate(a)) do (i, aᵢ)\n        x^(i-1) * aᵢ\n    end\n    accumulator = sum(powers)\n    return accumulator\nend\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Using the default syntax for map and storing the anonymous into a variable","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"function polynomial(a, x)\n    polypow = ia -> x^(ia[1]-1) * ia[2] # \n    powers = map(polypow, enumerate(a))\n    return sum(powers)\nend\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"As the function polypow is used only once, there is no need to assign it to a local variable.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"function polynomial(a, x)\n    powers = map(ia -> x^(ia[1]-1) * ia[2], enumerate(a))\n    sum(powers)\nend\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Checking the behavior on all the inputs.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"polynomial(a, x)\npolynomial(af, x)\npolynomial(at, x)\npolynomial(ant, x)\npolynomial(a2d, x)\npolynomial(ach, x)\npolynomial(ac, x)\npolynomial(ag, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"BONUS: Using one line function definition and the recently added option of a function in the first argument of sum:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"polynomial(a, x) = sum(ia -> x^(ia[1]-1) * ia[2], enumerate(a))\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_01/lab/#How-to-use-code-from-other-people","page":"Lab","title":"How to use code from other people","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The script that we have run at the beginning of this lab has created a folder L1Env with the following files.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"./L1Env/\n    ├── Manifest.toml\n    ├── Project.toml\n    └── src\n        └── L1Env.jl","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Every folder with a toml file called Project.toml, can be used by Julia's pkg manager into setting so called environment. Each of these environments has a specific name, unique identifier and most importantly a list of pkgs to be installed. Setting up or more often called activating an environment can be done either before starting Julia itself by running julia with the --project XXX flag or from withing the Julia REPL, by switching to Pkg mode with ] key (similar to the help mode activated by pressing ?) and running command activate.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"So far we have used the general environment, which by default does not come with any 3rd party packages and includes only the base and standard libraries - already quite powerful on its own. ","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"In order to find which environment is currently active, run the following:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"pkg> status","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The output of such command usually indicates the general environment located at .julia/ folder (${HOME}/.julia/ or ${APPDATA}/.julia/ in case of Unix/Windows based systems respectively)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"pkg> status\nStatus `~/.julia/environments/v1.6/Project.toml` (empty project)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Generally one should avoid working in the general environment, with the exception using some generic pkgs, such as PkgTemplates.jl, which is used for generating pkg templates/folder structure like the one above (link), more on this in the lecture on pkg development. ","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Activate the L1Env environment inside ./L1Env and check that the BenchmarkTools package has been installed. Use BenchmarkTools pkg's @btime to benchmark our polynomial function with the following arguments.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"aexp = ones(10) ./ factorial.(0:9)\nx = 1.1\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"HINTS:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"In pkg mode use the command activate and status to check the presence. \nIn order to import the functionality from other package, lookup the keyword using in the repl help mode ?. \nThe functionality that we want to use is the @btime macro (it acts almost like a function but with a different syntax @macro arg1 arg2 arg3 ...). More on macros in the corresponding lecture.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"BONUS: Compare the output of polynomial(aexp, x) with the value of exp(x), which it approximates.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"note: Broadcasting\nIn the assignment's code, we are using quite ubiquitous concept in Julia called broadcasting or simply the dot-syntax - see ./, factorial.. This concept allows to map both simple arithmetic operations as well as custom functions across arrays, with the added benefit of increased performance, when the broadcasting system can merge operations into a more efficient code. More information can be found in the official documentation or section of our bachelor course.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"There are other options to import a function/macro from a different package, however for now let's keep it simple with the using Module syntax, that brings to the REPL, all the variables/function/macros exported by the BenchmarkTools pkg. If @btime is exported, which it is, it can be accessed without specification i.e. just by calling @btime without the need for BenchmarkTools.@btime. More on the architecture of pkg/module loading in the package developement lecture.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"using BenchmarkTools\n@btime polynomial(aexp, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The output gives us the time of execution averaged over multiple runs (the number of samples is defined automatically based on run time) as well as the number of allocations and the output of the function, that is being benchmarked.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"BONUS: The difference between our approximation and the \"actual\" function value computed as a difference of the two. ","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"polynomial(aexp, x) - exp(x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The apostrophes in the previous sentece are on purpose, because implementation of exp also relies too on a finite sum, though much more sophisticated than the basic Taylor expansion.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_01/lab/#Discussion-and-future-directions","page":"Lab","title":"Discussion & future directions","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Instead of if-else statements that would throw an error for different types, in Julia, we generally see the pattern of typing the function in the way. that for other than desirable types MethodError is emitted with the information about closest matching methods. This is part of the design process in Julia of a function and for the particular functionality of the polynomial example, we can look into the Julia itself, where it has been implemented in the evalpoly function","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"methods(evalpoly)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Another avenue, that we have only touched with the BenchmarkTools, is performance and will be further explored in the later lectures.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"With the next lecture focused on typing in Julia, it is worth noting that polynomials lend itself quite nicely to a definition of a custom type, which can help both readability of the code as well further extensions.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"struct Polynom{C}\n    coefficients::{C}\nend\n\nfunction (p:Polynom)(x)\n    polynomial(p.coefficients, x)\nend","category":"page"},{"location":"lecture_01/lab/#Useful-resources","page":"Lab","title":"Useful resources","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Getting Started tutorial from JuliaLang documentation - Docs\nConverting syntax between MATLAB ↔ Python ↔ Julia - Cheatsheet\nBachelor course for refreshing your knowledge - Course\nStylistic conventions - Style Guide\nReserved keywords - List","category":"page"},{"location":"lecture_01/lab/#lab_errors","page":"Lab","title":"Various errors and how to read them","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"This section summarizes most commonly encountered types of errors in Julia and how to resolve them or at least understand, what has gone wrong. It expands a little bit the official documentation, which contains the complete list with examples. Keep in mind again, that you can use help mode in the REPL to query error types as well.","category":"page"},{"location":"lecture_01/lab/#MethodError","page":"Lab","title":"MethodError","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"This type of error is most commonly thrown by Julia's multiple dispatch system with a message like no method matching X(args...), seen in two examples bellow.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"2 * 'a'                       # many candidates\ngetindex((i for i in 1:4), 3) # no candidates","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Both of these examples have a short stacktrace, showing that the execution failed on the top most level in REPL, however if this code is a part of some function in a separate file, the stacktrace will reflect it. What this error tells us is that the dispatch system could not find a method for a given function, that would be suitable for the type of arguments, that it has been given. In the first case Julia offers also a list of candidate methods, that match at least some of the arguments","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"When dealing with basic Julia functions and types, this behavior can be treated as something given and though one could locally add a method for example for multiplication of Char and Int, there is usually a good reason why Julia does not support such functionality by default. On the other hand when dealing with user defined code, this error may suggest the developer, that either the functions are too strictly typed or that another method definition is needed in order to satisfy the desired functionality.","category":"page"},{"location":"lecture_01/lab/#InexactError","page":"Lab","title":"InexactError","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"This type of error is most commonly thrown by the type conversion system (centered around convert function), informing the user that it cannot exactly convert a value of some type to match arguments of a function being called.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Int(1.2)                      # root cause\nappend!([1,2,3], 1.2)         # same as above but shows the root cause deeper in the stack trace","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"In this case the function being Int and the value a floating point. The second example shows InexactError may be caused deeper inside an inconspicuous function call, where we want to extend an array by another value, which is unfortunately incompatible.","category":"page"},{"location":"lecture_01/lab/#ArgumentError","page":"Lab","title":"ArgumentError","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"As opposed to the previous two errors, ArgumentError can contain user specified error message and thus can serve multiple purposes. It is however recommended to throw this type of error, when the parameters to a function call do not match a valid signature, e.g. when factorial were given negative or non-integer argument (note that this is being handled in Julia by multiple dispatch and specific DomainError).","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"This example shows a concatenation of two 2d arrays of incompatible sizes 3x3 and 2x2.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"hcat(ones(3,3), zeros(2,2))","category":"page"},{"location":"lecture_01/lab/#KeyError","page":"Lab","title":"KeyError","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"This error is specific to hash table based objects such as the Dict type and tells the user that and indexing operation into such structure tried to access or delete a non-existent element.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"d = Dict(:a => [1,2,3], :b => [1,23])\nd[:c]","category":"page"},{"location":"lecture_01/lab/#TypeError","page":"Lab","title":"TypeError","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Type assertion failure, or calling an intrinsic function (inside LLVM, where code is strictly typed) with incorrect argument type. In practice this error comes up most often when comparing value of a type against the Bool type as seen in the example bellow.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"if 1 end                # calls internally typeassert(1, Bool)\ntypeassert(1, Bool)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"In order to compare inside conditional statements such as if-elseif-else or the ternary operator x ? a : b the condition has to be always of Bool type, thus the example above can be fixed by the comparison operator: if 1 == 1 end (in reality either the left or the right side of the expression contains an expression or a variable to compare against).","category":"page"},{"location":"lecture_01/lab/#UndefVarError","page":"Lab","title":"UndefVarError","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"While this error is quite self-explanatory, the exact causes are often quite puzzling for the user. The reason behind the confusion is to do with code scoping, which comes into play for example when trying to access a local variable from outside of a given function or just updating a global variable from within a simple loop. ","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"In the first example we show the former case, where variable is declared from within a function and accessed from outside afterwards.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"function plusone(x)\n    uno = 1\n    return x + uno\nend\nuno # defined only within plusone","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Unless there is variable I_am_not_defined in the global scope, the following should throw an error.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"I_am_not_defined","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Often these kind of errors arise as a result of bad code practices, such as long running sessions of Julia having long forgotten global variables, that do not exist upon new execution (this one in particular has been addressed by the authors of the reactive Julia notebooks Pluto.jl).","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"For more details on code scoping we recommend particular places in the bachelor course lectures here and there.","category":"page"},{"location":"lecture_01/lab/#ErrorException-and-error-function","page":"Lab","title":"ErrorException & error function","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"ErrorException is the most generic error, which can be thrown/raised just by calling the error function with a chosen string message. As a result developers may be inclined to misuse this for any kind of unexpected behavior a user can run into, often providing out-of-context/uninformative messages.","category":"page"},{"location":"lecture_02/lab/#lab02","page":"Lab","title":"Lab 2: Predator-Prey Agents","text":"","category":"section"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"using Scientific_Programming_in_Julia\nusing Scientific_Programming_in_Julia.Ecosystem: eat!, find_food, count","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"In the next two labs you will implement your own, simplified, agent-based simulation of a predator-prey model.  The model will contain wolves, sheep, and - to feed your sheep - some grass.  Running and plotting your final result could look something like the plot below.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"(Image: img)","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"As you can see, in this model, the wolves unfortunately died out :(.","category":"page"},{"location":"lecture_02/lab/#Creating-the-world","page":"Lab","title":"Creating the world","text":"","category":"section"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"To get started we need a type hierarchy. In order to be able to extend this model in later labs we will create an AbstractAgent that acts as the root of our tree. All animals and plants will be subtypes of AbstractAgent (it is a good convention to start the name of an abstract type with Abstract...). There are different kinds of animals and plants so it makes sense to create an AbstractAnimal type which will be the supertype of all animals. The same is true for AbstractPlants:","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"abstract type AbstractAgent end\nabstract type AbstractAnimal <: AbstractAgent end\nabstract type AbstractPlant <: AbstractAgent end","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"The first concrete type we implement is the basis of life in our simulation and source of all energy: Grass. Our Grass will be growing over time and it will need a certain amount of time steps to fully grow before it can be eaten. This has to be reflected in the fields of our grass struct:","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"mutable struct Grass <: AbstractPlant\n    fully_grown::Bool\n    regrowth_time::Int\n    countdown::Int\nend\n# constructor for grass with random growth countdown\nGrass(t) = Grass(false, t, rand(1:t))","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Note that Grass is a subtype of AbstractPlant. Let us assume that all plants have at least the fields fully_grown, regrowth_time, and countdown, because all plants need some time to grow. If this is the case we can define a common interface for all AbstractPlants.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"# get field values\nfully_grown(a::AbstractPlant) = a.fully_grown\ncountdown(a::AbstractPlant) = a.countdown\n\n# set field values\n# (exclamation marks `!` indicate that the function is mutating its arguments)\nfully_grown!(a::AbstractPlant, b::Bool) = a.fully_grown = b\ncountdown!(a::AbstractPlant, c::Int) = a.countdown = c\nincr_countdown!(a::AbstractPlant, Δc::Int) = countdown!(a, countdown(a)+Δc)\n\n# reset plant couter once its grown\nreset!(a::AbstractPlant) = a.countdown = a.regrowth_time","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Grass cannot grow in a void, hence we need a World.  In our simple case this world will just be a container for all our agents.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Define a World struct that will hold all your AbstractAgents in a Vector called agents. Try to avoid fields with abstract types. Julia's compiler will not be able to infer the type for those (which leads to type instabilities and performance losses; see the composite types section in the lecture).","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"struct World{T<:AbstractAgent}\n    agents::Vector{T}\nend\n\n# if you want you can overload the `show` method to get custom printing of your World\nfunction Base.show(io::IO, w::World)\n    println(io, typeof(w))\n    map(a->println(io,\"  $a\"),w.agents)\nend","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Now you should be able to create a world some grass in it that will soon be eaten by sheep:","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"grass = Grass(5)\nworld = World([grass])","category":"page"},{"location":"lecture_02/lab/#Sheep-eat-grass","page":"Lab","title":"Sheep eat grass","text":"","category":"section"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Our simulated Sheep will have a certain amount of energy E, a reproduction probability p_r, and a probablity to find food p_f in each iteration of our simulation. Additionally, each sheep with get a certain amout of energy Delta E from eating a Grass. The corresponding struct then looks like this","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"mutable struct Sheep{T<:Real} <: AbstractAnimal\n    energy::T\n    Δenergy::T\n    reproduction_prob::T\n    food_prob::T\nend","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Again we will use Sheep as a generic example for an AbstractAnimal which leaves us with the interface below. We only have setters for energy because all other fields of our animals will stay constant.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"# get field values\nenergy(a::AbstractAnimal) = a.energy\nΔenergy(a::AbstractAnimal) = a.Δenergy\nreproduction_prob(a::AbstractAnimal) = a.reproduction_prob\nfood_prob(a::AbstractAnimal) = a.food_prob\n\n# set field values\nenergy!(a::AbstractAnimal, e) = a.energy = e\nincr_energy!(a::AbstractAnimal, Δe) = energy!(a, energy(a)+Δe)","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"In every iteration of the simulation each sheep will get a chance to eat some grass. The process of one animal eating a plant (or another animal) will be implemented via the eat!(a::AbstractAgent,b::AbstractAgent,::World) function. Calling the function will cause agent a to eat agent b, possibly mutating them and the world. The eat! function will do something different for different input types and is our first practical example of multiple dispatch. The eat! function is part of our interface and we will have to implement a special methods for each new type that we introduce.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Implement a function eat!(::Sheep, ::Grass, ::World) which increases the sheep's energy by Delta E and sets fully_grown of the grass to false.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"function eat!(sheep::Sheep, grass::Grass, w::World)\n    if fully_grown(grass)\n        fully_grown!(grass, false)\n        incr_energy!(sheep, Δenergy(sheep))\n    end\nend","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Below you can see how a fully grown grass is eaten by a sheep.  The sheep's energy changes and the fully_grown field of the grass becomes false.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"grass = Grass(true,5.0,5.0);\nsheep = Sheep(10.0,5.0,0.1,0.1);\nworld = World([grass, sheep])\neat!(sheep,grass,world);\nworld","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Note that the order of the arguments has a meaning here. Calling eat!(grass,sheep,world) results in a MethodError which is great, because Grass cannot eat Sheep.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"grass = Grass(true,5.0,5.0);     # hide\nsheep = Sheep(10.0,5.0,0.1,0.1); # hide\nworld = World([grass, sheep]);   # hide\neat!(grass,sheep,world);","category":"page"},{"location":"lecture_02/lab/#Wolves-eat-sheep","page":"Lab","title":"Wolves eat sheep","text":"","category":"section"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Next, implement a Wolf with the same properties as the sheep (E, Delta E, p_r, and p_f) as well as the correspoding eat! method which increases the wolf's energy and kills the sheep (i.e. removes the sheep from the world).","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Hint: You can use findall and deleteat! to remove agents from your world.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"mutable struct Wolf{T<:Real} <: AbstractAnimal\n    energy::T\n    Δenergy::T\n    reproduction_prob::T\n    food_prob::T\nend\n\nfunction eat!(wolf::Wolf, sheep::Sheep, w::World)\n    kill_agent!(sheep,w)\n    incr_energy!(wolf, Δenergy(wolf))\nend\n\nkill_agent!(a::AbstractAnimal, w::World) = deleteat!(w.agents, findall(x->x==a, w.agents))","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"With a correct eat! method you should get results like this:","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"grass = Grass(true,5.0,5.0);\nsheep = Sheep(10.0,5.0,0.1,0.1);\nwolf  = Wolf(20.0,10.0,0.1,0.1);\nworld = World([grass, sheep, wolf])\neat!(wolf,sheep,world);\nworld","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"The sheep is removed from the world and the wolf's energy increased by Delta E.","category":"page"},{"location":"lecture_02/lab/#Finding-food-for-sheep","page":"Lab","title":"Finding food for sheep","text":"","category":"section"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"The next mechanism in our simulation models an animal's search for food.  For example, a sheep can only try to eat if the world currently holds some grass. The process of finding food for a given animal will be implemented by the function find_food(a::AbstractAnimal, ::World). This function will either return nothing or another animal that can be eaten by a with the given food probability p_f.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Implement the method find_food(::Sheep, ::World) which returns either a Grass (sampled randomly from all Grasses with the given food probability p_f) or returns nothing.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Hint: You can use StatsBase.sample to choose a random element from a vector.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"function find_food(a::Sheep, w::World)\n    if rand() <= food_prob(a)\n        as = filter(x->isa(x,Grass), w.agents)\n        isempty(as) ? nothing : sample(as)\n    end\nend","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"To test your function your can create sheep with different p_f. A sheep with p_f=1 will always find some food if there is some in the world, so you should get a result like below.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"grass = Grass(true,5.0,5.0);\nsheep = Sheep(10.0,5.0,1.0,1.0);\nwolf  = Wolf(20.0,10.0,1.0,1.0);\nworld = World([grass, sheep, wolf]);\n\ndinner = find_food(sheep,world)\neat!(sheep,dinner,world);\nsheep","category":"page"},{"location":"lecture_02/lab/#Finding-food-for-wolves","page":"Lab","title":"Finding food for wolves","text":"","category":"section"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Implement a function find_food(::Wolf, ::World) which returns either a Sheep (with the given food probability p_f) or returns nothing.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"function find_food(a::Wolf, w::World)\n    if rand() <= food_prob(a)\n        as = filter(x->isa(x,Sheep), w.agents)\n        isempty(as) ? nothing : sample(as)\n    end\nend","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_02/lab/#General-food-finding","page":"Lab","title":"General food finding","text":"","category":"section"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Identify the code duplications between find_food(::Sheep,::World) and find_food(::Wolf,::World) and generalize the function to find_food(::AbstractAnimal, ::World)","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"function find_food(a::AbstractAnimal, w::World)\n    if rand() <= food_prob(a)\n        as = filter(x->eats(a,x), w.agents)\n        isempty(as) ? nothing : sample(as)\n    end\nend\n\neats(::Sheep,::Grass) = true\neats(::Wolf,::Sheep) = true\neats(::AbstractAgent,::AbstractAgent) = false","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_02/lab/#Eating-nothing","page":"Lab","title":"Eating nothing","text":"","category":"section"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"What happens if you call eat!(wolf, find_food(wolf,world), world) and there are no sheep anymore? Or if the wolf's p_f1?","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Write a simple for-loop that runs 7 iterations of a simple simulation that lets a wolf eat one sheep in each iteration with this given world:","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"sheep = [Sheep(10.0,5.0,1.0,1.0) for _ in 1:5]\nwolf  = Wolf(20.0,10.0,1.0,0.0)\nworld = World(vcat(sheep, [wolf]))","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Hint: You can try to overload the eat! function appropriately.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"# make sure any animal can also eat `nothing`\neat!(a::AbstractAnimal,b::Nothing,w::World) = nothing\n\nfor _ in 1:10\n    dinner = find_food(wolf,world)\n    eat!(wolf,dinner,world)\nend","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img class=\"docs-light-only\"; src=\"https://raw.githubusercontent.com/JuliaTeachingCTU/JuliaCTUGraphics/master/logo/Scientific-Programming-in-Julia-logo.svg\"; alt=\"Scientific Programming in Julia logo\"; max-width: 100%; height: auto>\n<img class=\"docs-dark-only\"; src=\"https://raw.githubusercontent.com/JuliaTeachingCTU/JuliaCTUGraphics/master/logo/Scientific-Programming-in-Julia-logo-dark.svg\"; alt=\"Scientific Programming in Julia logo\"; max-width: 100%; height: auto;>","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Plots\nENV[\"GKSwstype\"] = \"100\"\ngr()","category":"page"},{"location":"","page":"Home","title":"Home","text":"Scientific Programming requires the highest performance but we also want to write very high level code to enable rapid prototyping and avoid error prone, low level implementations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Julia programming language is designed with exactly those requirements of scientific computing in mind.  In this course we will show you how to make use of the tools and advantages that jit-compiled Julia provides over dynamic, high-level languages like Phython or lower level languages like C++.","category":"page"},{"location":"#What-will-you-learn?","page":"Home","title":"What will you learn?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"First and foremost you will learn how to think julia - meaning how write fast, extensible, reusable, and easy-to-read code using things like optional typing, multiple dispatch, and functional programming concepts.  The later part of the course will teach you how to use more advanced concepts like language introspection, metaprogramming, and symbolic computing. Amonst others you will implement your own automatic differetiation (the backbone of modern machine learning) package based on these advanced techniques that can transform intermediate representations of Julia code.","category":"page"},{"location":"#Organization","page":"Home","title":"Organization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The course webpage contains all information about the course that you need, including lecture notes, lab instructions, and homeworks. The official format of the course is 2+2 (2h lectures/2h labs per week) for 4 credits.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The course will be graded based on points from your homework (max. 20 points) and points from a final project (max. 30 points).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Below is a table that shows which lectures have homeworks (and their points).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Homework 1 2 3 4 5 6 7 8 9 10 11 12 13\nPoints 2 2 2 2 2 2 2 2 - 2 - 2 -","category":"page"},{"location":"","page":"Home","title":"Home","text":"Hint: The first few homeworks are easier. Use them to fill up your points.","category":"page"},{"location":"#final_project","page":"Home","title":"Final project","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The final project will be individually agreed on for each student. Ideally you can use this project to solve a problem you have e.g. in your thesis, but don't worry - if you cannot come up with an own project idea, we will suggest one to you.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The evaluation criteria of the final project are ...","category":"page"},{"location":"#Grading","page":"Home","title":"Grading","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Your points from the homeworks and the final project are summed and graded by the standard grading scale below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Grade A B C D E F\nPoints 45-50 40-44 35-39 30-34 25-29 <25","category":"page"},{"location":"#Teachers","page":"Home","title":"Teachers","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"– E-mail Room Role\nTomáš Pevný pevnytom@fel.cvut.cz KN:E-333 Lecturer\nVašek Šmídl smidlva1@fjfi.cvut.cz KN:E-333 Lecturer\nJan Franců jan.francu@fjfi.cvut.cz KN:E-333 Lab Instructor\nNiklas Heim heimnikl@fel.cvut.cz KN:E-333 Lab Instructor","category":"page"},{"location":"#Prerequisites","page":"Home","title":"Prerequisites","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are no hard requirements to take the course, but if you are not at all familiar with Julia we recommend to take Julia for Optimization and Learning before enrolling in this course.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Functional Programming course also contains some helpful concepts for this course.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Official documentation\nThink Julia: How to Think Like a Computer Scientist\nFrom Zero to Julia!\nWikiBooks","category":"page"}]
}
