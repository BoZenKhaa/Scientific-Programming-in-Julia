var documenterSearchIndex = {"docs":
[{"location":"lecture_03/lab/#Lab-3:-Predator-Prey-Agents","page":"Lab","title":"Lab 3: Predator-Prey Agents","text":"","category":"section"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"using Scientific_Programming_in_Julia\nusing Scientific_Programming_in_Julia.Ecosystem: eat!, find_food, count","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"In this lab we will finalize our predator-prey agent simulation such that we can simulate a number of steps in order to get a plot like below.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"(Image: img)","category":"page"},{"location":"lecture_03/lab/#Reproduction","page":"Lab","title":"Reproduction","text":"","category":"section"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"The only other thing that our animals are able to do apart from eating will be reproducing. Write a function reproduce! that take an AbstractAnimal and a World. Reproducing will cost an animal half of its energy and add an identical copy of the given animal to the world.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"function reproduce!(a::AbstractAnimal, w::World)\n    a.energy /= 2\n    push!(w.agents, deepcopy(a))\nend","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_03/lab/#One-step-at-a-time","page":"Lab","title":"One step at a time","text":"","category":"section"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"One iteration of our simulation will be carried out by a function called agent_step!(::AbstractAgent, ::World). Implement one method for AbstractPlants and one for AbstractAnimals.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"An AbstractPlant will grow if it is not fully grown (i.e. decrease growth counter).  If the growth counter has reached zero, the fully_grown flag has to be set to zero and the counter reset to regrowth_time.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"An AbstractAnimal will loose one unit of energy in every step.  Then it will try to find food and eat. After eating, if its energy is less than zero, the animal dies.  If it is still alive, it will try to reproduce with the probablitiy p_r.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"function agent_step!(a::AbstractPlant, w::World)\n    if !a.fully_grown\n        if a.countdown <= 0\n            a.fully_grown = true\n            a.countdown = a.regrowth_time\n        else\n            a.countdown -= 1\n        end\n    end\n    return a\nend\n\nfunction agent_step!(a::A, w::World) where A<:AbstractAnimal\n    a.energy -= 1\n    dinner = find_food(a,w)\n    eat!(a, dinner, w)\n    if a.energy < 0\n        kill_agent!(a,w)\n        return\n    end\n    if rand() <= a.reproduction_prob\n        reproduce!(a,w)\n    end\n    return a\nend","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_03/lab/#Simulate-the-world!","page":"Lab","title":"Simulate the world!","text":"","category":"section"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"The last function we need to run our simulation just needs to run a number of steps. In practice we often want varying logging behaviour which we can implement nicely using callbacks. Implement a function simulate!(w::World, iters::Int; callbacks=[]) which applies a number of callbacks of the form callback(::World) after each iteration.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"An exemplary callback could just log the agent count at ever step:","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"log_count(w::World) = @info agent_count(w)","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"function simulate!(w::World, iters::Int; callbacks=[])\n    for i in 1:iters\n        for a in w.agents\n            agent_step!(a,w)\n        end\n        for cb in callbacks\n            cb(w)\n        end\n    end\nend","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"Now lets try to run our first fully fledged simulation!  Below you can find some parameters that will often result in nice oscillations like in the plot at the beginning of the lab.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"n_grass       = 500\nregrowth_time = 17.0\n\nn_sheep         = 100\nΔenergy_sheep   = 5.0\nsheep_reproduce = 0.5\nsheep_foodprob  = 0.4\n\nn_wolves       = 8\nΔenergy_wolf   = 17.0\nwolf_reproduce = 0.03\nwolf_foodprob  = 0.02\n\ngs = [Grass(true,regrowth_time,regrowth_time) for _ in 1:n_grass]\nss = [Sheep(2*Δenergy_sheep,Δenergy_sheep,sheep_reproduce, sheep_foodprob) for _ in 1:n_sheep]\nws = [Wolf(2*Δenergy_wolf,Δenergy_wolf,wolf_reproduce, wolf_foodprob) for _ in 1:n_wolves]\n\nw = World(vcat(gs,ss,ws))\n\ncbs = [w->(@info agent_count(w))]\nsimulate!(w, 10, callbacks=cbs)","category":"page"},{"location":"lecture_03/lab/#Smarter-callbacks-through-closures","page":"Lab","title":"Smarter callbacks through closures","text":"","category":"section"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"Often we want our callbacks to be executed only every Nth step.  Implement a function every_nth(f::Function,n::Int) that takes a function and uses a closure to construct another function that only calls f every n calls to the function fn that is returned by every_nth(f,n).","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"Use every_nth to log the agent count every 5th step of your simulation and to save every second agent count.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"function every_nth(f::Function, n::Int)\n    i = 1\n    function callback(w::World)\n        # display(i) # comment this out to see how the counter increases\n        if i == n\n            f(w)\n            i = 1\n        else\n            i += 1\n        end\n    end\nend\n\n# construct a global variable to store the trajectories\ncounts = Dict(n=>[c] for (n,c) in agent_count(w))\n# callback to save current counts\nfunction _save(w::World)\n    for (n,c) in agent_count(w)\n        push!(counts[n],c)\n    end\nend\n\n# create callbacks\nlogcb = every_nth(w->(@info agent_count(w)), 5)\nsavecb = every_nth(_save, 2)\n\nsimulate!(w, 200, callbacks=[logcb, savecb])\n\n# you can now plot the trajectories like this\nusing Plots\nplt = plot()\nfor (n,c) in counts\n    plot!(plt, c, label=\"$n\", lw=2)\nend\ndisplay(plt)","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_03/lab/#Poisoned-Grass","page":"Lab","title":"Poisoned Grass","text":"","category":"section"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"In the previous exercises you have seen that multiple dispatch makes it easy to add new methods to a given type (much easier than in OOP!).  In this exercise you will see that it is just as easy to add a completely new type to our hierarchy and reuse the methods that we have already defined (similar to inheritance in OOP).","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"We have a few essential functions: agent_step!, reproduce!, find_food, eats, and eat!. If you look at their type signatures you can see that the first three already operate on any AbstractAnimal/AbstractPlant. This means that for any subtype that has the expected fields (energy, Δenergy, food_prob, and reproduction_prob) these functions already work.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"The only methods we have to implement for a new animal or plant are the eats and eat! methods.  So, lets implement a PoisonedGrass which will decrease the energy of a sheep that ate it.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"How much poisoned grass can you add to the simulation without wiping out the sheep population?","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"mutable struct PoisonedGrass <: AbstractPlant\n    fully_grown::Bool\n    regrowth_time::Int\n    countdown::Int\nend\nPoisonedGrass(t) = PoisonedGrass(false, t, rand(1:t))\n\nfunction eat!(sheep::Sheep, grass::PoisonedGrass, w::World)\n     if grass.fully_grown\n        grass.fully_grown = false\n        sheep.energy -= sheep.Δenergy\n    end\nend\n\neats(::Sheep,::PoisonedGrass) = true","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_02/lecture/#Motivation","page":"Lecture","title":"Motivation","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Before going into details about Julia type system, we spent few minutes motivating the two main role of type system, which is (i) structuring the code and (ii) and communicating to the compiler your intentions how the type will be used. While the first aspect is very important for the convenience of programmer and possible abstraction in the language, the latter aspect is very important for speed. ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"What Wikipedia tells about type and type system?","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"In computer science and computer programming, a data type or simply type is an attribute of data which tells the compiler or interpreter how the programmer intends to use the data (see (Image: wiki)). ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"A type system is a logical system comprising a set of rules that assigns a property called a type to the various constructs of a computer program, such as variables, expressions, functions or modules. These types formalize and enforce the otherwise implicit categories the programmer uses for algebraic data types, data structures, or other components (see (Image: wiki)).","category":"page"},{"location":"lecture_02/lecture/#Structuring-the-code","page":"Lecture","title":"Structuring the code","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"The main role is therefore aiding help to structure the code and impose semantic restriction. Consider for example two types with the same definition but different names.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"struct Dog\n\tname::String\nend\n\nstruct Cat\n\tname::String\nend","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"This allows us to define functions applicable only to the corresponding type","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"bark(dog::Dog) = println(dog.name, \" has barked.\")\nmeow(cat::Cat) = println(cat.name, \" have meowed.\")","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"and therefore the compiler (or interpretter) enforces that dog can only bark and never meow and vice versa can cat only meow. In this sense, it ensures that bark(cat) and meow(dog) never happen. Unlike if we define  those functions as ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"bark(dog::String) = println(dog.name, \" has barked.\")\nmeow(cat::String) = println(cat.name, \" have meowed.\")","category":"page"},{"location":"lecture_02/lecture/#Intention-of-use-and-restrictions-on-compilers","page":"Lecture","title":"Intention of use and restrictions on compilers","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"The intention of use in types is tightly related to how efficient code can compiler produce for that given intention. As an example, consider a following two variables a and b and function inc which increments the content by one and return the array.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"a = [1, 2, 3]\nb = (1, 2, 3)\ninc(x) = x .+ 1","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"The variable a is an array of Int64s, whereas b is a Tuple of Int64. Now if we look, how compiler compiles each version, you will see a striking difference","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"@code_native inc(a)\n@code_native inc(b)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"On my i5-8279U CPU, the difference is visible in performance","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"using BenchmarkTools\njulia> @btime inc($(a));\n  36.779 ns (1 allocation: 112 bytes)\n\njulia> @btime inc($(b));\n  0.036 ns (0 allocations: 0 bytes)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"(as will be seen later, the difference in speed comes mainly from the memory allocation).  For fun you can also test the speed of not type stable code","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"c = Vector{Number}([1, 2, 3])\njulia> @btime inc($(c));\n  865.304 ns (9 allocations: 464 bytes)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Does it mean that we should always use Tuples instead of Arrays? Surely not, it is just that each is better for different use-case. Arrays allows us for example to reuse space, which Tuples do not permit. For example","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"inc!(x) = x .= x .+ 1","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"will work for a but not for b, as Tuples are \"immutable\". This gives the compiler freedom to allocate (typically on Stack), while arrays are (at the time of writing) allocated strinctly on heap (needless to say that non-allocating version inc! of inc is much faster).","category":"page"},{"location":"lecture_02/lecture/#The-type-system","page":"Lecture","title":"The type system","text":"","category":"section"},{"location":"lecture_02/lecture/#Julia-is-dynamicaly-typed","page":"Lecture","title":"Julia is dynamicaly typed","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Julia's type system is dynamic, which means that all types are resolved during runtime. But, if the compiler can infer type of all variables of a function, it can specialize it leading to a very efficient code. Consider again the above example","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"a = [1,2,3]\nc = Vector{Number}([1,2,3])\ninc!(x) = x .= x .+ 1","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"where in case of calling inc(a), the compiler precisely knows types of items of a (all are Int64, which allow it to compile inc(a) for a vector if Integers. In case of c, the compiler does not know, what to expect, therefore he has to create a generic version of inc where for each item he has to decide the type. This way more complex leading to drop in performance","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"julia> @btime inc!($(a))\n  4.322 ns (0 allocations: 0 bytes)\njulia> @btime inc!($(c))\n  132.294 ns (6 allocations: 96 bytes)  ","category":"page"},{"location":"lecture_02/lecture/#Types-of-types","page":"Lecture","title":"Types of types","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Julia divides types into three classes.","category":"page"},{"location":"lecture_02/lecture/#Abstract-Type","page":"Lecture","title":"Abstract Type","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"((Image: Julia documentation)) Abstract types cannot be instantiated, which means that we cannot create a variable that would have an abstract type (try typeof(Number(1f0))). The most important use of abstract type is for structuring the code and defining general functions over semantically similar entities with different implementation. ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"An abstract type is define by preceding a definition of a type (declared using struct keyword) with a keyword abstract. For example following set of abstract types defines the part number system in julia.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"abstract type Number end\nabstract type Real     <: Number end\nabstract type AbstractFloat <: Real end\nabstract type Integer  <: Real end\nabstract type Signed   <: Integer end\nabstract type Unsigned <: Integer end","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"The <: means \"is a subtype of\" and it is used in declarations where the right-hand is an immediate sypertype of a given type (Integer has an immediate supertype Real.) The abstract type Number is derived from Any which is a default supertype of any type (this means all subtypes are derived from Any).  ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Recall the structure is used mainly for defining functions, that are known to provide a correct output on all subtypes of a given abstract type. Consider for example a sgn function, which can be defined as ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"sgn(x::Real) = x > 0 ? 1 : x < 0 ? -1 : 0\nsgn(x::Unsigned) = Int(x > 0)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"and where the first function is defined for any subtype of a real, where the latter is used for subtypes of Unsigned.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"!!! info \"Header\"\n\nHow does the julia decides which function to use when two possible function definitions are possible? For example `sgn(UInt8(0))` can call a definition `sgn(x::Real)` or a definition `sgn(x::Unsigned)`. The answer is that it chooses the most specific version, and therefore for `sgn(UInt8(0))` it takes `sgn(x::Unsinged)`. If the compiler cannot decide, it throws an error.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"A hierarchy of abstract types allows to define default implementation of some function over subtypes and specialize it for concrete types. A prime example is matrix multiplication, which has a generic implementation with many specializations for various types of matrices (sparse, dense, banded, etc.)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"All abstract types, except Any are defined by core libraries. This means that Julia does not make a difference between abstract types that are shipped with the language and those defined by the user. All are treated the same.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Abstract types can have parameters, for we have for example ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"abstract struct AbstractArray{T,N} end","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"which defines arrays of arbitrary dimentions with an element type T. Naturaly AbstractArray{Float32,2} is different from AbstractArray{Float64,2} and from AbstractArray{Real,2} (more on this later).","category":"page"},{"location":"lecture_02/lecture/#Primitive-types","page":"Lecture","title":"Primitive types","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Citing the (Image: documentation): A primitive type is a concrete type whose data consists of plain old bits. Classic examples of primitive types are integers and floating-point values. Unlike most languages, Julia lets you declare your own primitive types, rather than providing only a fixed set of built-in ones. In fact, the standard primitive types are all defined in the language itself:","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"primitive type Float16 <: AbstractFloat 16 end\nprimitive type Float32 <: AbstractFloat 32 end\nprimitive type Float64 <: AbstractFloat 64 end","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"We refer the reader to the original documentation, as we will not use them. They are mentioned to assure the reader that there is very little in Julia of what is not defined in it.","category":"page"},{"location":"lecture_02/lecture/#composite_types","page":"Lecture","title":"Composite types","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"The composite types are similar to struct in C (they even have the same memory layout). It is not a great idea to think about them as objects (in OOP sense), because objects tie together data and functions over the data. Contrary in Julia (and in C), the function operates over data, but are not tied to them. Composite types are a powerhorse of Julia's type system, as most user-defined types are composite.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"The composite type is defined as","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"struct Position\n  x::Float64\n  y::Float64\nend","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"which defines a structure with two fields x and y of type Float64. Julia compiler creates a default constructor, where both (but generally all) arguments are converted using (convert(Float64, x), convert(Float64, y) to the correct type. This means that we can construct a Position with numbers of different type that are convertable to Float, e.g. Position(1,1//2).","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Composite types do not have to have a specified type, e.g.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"struct VaguePosition\n  x \n  y \nend","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"which would work as the definition above and allows to store different values in x, for example String. But it would limit compiler's ability to specialize, which can have a negative impact on the performance. For example","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"using BenchmarkTools\nmove(a::T, b::T) where {T} = T(a.x + b.x, a.y + b.y)\nx = [Position(rand(), rand()) for _ in 1:100]\ny = [VaguePosition(rand(), rand()) for _ in 1:100]\njulia> @btime reduce(move, x);\n  114.105 ns (1 allocation: 32 bytes)\n\njulia> @btime reduce(move, y);\n  3.879 μs (199 allocations: 3.12 KiB)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"The same holds if the Composite type contains field with AbstractType, for example","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"struct LessVaguePosition\n  x::Real\n  y::Real \nend\nz = [LessVaguePosition(rand(), rand()) for _ in 1:100];\njulia> @btime reduce(move, z);\n  16.260 μs (496 allocations: 9.31 KiB)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"A recommended way to fix this is to parametrize the struct is to parametrize the type definition as follows","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"struct Position2{T}\n  x::T\n  y::T \nend\nu = [Position2(rand(), rand()) for _ in 1:100];\njulia> @btime reduce(move, u);\n  110.043 ns (1 allocation: 32 bytes)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"and notice that the compiler can take advantage of specializing for differenty types (which does not have effect as in modern processrs have addition of Float and Int takes the same time)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"v = [Position2(rand(1:100), rand(1:100)) for _ in 1:100];\n@btime reduce(move, v);\n  110.043 ns (1 allocation: 32 bytes)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"All structs defined above are immutable (as we have seen above in the case of Tuple), which means that one cannot change a field (unless the struct wraps a container, like and array, which allows that). For example this raises an error","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"a = Position(1, 2)\na.x = 2","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"If one needs to make a struct mutable, use the keyword mutable as follows","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"mutable struct MutablePosition{T}\n  x::T\n  y::T\n\nend\n\na = MutablePosition(1e0, 2e0)\na.x = 2","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"but there might be some performance penalty(not observable at this simple demo).","category":"page"},{"location":"lecture_02/lecture/#Type-hierarchy","page":"Lecture","title":"Type hierarchy","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Depending on the variance of the type constructor, the subtyping relation of the simple types may be either preserved, reversed, or ignored for the respective complex types. In the OCaml programming language, for example, \"list of Cat\" is a subtype of \"list of Animal\" because the list type constructor is covariant. This means that the subtyping relation of the simple types are preserved for the complex types. ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"On the other hand, \"function from Animal to String\" is a subtype of \"function from Cat to String\" because the function type constructor is contravariant in the parameter type. Here the subtyping relation of the simple types is reversed for the complex types. ","category":"page"},{"location":"lecture_02/lecture/#The-power-of-Type-System-\\-and-multiple-dispatch","page":"Lecture","title":"The power of Type System \\& multiple dispatch","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Zero cost abstraction the compiler has information about types and can freely inline x |> identity |> identity |> identity |> identity |> identity","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"julia> f(x) = x |> identity |> identity |> identity |> identity |> identity\n@code_lowered f(1)\n@code_lowered f(1)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Why the type system is important for efficiency\nBad practices \nLABS:\nNumber type-tree\nDesign Interval Aritmetics (for ODES)","category":"page"},{"location":"lecture_02/lecture/#VS-NOtes:","page":"Lecture","title":"VS NOtes:","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Basics:","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"type hierarchy\nsubtyping\nUnions","category":"page"},{"location":"lecture_02/lecture/#Pevnak's-idea","page":"Lecture","title":"Pevnak's idea","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Type hierarchy and rationale behind","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"* Why I cannot create an abstract struct with fields.\n* Why a type cannot subtype more than one types\n* How the type matching system works and what are the rules (Would take Jan Vitek's lecture or earlier) https://youtu.be/Y95fAipREHQ?t=958c","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"What types do in practice and how it matters?","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"* Allow to structure the program (example two types with the same memory layout (even empty) specializes methods)\n* Provides an information how to arrange variables in computer memory\n* Inform compiler how things can be stored (possibly on stack (bit types) vs strictly on heap (arrays))\n* Inform compiler about what is known (mutable vs non-mutable structs). Explain that when things are mutable, they have to be \"boxed\", meaning the variable is on stack and the structure contains pointer. \n* The effect of not strictly typed structs, where the type inference of objects is left to runtime","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Performance gotchas","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"- Why global is slow and how `const` comes to rescue","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Show the above with @codetyped, @codenative and @btime the effects, such that they can see that.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Stefans's C++ example of overloading https://discourse.julialang.org/t/claim-false-julia-isnt-multiple-dispatch-but-overloading/42370/16","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"_ Discussion about multiple inheritance https://github.com/JuliaLang/julia/issues/5","category":"page"},{"location":"lecture_02/lecture/#Examples","page":"Lecture","title":"Examples","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"why Vector{AbstractFloat} is a bad idea, while Vector{Float64} is a good one?\nwhy Vector{AbstractFloat} is different to Vector{<:AbstractFloat} or Vector{T} where {T<:AbstractFloat} ","category":"page"},{"location":"lecture_02/lecture/#Why-[1,2,3]-is-not-a-Vector{Number}","page":"Lecture","title":"Why [1,2,3] is not a Vector{Number}","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Vector{Number} is a concrete type, and [1, 2, 3] has type Vector{Int}, which is also a concrete type. One concrete type is never a subtype of another concrete type, they are the leaves of the type tree.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Vector{Number} is concrete, even though Number is not a concrete type. That’s because it has a concrete implementation which can store all types that are subtypes of Number, it has a specific memory layout etc. On the other hand, AbstractVector{Int} is the other way around and not a concrete type, because the container is abstract even though the element is concrete.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"What you can do instead is [1, 2, 3] isa Vector{<:Number} which is true. That’s because <:Number is a sort of placeholder which means “any type which is a subtype of Number”. This is often needed for dispatching on containers where you want to allow set of element types. f(x::Vector{Number}) can take only arguments of type Vector{Number}, whereas g(x::Vector{<:Number}) can take e.g. Vector{Int}, Vector{Float64}, Vector{Real}, Vector{Number}, etc.","category":"page"},{"location":"lecture_02/lecture/#Optional-stuff","page":"Lecture","title":"Optional stuff","text":"","category":"section"},{"location":"lecture_02/lecture/#Alignment-in-the-memory","page":"Lecture","title":"Alignment in the memory","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Super-importnat for speed, cache utilization\nKnow if you are row or column major \nVector{Vector{Float}} is a really bad idea over ","category":"page"},{"location":"lecture_02/lecture/#A-Headache-examples","page":"Lecture","title":"A Headache examples","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"This is a great example for type resolution.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"function Base.reduce(::typeof(hcat), xs::Vector{TV})  where {T, L, TV<:OneHotLike{T, L}}\n  OneHotMatrix(reduce(vcat, map(_indices, xs)), L)\nend","category":"page"},{"location":"lecture_02/lecture/#Turning-multiple-distpatch-to-single-dispatch","page":"Lecture","title":"Turning multiple-distpatch to single dispatch","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"https://stackoverflow.com/questions/39133424/how-to-create-a-single-dispatch-object-oriented-class-in-julia-that-behaves-l/39150509#39150509","category":"page"},{"location":"lecture_02/lecture/#conversion-among-variables","page":"Lecture","title":"conversion among variables","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"reinterpret(Float32, ref_sketch)","category":"page"},{"location":"lecture_02/lecture/#Trivia","page":"Lecture","title":"Trivia","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"why this is true Vector{Int} <: AbstractVector{<:Any} why this is false Vector{Int} <: Vector{Any} why this is true Vector{Int} <: Vector{<:Any}","category":"page"},{"location":"installation/#install","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"In order to participate in the course, everyone should install a recent version of Julia together with some text editor of choice. Furthermore during the course we will introduce some best practices of creating/testing and distributing your own Julia code, for which we will require a GitHub account.","category":"page"},{"location":"installation/#Julia-IDE","page":"Installation","title":"Julia IDE","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"As there does not exist any proper IDE for Julia yet, there is no one way to install/develop and run Julia. However following the bachelor course TODO LINK we will be using currently the most widely adopted way to code in Julia and that is in combination with VSCode editor. If you are still rocking Windows machine there is a great guide on getting such setup working on the bachelor course. TODO LINK or COPY When deciding which version to download we recommend the latest stable release as of August 2021, 1.6.x, which has some quality of life improvements mainly with regards to exception readability. This is however not a strict requirement and any text editor with the option to send code to the terminal, such as Sublime Text, Vim+tmux or Atom will suffice (a major convenience when dealing with programming languages that support interactivity through a Read-Eval-Print Loop - REPL).","category":"page"},{"location":"installation/#GitHub-registration-and-Git-setup","page":"Installation","title":"GitHub registration & Git setup","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"If you are familiar with git and GitHub, we recommend following the guide at TODO LINK or COPY to create your own GitHub account and install a git client.","category":"page"},{"location":"installation/#Advanced-setup-(not-required)","page":"Installation","title":"Advanced setup (not required)","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"More advanced users can experiment with the following setups on Windows and/or Linux/MacOS platforms. More specifically we believe that knowing how to run any language inside a Docker container helps to understand the problem of dependencies and reproducible code in more depth than with a simple local installation. Moreover given the convenience of remote development in VSCode both of the setups feel almost like a local installation.","category":"page"},{"location":"installation/#Julia-in-WSL","page":"Installation","title":"Julia in WSL","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"This setup is specific to Windows 10, which as of 2016 allows to run any Linux distribution almost natively on top of the Windows kernel.","category":"page"},{"location":"installation/#Julia-in-Docker","page":"Installation","title":"Julia in Docker","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Install Docker client\nSetup the permissions\nBuild a simple docker with Julia Hello world\nCaveats around such setup - GUI, dependencies, file system, running as root","category":"page"},{"location":"lecture_01/motivation/#Introduction-to-Scientific-Programming","page":"Motivation","title":"Introduction to Scientific Programming","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Loose def: a scientific programming language is designed and optimized for the use of mathematical formula and matrices wiki","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Examples of Scientific programming languages include ALGOL, APL, Fortran, J, Julia, Maple, MATLAB and R.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Key requirements:","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"fast execution of the code (complex algorithms)\nease of code reuse / restructuring \nreproducibility of the results","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Contrast to general-purpose language:","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"less concern with business models (library + header files)\nless concern with ABI \nless concern with public/private separation","category":"page"},{"location":"lecture_01/motivation/#TODO","page":"Motivation","title":"TODO","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Zero cost abstraction - Rackcaucas","category":"page"},{"location":"lecture_01/motivation/#Example","page":"Motivation","title":"Example","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"In many applications, we encounter the task of optimization a function given by a routine (e.g. engineering, finance, etc.)","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"using Optim\n\nP(x,y) = x^2 - 3x*y + 5y^2 - 7y + 3   # user defined function\n\nz₀ = [ 0.0\n       0.0 ]     # starting point for optimization algorithm\n\noptimize(z -> P(z...), z₀, Newton())\n#optimize(z -> P(z...), z₀, Newton();autodiff = :forward)\n#optimize(z -> P(z...), z₀, ConjugateGradient())\n","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Very simple for a user, very complicated for a programmer. The program should:","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"pick the right optimization method (easy by config-like approach)\ncompute gradient (Hessian) of a user function","category":"page"},{"location":"lecture_01/motivation/#Classical-thinking:-create-a-library,-call-it.","page":"Motivation","title":"Classical thinking: create a library, call it.","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Think of an experiment: main taking a configuration file. The configuration file can be simple: input file, what to do with it, output file.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"The more complicated experiments you want to do, the more complex your configuration file becomes. Sooner or later, you will create a new configuration language, or scripting language.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Ending up in 2 language problem. ","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Low-level programming = computer centric\nclose to the hardware\nallows excellent optimization for fast execution\nHigh-level programming = user centric\nexperimenting = running multiple configurations\nrunning code with many different parameters as easily as possible\nallowing high level of abstraction","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"In scientific programming, the most well known scipting languages are: Python,  Matlab, R","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"If you care about standard \"configurations\" they are just perfect. \nYou hit a problem with more complex experiments. ","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"The scripting language typically makes decisions (if) at runtime. Becomes slow.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"(Image: )","category":"page"},{"location":"lecture_01/motivation/#Other-approaches","page":"Motivation","title":"Other approaches","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Just in time compilation (HL -> LL)\nautomatic typing (auto in C++) (LL->HL)","category":"page"},{"location":"lecture_01/motivation/#Challenge","page":"Motivation","title":"Challenge","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Translate high-level thinking with as much abstraction as possible into fast machine code.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Indexing array x in Matlab:","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"y=x(4/2)\ny=x(5/2)","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"In the first case it works, in the second throws an error.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"function inde(x,n,m), x(n/m) can never be fast.","category":"page"},{"location":"lecture_01/motivation/#Julia-way","page":"Motivation","title":"Julia way","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"strong but flexible type system\nmultiple dispatch\nsingle language from high to low levels (as much as possible)\noptimize execution as much as you can during runtime\nfunctions are symbolic abstract layers\nabstraction should have zero computational cost","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"(Image: )","category":"page"},{"location":"lecture_01/motivation/#Example:","page":"Motivation","title":"Example:","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Function recursion with arbitrary number of arguments:","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"fsum(x) = x\nfsum(x,p...) = x+fsum(p[1],p[2:end]...)\n\nfsum(1,2,3)\n@code_llvm fsum(1,2,3)\n@code_llvm fsum(1.0,2.0,3.0)\nfz()=fsum(1,2,3)\n@code_llvm fz()","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"More involved example:","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"using Zygote\n\nf(x)=3x+1\n@code_llvm f'(10)","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Fuctions can act eiter as regular functions or like templates in C++.","category":"page"},{"location":"lecture_01/motivation/#Advantages-and-disadvantages","page":"Motivation","title":"Advantages and disadvantages","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"compilation of everything to \nvery fast code\nslow interaction (caching...)\ngenerating libraries is harder \nthink of fsum, \neverything is \".h\" file\ndebugging will be harder\nMultiple dispatch\nallows great extensibility and code composition\nnot (yet) mainstream thinking","category":"page"},{"location":"how_to_submit_hw/#homeworks","page":"How to submit homeworks","title":"Homework submission","text":"","category":"section"},{"location":"how_to_submit_hw/","page":"How to submit homeworks","title":"How to submit homeworks","text":"This document should describe the homework submission procedure.","category":"page"},{"location":"howto/#How-to-use-admonitions","page":"How To ...","title":"How to use admonitions","text":"","category":"section"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"Documenter.jl provides five special styles for admonitions and one style for custom admonition types","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"Admonition type html class\ninfo \"admonition is-info\"\ncompat \"admonition is-compat\"\ndange \"admonition is-danger\"\nwarning \"admonition is-warning\"\ntip \"admonition is-success\"\ncustom \"admonition is-category-custom\"","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"All these admonitions can be used in the following way","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"!!! tip \"Header\"\n    Text ...\n    ```@repl\n    a = 1\n    b = 2\n    a + b\n    ```","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"The resulting admonition looks as follows","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"tip: Header\nText ...a = 1\nb = 2\na + b","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"The problem is, that the evaluation of the block of code inside admonitions is not currently supported. To allow code evaluation inside admonitions, we can use two raw HTML blocks to wrap the admonition body. The syntax of the code between the HTML block is the same as everywhere else in the document.","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"```@raw html\n<div class=\"admonition is-success\">\n<header class=\"admonition-header\">Header</header>\n<div class=\"admonition-body\">\n```\n\nText ...\n\n```@repl\na = 1\nb = 2\na + b\n```\n\n```@raw html\n</div></div>\n```","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"The resulting admonition then looks as follows","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"<div class=\"admonition is-success\">\n<header class=\"admonition-header\">Header</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"Text ...","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"a = 1\nb = 2\na + b","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"</div></div>","category":"page"},{"location":"howto/#Additional-admonition-types","page":"How To ...","title":"Additional admonition types","text":"","category":"section"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"The css style downloaded in the make.jl provides three additional admonition types","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"Admonition type html class\ntheorem \"admonition is-category-theorem\"\nexercise \"admonition is-category-exercise\"\nhomework \"admonition is-category-homework\"","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"Currently, the first two types use the style of the default admonitions types. However, it may change in the future.","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"theorem: Theorem\nText...","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"exercise: Exercise\nText...","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"homework: Homework\nText...","category":"page"},{"location":"howto/#Exercise-with-solution","page":"How To ...","title":"Exercise with solution","text":"","category":"section"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"The used css style also provides style for collapsible admonition that can be used for example to define exercise with the hidden solution. To use this feature, we have to use raw HTML blocks.","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"```@raw html\n<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Header</header>\n<div class=\"admonition-body\">\n```\n\nSome text that describes the exercise\n\n```@raw html\n</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>\n```\n\nSolution\n\n```@raw html\n</p></details>\n```","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"The result is following","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Header</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"Some text that describes the exercise","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"Solution","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"</p></details>","category":"page"},{"location":"lecture_02/hw/#Homework-2:-Predator-Prey-Agents","page":"Homework","title":"Homework 2: Predator-Prey Agents","text":"","category":"section"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"using Scientific_Programming_in_Julia\nusing Scientific_Programming_in_Julia.Ecosystem: eat!, find_food, agent_count","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"In this homework we will continue working on our agent simulation.  All your code must be in a single file called Ecosystem.jl containing all the type definitions and functions we created in Lab 2 and the work you do in this homework. Zip this file and upload it to BRUTE to receive your points for the homework.","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"To monitor the different populations in our world we need a function that counts each type of agent. For AbstractAnimals we simply have to count how many of each type are currently in our World. In the case of AbstractPlants we only want to count the ones that are fully grown.","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"<div class=\"admonition is-category-homework\">\n<header class=\"admonition-header\">Homework (2 points)</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"Implement a function agent_count that can be called on a single AbstractAgent and returns either 0 or 1 (i.e. always 1 for animals; 1 for a fully grown plant and 0 otherwise).\nAdd a method for a vector of agents Vector{<:AbstractAgent}.\nAdd a method for a World which returns a dictionary that contains pairs of Symbols and the agent count like below:","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"grass1 = Grass(true,5.0,5.0);\ngrass2 = Grass(false,5.0,2.0);\nsheep = Sheep(10.0,5.0,1.0,1.0);\nwolf  = Wolf(20.0,10.0,1.0,1.0);\nworld = World([grass1, grass2, sheep, wolf]);\n\nagent_count(world)  # the grass that is not fully grown is not counted","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"Hint: You can get the name of a type by using the nameof function:","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"nameof(Grass)","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"Use as much dispatch as you can! ;)","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"# first solution using foldl instead of a for loop\nagent_count(g::AbstractPlant) = g.fully_grown ? 1 : 0\nagent_count(::AbstractAnimal) = 1\nagent_count(as::Vector{<:AbstractAgent}) = sum(agent_count,as)\n\nfunction agent_count(w::World)\n    function op(d::Dict,a::T) where T<:AbstractAgent\n        n = nameof(T)\n        if n in keys(d)\n            d[n] += agent_count(a)\n        else\n            d[n] = agent_count(a)\n        end\n        return d\n    end\n    foldl(op, w.agents, init=Dict{Symbol,Int}())\nend","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"# second solution with StastBase.countmap\ncountsym(g::T) where T<:AbstractPlant = g.fully_grown ? nameof(T) : :NoCount\ncountsym(::T) where T<:AbstractAnimal = nameof(T)\n\nfunction agent_count(w::World)\n    cs = StatsBase.countmap(countsym.(w.agents))\n    delete!(cs,:NoCount)\nend","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"</p></details>","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise (voluntary)</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"Using the world below, run a simple simulation with 7 iterations.  In each iteration the wolf has to find_food and eat!.  Plot trajectories of the agent count over time.","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"(Do not include this code in your submission to BRUTE)","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"grass = [Grass(true,5.0,5.0) for _ in 1:2];\nsheep = [Sheep(10.0,5.0,1.0,1.0) for _ in 1:5];\nwolf  = Wolf(20.0,10.0,1.0,1.0);\nworld = World(vcat([wolf], sheep, grass));","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"grass = [Grass(true,5.0,5.0) for _ in 1:2];\nsheep = [Sheep(10.0,5.0,1.0,1.0) for _ in 1:5];\nwolf  = Wolf(20.0,10.0,1.0,1.0);\nworld = World(vcat([wolf], sheep, grass));\n\nns = nameof.(unique(typeof.(world.agents)))\ncounts = Dict(n=>[] for n in ns);\nfor _ in 1:7\n    cs = agent_count(world)\n    eat!(wolf, find_food(wolf,world), world)\n    for (n,c) in cs\n        push!(counts[n], c)\n    end\nend\n\nusing Plots\nplt = plot();\nfor n in ns\n    plot!(plt, counts[n], label=\"$n\", lw=2, ylims=(0,5))\nend\nplt","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"</p></details>","category":"page"},{"location":"lecture_01/hw/#Homework-1","page":"Homework","title":"Homework 1","text":"","category":"section"},{"location":"lecture_01/hw/#Assignment-1-(2-points)","page":"Homework","title":"Assignment 1 (2 points)","text":"","category":"section"},{"location":"lecture_01/hw/#Assignment-2-(4-points)","page":"Homework","title":"Assignment 2 (4 points)","text":"","category":"section"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"...","category":"page"},{"location":"lecture_01/hw/#How-to-submit?","page":"Homework","title":"How to submit?","text":"","category":"section"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"The guide is located here","category":"page"},{"location":"lecture_02/example/#from-introduction","page":"-","title":"from introduction","text":"","category":"section"},{"location":"lecture_02/example/","page":"-","title":"-","text":"Recursive call","category":"page"},{"location":"lecture_02/example/","page":"-","title":"-","text":"fsum(x) = x\nfsum(x,p...) = x+fsum(p[1],p[2:end]...)","category":"page"},{"location":"lecture_02/example/","page":"-","title":"-","text":"Is a template how to behave:","category":"page"},{"location":"lecture_02/example/","page":"-","title":"-","text":"julia is a typed language: x, and p are of type Any\nwhat happens when calling:","category":"page"},{"location":"lecture_02/example/","page":"-","title":"-","text":"fsum(1,2,3)\nfsum(1,'c')\nfsum(1,\"c\")","category":"page"},{"location":"lecture_02/example/","page":"-","title":"-","text":"Show what \"+\" function do, ","category":"page"},{"location":"lecture_02/example/","page":"-","title":"-","text":"methods(+)","category":"page"},{"location":"lecture_02/example/","page":"-","title":"-","text":"what is multiple dispatch, how differnt it is from operator overloading. (Stefans example from lecture)","category":"page"},{"location":"lecture_02/example/#Show-error-message:","page":"-","title":"Show error message:","text":"","category":"section"},{"location":"lecture_02/example/","page":"-","title":"-","text":"explain why fsum(1,\"c\") failed.","category":"page"},{"location":"lecture_02/example/#Introduce-type-hierarchy","page":"-","title":"Introduce type hierarchy","text":"","category":"section"},{"location":"lecture_02/example/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"lecture_02/example/","page":"-","title":"-","text":"Define fsum(x::Number,p...) = x+fsum(p[1],p[2:end]...)\nShow how to extend to Arrays\nDefine fsum(x::AbstractArray,p...) = x+fsum(p[1],p[2:end]...)\nUnion","category":"page"},{"location":"lecture_01/outline/#Course-outline","page":"Outline","title":"Course outline","text":"","category":"section"},{"location":"lecture_01/outline/","page":"Outline","title":"Outline","text":"type system\nuser: tool for abstraction\ncompiler: tool for memory layout\ndesign patterns (mental setup)\njulia is a type-based language\ngeneralizes OOP and FP\nPackages\nway how to organize code\ncode reuse (alternative to libraries)\nexperiment reproducibility\n","category":"page"},{"location":"lecture_01/outline/#How-to-write-fast-code:","page":"Outline","title":"How to write fast code:","text":"","category":"section"},{"location":"lecture_01/outline/","page":"Outline","title":"Outline","text":"(Image: )","category":"page"},{"location":"lecture_01/outline/","page":"Outline","title":"Outline","text":"cache misses.","category":"page"},{"location":"lecture_01/outline/#Syntax","page":"Outline","title":"Syntax","text":"","category":"section"},{"location":"lecture_01/outline/","page":"Outline","title":"Outline","text":"Syntactic Sugar: Cheat sheet: https://cheatsheets.quantecon.org/","category":"page"},{"location":"lecture_01/outline/#Typing-Lecture-2","page":"Outline","title":"Typing -> Lecture 2","text":"","category":"section"},{"location":"lecture_01/outline/","page":"Outline","title":"Outline","text":"static\ndynamic","category":"page"},{"location":"lecture_01/outline/#","page":"Outline","title":"","text":"","category":"section"},{"location":"lecture_03/hw/#Homework-3","page":"Homework","title":"Homework 3","text":"","category":"section"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"Implement a gendered sheep that can only reproduce with another sheep of opposite gender.","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"The gendered sheep need an additonal field. As you cannot inherit from a concrete type in julia, you will have to forward the eats and eat! methods. In order to get the custom reproduction behaviour you have to overload the reproduce! function.","category":"page"},{"location":"lecture_01/lab/#Lab-01:-Introduction-to-Julia","page":"Lab","title":"Lab 01: Introduction to Julia","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"This lab should get everyone up to speed in the basics of Julia's installation, syntax and basic coding. For more detailed introduction you can check out Lectures 1-3 of the bachelor course.","category":"page"},{"location":"lecture_01/lab/#Testing-Julia-installation","page":"Lab","title":"Testing Julia installation","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"In order to proceed further let's run a simple script to see, that the setup described in chapter Installation is working properly. After spawning a terminal run this command:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"julia ./test_setup.jl","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The script does the following ","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"\"Tests\" if Julia is added to path and can be run with julia command from anywhere\nPrints Hello World and Julia version info\nCreates an environment configuration files\nInstalls a basic pkg called BenchmarkTools, which we will use for benchmarking a simple function later in the labs.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"There are some quality of life improvements over long term support versions of Julia and thus for the course of these lectures we will use the latest stable release of Julia 1.6.x.","category":"page"},{"location":"lecture_01/lab/#Polynomial-evaluation-example","page":"Lab","title":"Polynomial evaluation example","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Let's consider a common mathematical example for evaluation of nth-degree polynomial","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"f(x) = a_nx^n + a_n-1x^n-1 + dots + a_0x^0","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"where x in mathbbR and veca in mathbbR^n+1.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The simplest way of writing this is just realizing that essentially the function f is really implicitly containing argument veca, i.e. f equiv f(veca x), yielding the following function","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"function polynomial(a, x)\n    accumulator = 0\n    for i in length(a):-1:1\n        accumulator += x^(i-1) * a[i] # ! 1-based indexing for arrays\n    end\n    return accumulator\nend\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Evaluate the code of the function called polynomial in Julia REPL and evaluate the function itself with the following arguments.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"a = [-19, 7, -4, 6] # list coefficients a from a^0 to a^n\nx = 3               # point of evaluation\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The simplest way is to just copy&paste into an already running terminal manually. As opposed to the default Python REPL, Julia can deal with the blocks of code and different indentation much better without installation of an ipython-like REPL. There are ways to make this much easier in different text editors/IDEs:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"VSCode - when using Julia extension, by default Ctrl+Enter will spawn Julia REPL, when a .jl file is opened\nSublime Text - Send Code pkg (works well with Linux terminal or tmux, support for Windows is poor)\nVim - there is a Julia language plugin, which can be combine with vimcmdline","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Either way, you should see the following:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"function polynomial(a, x)\n    accumulator = 0\n    for i in length(a):-1:1\n        accumulator += x^(i-1) * a[i] # ! 1-based indexing for arrays\n    end\n    return accumulator\nend","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Similarly we enter the arguments of the function a and x:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"a = [-19, 7, -4, 6]\nx = 3","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Function call intuitively takes the name of the function with round brackets as arguments, i.e. works in the same way as majority of programming languages. The result is printed unless a ; is added at the end of the statement.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"polynomial(a, x)    # function call","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Thanks to the high level nature of Julia language it is often the case that examples written in pseudocode are almost directly rewritable into the language itself without major changes and the code can be thus interpreted easily.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"(Image: polynomial_explained)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The indentation is not necessary as opposed to other languages such as Python, due to the existence of the end keyword, however it is strongly recommended to use it, see style guide. Furthermore the return keyword can be omitted if the last line being evaluated contains the result, unless the line ends with ;.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Though there are libraries/IDEs that allow us to step through Julia code (Rebugger.jl link and VSCode link), we can (having defined the arguments with the same name as inside the actual function) evaluate pieces of code separately. ","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Evaluate the following pieces of code and check their type with typeof function, e.g. typeof(a) or typeof([-19, 7, -4, 6])","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"BONUS: Try to \"call for help\" by accessing the build in help terminal by typing ? followed by a keyword to explain. Use this for basic functions such as length, typeof, ^.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"a = [-19, 7, -4, 6]\nx = 3\naccumulator = 0\nlength(a):-1:1\n\ni = length(a)\naccumulator += x^(i-1) * a[i]\naccumulator\n\npolynomial\n^\n*","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"When defining a variable through an assignment we get the representation of the right side, again this is different from the default  behavior in Python, where the output of a = [-19, 7, -4, 6], prints nothing. In Julia REPL we get the result of the display function.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"julia> a = [-19, 7, -4, 6]\njulia> display(a) # should return the same thing as the line above","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"As you can see, the string that is being displayed contains information about the contents of a variable along with it's type in this case this is a Vector of Int types. Which can be checked further with the typeof function","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(a)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The other two assignments are exactly the same as they both generate an instance of Int type with different values. Though now one has to call for hell the typeof function, because by default this information is omitted in the display of simple types.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"x = 3\naccumulator = 0\ntypeof(x), typeof(accumulator)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The next expression creates an instance of a range, which are inclusive in Julia, i.e. containing number from start to end - in this case running from 4 to 1 with negative step -1, thus counting down.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"length(a):-1:1\ntypeof(length(a):-1:1)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Let's confirm the fact that the update operator += really does update the variable accumulator by running the following","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"i = length(a) # \naccumulator += x^(i-1) * a[i]\naccumulator","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Notice that evaluating a variable, which can be used instead of the return keyword at the end of a function.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"We have already seen the output of evaluating polynomial function name in the REPL By creating the function polynomial we have defined a variable polynomial, that from now on always refers to a function and cannot be redefined with a different type.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"polynomial","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"This is cause by the fact that each function defines essentially a new type, the same like Int ~ Int64 or Vector{Int}.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(polynomial)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"You can check that it is a subtype of the Function abstract type, with the subtyping operator <:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(polynomial) <: Function","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"These concepts will be expanded further in the type lecture, however for now note that this construction is quite useful for example if we wanted to create derivative rules for our function derivativeof(::typeof(polynomial), ...).","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Looking at the last two functions +, *","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"BONUS: Accessing help terminal ? and looking up a keyword, searches for documentation of individual methods/functions in the source code. When creating a pkg, it is desirable to create so called docstrings for each method that is going to be exported. docstrings are multiline strings written above a function. More on this in lecture on pkg development.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"\"\"\"\n    polynomial(a, x)\n\nReturns value of a polynomial with coefficients `a` at point `x`.\n\"\"\"\nfunction polynomial(a, x)\n    # function body\nend","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"As the arguments of the polynomial functions are untyped, i.e. they do not specify the allowed types like for example polynomial(a, x::Number) does, the following exercise explores how wide range of arguments does the","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"What happens if you call our polynomial function with with the following coefficients?","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"af = [-19.0, 7.0, -4.0, 6.0]\nat = (-19, 7, -4, 6)\nant = (a₀ = -19, a₁ = 7, a₂ = -4, a₃ = 6)\na2d = [-19 -4; 7 6]\nach = ['1', '2', '3', '4']\nac = [2i^2 + 1 for i in -2:1]\nag = (2i^2 + 1 for i in -2:1)\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Check first the types of each of these coefficients by calling typeof and eltype.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"BONUS: In the case of ag, use the collect function to get the desirable result. What does it do? Check again the type of the result.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"As opposed to the basic definition of a type the array is filled with Float64 types and the resulting value gets promoted as well to the Float64.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(at), eltype(at)\npolynomial(at, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"With round brackets over a fixed length vector we get the Tuple type, which is a fixed size, so called immutable \"array\" of a fixed size (its elements cannot be changed, unless initialized from scratch). Each element can be of a different type, but here we have only one and thus the Tuple is aliased into NTuple. There are some performance benefits for using immutable structure, which will be discussed later or even later.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(ant), eltype(ant)\npolynomial(ant, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Defining a 2D array is a simple change of syntax, which initialized a matrix row by row separated by ; with spaces between individual elements. The function works in the same way because linear indexing works in 2d arrays in column major fashion.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(a2d), eltype(a2d)\npolynomial(a2d, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Consider the vector/array of characters, which themselves have numeric values (you can check by converting them to Int Int('1') or convert(Int, 'l')). In spite of that, our untyped function cannot process such input, as there isn't an operation/method that would allow  multiplication of Char and Int type. Julia tries to promote the argument types to some common type, however checking the promote_type(Int, Char) returns Any (union of all types), which tells us that the conversion is not possible automatically.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(ach), eltype(ach)\npolynomial(ach, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"In the stacktrace we can see the location of each function call. If we include the function polynomial from some file poly.jl using include(\"poly.jl\"), we will see that the location changes from REPL[X]:10 to the the actual file name.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The next example shows so called array comprehension syntax, where we define and array of known length using and for loop iteration. Resulting array/vector has integer elements, however even mixed type is possible yielding Any, if there isn't any other common supertype to promote every entry into. (Use ? to look what promote and promote_type does.)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(ac), eltype(ac)\npolynomial(ac, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"By swapping square brackets for round we have defined so called generator/iterator, which as opposed to the previous example does not allocate an array, only the structure that produces it. You may notice that the element type in this case is Any, which means that a function using such generator as an argument cannot specialize based on the type and has to infer it every time an element is generated/returned. We will touch on how this affects performance in one of the later lectures.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(ag), eltype(ag)\npolynomial(ag, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"BONUS: In general generators may have unknown length which is useful, for example in batch processing of files, where we do not know beforehand how many files are in a folder. However the problem here originated from the problem of missing indexing operation getindex, which can be easily solved by collecting the generator with collect and thus transforming it into and array.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"agc = ag |> collect # pipe syntax, equivalent to collect(ag)\ntypeof(agc), eltype(agc)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"You can see now that eltype is no longer Any and a proper type for the whole container has been found in the collect function.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_01/lab/#How-to-use-code-from-other-people","page":"Lab","title":"How to use code from other people","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The script that we have run at the beginning of this lab has created a folder test with the following files.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"./test/\n    ├── Manifest.toml\n    ├── Project.toml\n    └── src\n        └── test.jl","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Every folder with a toml file called Project.toml, can be used by Julia's pkg manager into setting so called environment. Each of these environments has a specific name, unique identifier and most importantly a list of pkgs to be installed. Setting up or more often called activating an environment can be done either before starting Julia itself by running julia with the --project XXX flag or from withing the Julia REPL, by switching to Pkg mode with ] key (similar to the help mode activated by pressing ?).","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"So far we have used the general environment, which by default does not come with any 3rd party packages and includes only the base and standard libraries - already quite powerful on its own. ","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"In order to find which environment is currently active, run the following:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"] status","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"And the output of such command usually indicates the general environment located at .julia/ folder (${HOME}/.julia/ or ${APPDATA}/.julia/ in case of Unix/Windows based systems respectively)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"(@v1.6) pkg> status\nStatus `~/.julia/environments/v1.6/Project.toml` (empty project)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Generally one should avoid installing project specific pkg into general environment with the exception of some generic pkgs, which do not create much conflics such as PkgTemplates.jl, which is used for generating pkg templates/folder structure like the one above (link), more on this in the lecture on pkg development. ","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Activate the test environment inside ./test and check that the BenchmarkTools package has been installed. Use BenchmarkTools pkg's @btime to benchmark our polynomial function with the following arguments.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"aexp = ones(10) ./ factorial.(0:9)\nx = 1.1\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"In pkg mode use the command activate and status to check the presence. In order to import the functionality from other package, lookup the keyword using in the repl help mode ?. The functionality that we want to use is the @btime macro (it acts almost like a function but with a different syntax @macro arg1 arg2 arg3 ...). More on macros in the corresponding lecture.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"BONUS: Compare the output of polynomial(aexp, x) with the value of exp(x), which it approximates.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"There are other options to import a function/macro from a different package, however for now let's keep it simple with the using Module syntax, that brings to the REPL, all the variables/function/macros exported by the BenchmarkTools pkg. If @btime is exported, which it is, it can be accessed without specification i.e. just by calling @btime without the need for BenchmarkTools.@btime. More on the architecture of pkg/module loading in the package developement lecture.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"using BenchmarkTools\n@btime polynomial(aexp, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The output gives us the time of execution averaged over multiple runs (the number of samples is defined automatically based on run time) as well as the number of allocations and the output of the function, that is being benchmarked.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"BONUS: The difference between our approximation and the \"actual\" function value computed as a difference of the two. ","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"polynomial(aexp, x) - exp(x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The apostrophes in the previous sentece are on purpose, because implementation of exp also relies too on a finite sum, though much more sophisticated than the basic Taylor expansion.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_01/lab/#Useful-resources","page":"Lab","title":"Useful resources","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Getting Started tutorial from JuliaLang documentation - Docs\nConverting syntax between MATLAB ↔ Python ↔ Julia - Cheatsheet\nBachelor course for refreshing your knowledge - Course\nStylistic conventions - Style Guide\nReserved keywords - List","category":"page"},{"location":"lecture_02/lab/#lab02","page":"Lab","title":"Lab 2: Predator-Prey Agents","text":"","category":"section"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"using Scientific_Programming_in_Julia\nusing Scientific_Programming_in_Julia.Ecosystem: eat!, find_food, count","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"In the next two labs you will implement your own, simplified, agent-based simulation of a predator-prey model.  The model will contain wolves, sheep, and - to feed your sheep - some grass.  Running and plotting your final result could look something like the plot below.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"(Image: img)","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"As you can see, in this model, the wolves unfortunately died out :(.","category":"page"},{"location":"lecture_02/lab/#Creating-the-world","page":"Lab","title":"Creating the world","text":"","category":"section"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"To get started we need a type hierarchy. In order to be able to extend this model in later labs we will structure them like this","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"abstract type AbstractAgent end\nabstract type AbstractAnimal <: AbstractAgent end\nabstract type AbstractPlant <: AbstractAgent end","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Our Grass will be growing over time and it will need a certain amount of time steps to fully grow such that it can be eaten. This has to be reflected in the fields of our grass struct:","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"mutable struct Grass <: AbstractPlant\n    fully_grown::Bool\n    regrowth_time::Int\n    countdown::Int\nend\n# constructor for grass with random growth countdown\nGrass(t) = Grass(false, t, rand(1:t))","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Grass cannot grow in a void, hence we need a World.  In our simple case this world will be simply a container for all our agents.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Define a World struct that will hold all your AbstractAgents in a Vector. Try to avoid fields with abstract types. Julia's compiler will not be able to infer the type for those (which leads to type instabilities and performance losses; see the composite types section in the lecture).","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"struct World{T<:AbstractAgent}\n    agents::Vector{T}\nend\n\n# if you want you can overload the `show` method to get custom printing of your World\nfunction Base.show(io::IO, w::World)\n    println(io, typeof(w))\n    map(a->println(io,\"  $a\"),w.agents)\nend","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Now you should be able to create a world and grow some grass!","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"grass = Grass(5)\nworld = World([grass])","category":"page"},{"location":"lecture_02/lab/#Sheep-eat-grass","page":"Lab","title":"Sheep eat grass","text":"","category":"section"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Our simulated Sheep will have a certain amount of energy E, a reproduction probability p_r, and a probablity to find food p_f in each iteration of our simulation. Additionally, each sheep with get a certain amout of energy Delta E from eating a Grass. The corresponding struct then looks like this","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"mutable struct Sheep{T<:Real} <: AbstractAnimal\n    energy::T\n    Δenergy::T\n    reproduction_prob::T\n    food_prob::T\nend","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Implement a function eat!(::Sheep, ::Grass, ::World) which increases the sheep's energy by Delta E and sets fully_grown of the grass to false.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"function eat!(sheep::Sheep, grass::Grass, w::World)\n    if grass.fully_grown\n        grass.fully_grown = false\n        sheep.energy += sheep.Δenergy\n    end\nend","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Below you can see how a fully grown grass is eaten by a sheep.  The sheep's energy changes and the fully_grown field of the grass becomes false.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"grass = Grass(true,5.0,5.0);\nsheep = Sheep(10.0,5.0,0.1,0.1);\nworld = World([grass, sheep])\neat!(sheep,grass,world);\nworld","category":"page"},{"location":"lecture_02/lab/#Wolves-eat-sheep","page":"Lab","title":"Wolves eat sheep","text":"","category":"section"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Next, implement a Wolf with the same properties as the sheep (E, Delta E, p_r, and p_f) as well as the correspoding eat! method which increases the wolf's energy and kills the sheep (i.e. removes the sheep from the world).","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Hint: You can use findall and deleteat! to remove agents from your world.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"mutable struct Wolf{T<:Real} <: AbstractAnimal\n    energy::T\n    Δenergy::T\n    reproduction_prob::T\n    food_prob::T\nend\n\nfunction eat!(wolf::Wolf, sheep::Sheep, w::World)\n    kill_agent!(sheep,w)\n    wolf.energy += wolf.Δenergy\nend\n\nkill_agent!(a::AbstractAnimal, w::World) = deleteat!(w.agents, findall(x->x==a, w.agents))","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"With a correct eat! method you should get results like this:","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"grass = Grass(true,5.0,5.0);\nsheep = Sheep(10.0,5.0,0.1,0.1);\nwolf  = Wolf(20.0,10.0,0.1,0.1);\nworld = World([grass, sheep, wolf])\neat!(wolf,sheep,world);\nworld","category":"page"},{"location":"lecture_02/lab/#Finding-food-for-sheep","page":"Lab","title":"Finding food for sheep","text":"","category":"section"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Implement a function find_food(::Sheep, ::World) which returns either a Grass (sampled from all Grasses with the given food probability p_f) or returns nothing.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Hint: You can use StatsBase.sample to choose a random element from a vector.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"function find_food(a::Sheep, w::World)\n    if rand() <= a.food_prob\n        as = filter(x->isa(x,Grass), w.agents)\n        isempty(as) ? nothing : sample(as)\n    end\nend","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"A sheep with p_f=1 will always find some food if there is some in the world, so you should get a result like below.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"grass = Grass(true,5.0,5.0);\nsheep = Sheep(10.0,5.0,1.0,1.0);\nwolf  = Wolf(20.0,10.0,1.0,1.0);\nworld = World([grass, sheep, wolf]);\n\ndinner = find_food(sheep,world)\neat!(sheep,dinner,world);\nsheep","category":"page"},{"location":"lecture_02/lab/#Finding-food-for-wolves","page":"Lab","title":"Finding food for wolves","text":"","category":"section"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Implement a function find_food(::Wolf, ::World) which returns either a Sheep (with the given food probability p_f) or returns nothing.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"function find_food(a::Wolf, w::World)\n    if rand() <= a.food_prob\n        as = filter(x->isa(x,Sheep), w.agents)\n        isempty(as) ? nothing : sample(as)\n    end\nend","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_02/lab/#General-food-finding","page":"Lab","title":"General food finding","text":"","category":"section"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Identify the code duplications between find_food(::Sheep,::World) and find_food(::Wolf,::World) and generalize the function to find_food(::AbstractAnimal, ::World)","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"function find_food(a::T, w::World) where T<:AbstractAnimal\n    if rand() <= a.food_prob\n        as = filter(x->eats(a,x), w.agents)\n        isempty(as) ? nothing : sample(as)\n    end\nend\n\neats(::Sheep,::Grass) = true\neats(::Wolf,::Sheep) = true\neats(::AbstractAgent,::AbstractAgent) = false","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_02/lab/#Eating-nothing","page":"Lab","title":"Eating nothing","text":"","category":"section"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"What happens if you call eat!(wolf, find_food(wolf,world), world) and there are no sheep anymore? Or if the wolf's p_f1?","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Write a simple for loop that runs 7 iterations of a simple simulation that lets a wolf eat one sheep in each iteration with this given world:","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"sheep = [Sheep(10.0,5.0,1.0,1.0) for _ in 1:5]\nwolf  = Wolf(20.0,10.0,1.0,0.0)\nworld = World(vcat(sheep, [wolf]))","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Hint: You can try to overload the eat! function appropriately.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"# make sure any animal can also eat `nothing`\neat!(a::AbstractAnimal,b::Nothing,w::World) = nothing\n\nfor _ in 1:10\n    dinner = find_food(wolf,world)\n    eat!(wolf,dinner,world)\nend","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img class=\"docs-light-only\"; src=\"https://raw.githubusercontent.com/JuliaTeachingCTU/JuliaCTUGraphics/master/logo/Scientific-Programming-in-Julia-logo.svg\"; alt=\"Scientific Programming in Julia logo\"; max-width: 100%; height: auto>\n<img class=\"docs-dark-only\"; src=\"https://raw.githubusercontent.com/JuliaTeachingCTU/JuliaCTUGraphics/master/logo/Scientific-Programming-in-Julia-logo-dark.svg\"; alt=\"Scientific Programming in Julia logo\"; max-width: 100%; height: auto;>","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Plots\nENV[\"GKSwstype\"] = \"100\"\ngr()","category":"page"},{"location":"","page":"Home","title":"Home","text":"Welcome to our course Scientific Programming in Julia.","category":"page"},{"location":"#Information-about-the-course","page":"Home","title":"Information about the course","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Teachers: Tomáš Pevný and Vašek Šmídl\nLabs: Niklas Heim and Jan Franců\nCredits: 4\nFormat: 2+2\nEnrollment: search code XXX in KOS\nRequirements for the course:\nHomeworks (after every lab)\nFinal project on a topic agreed with the lecturers\nGrading: 60% final project defended at exam and 40% homework \nLocation: TBD","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some homeworks are harder than others, so each of them is rewarded with a different amount of points:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Homework 1 2 3 4 5 6 7 8 9 10 11 12 13\nPoints - 2 - - - - - - - - - - -","category":"page"},{"location":"#What-will-we-emphasize?-/-What-will-you-learn?","page":"Home","title":"What will we emphasize? / What will you learn?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The main goals of the course are the following: (make it longer? Split into two.)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Think in Julia.\nWrite extensible and reusable code.\nDig deeper into your code with debugging and introspection\nAutomatic Differentiation (AD) from scratch - the backbone of modern machine learning.\nExperience the power of code composability with Neural Ordinary Differential Equations - NeuralODEs.","category":"page"},{"location":"#Recommended-courses","page":"Home","title":"Recommended courses","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia for Optimization and Learning - bachelor course on Julia, which we recommend for beginners before enrolling to this course\nFunctional Programming - TODO fill in the url","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Official documentation\nThink Julia: How to Think Like a Computer Scientist\nFrom Zero to Julia!\nWikiBooks","category":"page"}]
}
