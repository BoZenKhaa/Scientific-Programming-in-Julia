var documenterSearchIndex = {"docs":
[{"location":"lecture_03/lab/#Lab-3:-Predator-Prey-Agents","page":"Lab","title":"Lab 3: Predator-Prey Agents","text":"","category":"section"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"using Scientific_Programming_in_Julia\nusing Scientific_Programming_in_Julia.Ecosystem: eat!, find_food, count","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"In this lab we will finalize our predator-prey agent simulation such that we can simulate a number of steps in order to get a plot like below.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"(Image: img)","category":"page"},{"location":"lecture_03/lab/#Reproduction","page":"Lab","title":"Reproduction","text":"","category":"section"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"The only other thing that our animals are able to do apart from eating will be reproducing. Write a function reproduce! that take an AbstractAnimal and a World. Reproducing will cost an animal half of its energy and add an identical copy of the given animal to the world.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"function reproduce!(a::AbstractAnimal, w::World)\n    a.energy /= 2\n    push!(w.agents, deepcopy(a))\nend","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_03/lab/#One-step-at-a-time","page":"Lab","title":"One step at a time","text":"","category":"section"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"One iteration of our simulation will be carried out by a function called agent_step!(::AbstractAgent, ::World). Implement one method for AbstractPlants and one for AbstractAnimals.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"An AbstractPlant will grow if it is not fully grown (i.e. decrease growth counter).  If the growth counter has reached zero, the fully_grown flag has to be set to zero and the counter reset to regrowth_time.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"An AbstractAnimal will loose one unit of energy in every step.  Then it will try to find food and eat. After eating, if its energy is less than zero, the animal dies.  If it is still alive, it will try to reproduce with the probablitiy p_r.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"function agent_step!(a::AbstractPlant, w::World)\n    if !a.fully_grown\n        if a.countdown <= 0\n            a.fully_grown = true\n            a.countdown = a.regrowth_time\n        else\n            a.countdown -= 1\n        end\n    end\n    return a\nend\n\nfunction agent_step!(a::A, w::World) where A<:AbstractAnimal\n    a.energy -= 1\n    dinner = find_food(a,w)\n    eat!(a, dinner, w)\n    if a.energy < 0\n        kill_agent!(a,w)\n        return\n    end\n    if rand() <= a.reproduction_prob\n        reproduce!(a,w)\n    end\n    return a\nend","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_03/lab/#Simulate-the-world!","page":"Lab","title":"Simulate the world!","text":"","category":"section"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"The last function we need to run our simulation just needs to run a number of steps. In practice we often want varying logging behaviour which we can implement nicely using callbacks. Implement a function simulate!(w::World, iters::Int; callbacks=[]) which applies a number of callbacks of the form callback(::World) after each iteration.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"An exemplary callback could just log the agent count at ever step:","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"log_count(w::World) = @info agent_count(w)","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"function simulate!(w::World, iters::Int; callbacks=[])\n    for i in 1:iters\n        for a in w.agents\n            agent_step!(a,w)\n        end\n        for cb in callbacks\n            cb(w)\n        end\n    end\nend","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"Now lets try to run our first fully fledged simulation!  Below you can find some parameters that will often result in nice oscillations like in the plot at the beginning of the lab.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"n_grass       = 500\nregrowth_time = 17.0\n\nn_sheep         = 100\nΔenergy_sheep   = 5.0\nsheep_reproduce = 0.5\nsheep_foodprob  = 0.4\n\nn_wolves       = 8\nΔenergy_wolf   = 17.0\nwolf_reproduce = 0.03\nwolf_foodprob  = 0.02\n\ngs = [Grass(true,regrowth_time,regrowth_time) for _ in 1:n_grass]\nss = [Sheep(2*Δenergy_sheep,Δenergy_sheep,sheep_reproduce, sheep_foodprob) for _ in 1:n_sheep]\nws = [Wolf(2*Δenergy_wolf,Δenergy_wolf,wolf_reproduce, wolf_foodprob) for _ in 1:n_wolves]\n\nw = World(vcat(gs,ss,ws))\n\ncbs = [w->(@info agent_count(w))]\nsimulate!(w, 10, callbacks=cbs)","category":"page"},{"location":"lecture_03/lab/#Smarter-callbacks-through-closures","page":"Lab","title":"Smarter callbacks through closures","text":"","category":"section"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"Often we want our callbacks to be executed only every Nth step.  Implement a function every_nth(f::Function,n::Int) that takes a function and uses a closure to construct another function that only calls f every n calls to the function fn that is returned by every_nth(f,n).","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"Use every_nth to log the agent count every 5th step of your simulation and to save every second agent count.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"function every_nth(f::Function, n::Int)\n    i = 1\n    function callback(w::World)\n        # display(i) # comment this out to see how the counter increases\n        if i == n\n            f(w)\n            i = 1\n        else\n            i += 1\n        end\n    end\nend\n\n# construct a global variable to store the trajectories\ncounts = Dict(n=>[c] for (n,c) in agent_count(w))\n# callback to save current counts\nfunction _save(w::World)\n    for (n,c) in agent_count(w)\n        push!(counts[n],c)\n    end\nend\n\n# create callbacks\nlogcb = every_nth(w->(@info agent_count(w)), 5)\nsavecb = every_nth(_save, 2)\n\nsimulate!(w, 200, callbacks=[logcb, savecb])\n\n# you can now plot the trajectories like this\nusing Plots\nplt = plot()\nfor (n,c) in counts\n    plot!(plt, c, label=\"$n\", lw=2)\nend\ndisplay(plt)","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_03/lab/#Poisoned-Grass","page":"Lab","title":"Poisoned Grass","text":"","category":"section"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"In the previous exercises you have seen that multiple dispatch makes it easy to add new methods to a given type (much easier than in OOP!).  In this exercise you will see that it is just as easy to add a completely new type to our hierarchy and reuse the methods that we have already defined (similar to inheritance in OOP).","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"We have a few essential functions: agent_step!, reproduce!, find_food, eats, and eat!. If you look at their type signatures you can see that the first three already operate on any AbstractAnimal/AbstractPlant. This means that for any subtype that has the expected fields (energy, Δenergy, food_prob, and reproduction_prob) these functions already work.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"The only methods we have to implement for a new animal or plant are the eats and eat! methods.  So, lets implement a PoisonedGrass which will decrease the energy of a sheep that ate it.","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"How much poisoned grass can you add to the simulation without wiping out the sheep population?","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"mutable struct PoisonedGrass <: AbstractPlant\n    fully_grown::Bool\n    regrowth_time::Int\n    countdown::Int\nend\nPoisonedGrass(t) = PoisonedGrass(false, t, rand(1:t))\n\nfunction eat!(sheep::Sheep, grass::PoisonedGrass, w::World)\n     if grass.fully_grown\n        grass.fully_grown = false\n        sheep.energy -= sheep.Δenergy\n    end\nend\n\neats(::Sheep,::PoisonedGrass) = true","category":"page"},{"location":"lecture_03/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_02/lecture/#Motivation","page":"Lecture","title":"Motivation","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Before going into details about Julia type system, we spent few minutes motivating the two main role of type system, which is (i) structuring the code and (ii) and communicating to the compiler your intentions how the type will be used. While the first aspect is very important for the convenience of programmer and possible abstraction in the language, the latter aspect is very important for speed. ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"What Wikipedia tells about type and type system?","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"In computer science and computer programming, a data type or simply type is an attribute of data which tells the compiler or interpreter how the programmer intends to use the data (see (Image: wiki)). ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"A type system is a logical system comprising a set of rules that assigns a property called a type to the various constructs of a computer program, such as variables, expressions, functions or modules. These types formalize and enforce the otherwise implicit categories the programmer uses for algebraic data types, data structures, or other components (see (Image: wiki)).","category":"page"},{"location":"lecture_02/lecture/#Structuring-the-code","page":"Lecture","title":"Structuring the code","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"The main role is therefore aiding help to structure the code and impose semantic restriction. Consider for example two types with the same definition but different names.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"struct Wolf\n\tname::String\n  energy::Int\nend\n\nstruct Sheep\n\tname::String\n  energy::Int\nend","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"This allows us to define functions applicable only to the corresponding type","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"howl(wolf::Wolf) = println(wolf.name, \" has howled.\")\nbaa(sheep::Sheep) = println(sheep.name, \" has baaed.\")","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"and therefore the compiler (or interpretter) enforces that wolf can only howl and never baa and vice versa sheep can only baa. In this sense, it ensures that howl(sheep) and baa(wolf) never happen. Unlike if we define  those functions as ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"bark(animal) = println(animal.name, \" has howled.\")\nbaa(animal)  = println(animal.name, \" has baaed.\")","category":"page"},{"location":"lecture_02/lecture/#Intention-of-use-and-restrictions-on-compilers","page":"Lecture","title":"Intention of use and restrictions on compilers","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"The intention of use in types is related to how efficient code can compiler produce for that given intention. As an example, consider a following two alternatives to represent a set of animals:","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"a = [Wolf(\"1\", 1), Wolf(\"2\", 2), Sheep(\"3\", 3)]\nb = (Wolf(\"1\", 1), Wolf(\"2\", 2), Sheep(\"3\", 3))","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"and define a function to sum energy of all animals as ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"energy(animals) = mapreduce(x -> x.energy, +, animals)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Inspecting the compiled code using ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"@code_native energy(a)\n@code_native energy(b)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"one observes the second version produces more optimal code. Why is that?","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"In the first representation, a, animals are stored in Array which can have arbitrary size and can contain arbitrary animals. This means that compiler has to compile energy(a) such that it works on such arrays.\nIn the second representation, b, animals are stored in Tuple, which specializes for lengths and types of items. This means that the compiler knows the number of animals and the type of each animal on each position within the tuple, which allows him to specialize.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"This difference will be indeed measurable On my i5-8279U CPU, the difference is visible in performance","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"using BenchmarkTools\njulia> @btime energy(a);\n  86.944 ns (0 allocations: 0 bytes)\n\njulia> @btime energy(b);\n  16.206 ns (0 allocations: 0 bytes)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Which nicely demonstrates that smart choice of types can greatly affect the performance.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Does it mean that we should always use Tuples instead of Arrays? Surely not, it is just that each is better for different use-case. Using Tuples means that compiler will compile special function for each tuple it observes, which is clearly wasteful.","category":"page"},{"location":"lecture_02/lecture/#The-type-system","page":"Lecture","title":"The type system","text":"","category":"section"},{"location":"lecture_02/lecture/#Julia-is-dynamicaly-typed","page":"Lecture","title":"Julia is dynamicaly typed","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Julia's type system is dynamic, which means that all types are resolved during runtime. But, if the compiler can infer type of all variables of a function, it can specialize it leading to a very efficient code. Consider a slightly modified example where we represent two wolfpacks:","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"wolfpack_a =  [Wolf(\"1\", 1), Wolf(\"2\", 2), Wolf(\"3\", 3)]\nwolfpack_b =  Any[Wolf(\"1\", 1), Wolf(\"2\", 2), Wolf(\"3\", 3)]","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"wolfpack_a carries a type Vector{Wolf} while wolfpack_b has a type Vector{Any}. This means that in the first case, the compiler know that all items are of the type Wolf and it can specialize functions using this information. In case of wolfpack_b, he does not know which animal he will encounter (although all are of the same type), and therefore it needs to dynamically resolve the type of each item upon its use. This ultimately leads to less performant code.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"julia> @btime energy(wolfpack_a)\n  15.498 ns (0 allocations: 0 bytes)\njulia> @btime energy(wolfpack_b)\n  91.152 ns (0 allocations: 0 bytes)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"To conclude, julia is indeed dynamically typed language, but if the compiler can infer all types in called function in advance, it does not have to perform a type resolution during execution, which produces a performant code.","category":"page"},{"location":"lecture_02/lecture/#Types-of-types","page":"Lecture","title":"Types of types","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Julia divides types into three classes: primitive, composite, and abstract.","category":"page"},{"location":"lecture_02/lecture/#Primitive-types","page":"Lecture","title":"Primitive types","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Citing the (Image: documentation): A primitive type is a concrete type whose data consists of plain old bits. Classic examples of primitive types are integers and floating-point values. Unlike most languages, Julia lets you declare your own primitive types, rather than providing only a fixed set of built-in ones. In fact, the standard primitive types are all defined in the language itself:","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"The definition of primitive types look as follows","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"primitive type Float16 <: AbstractFloat 16 end\nprimitive type Float32 <: AbstractFloat 32 end\nprimitive type Float64 <: AbstractFloat 64 end","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"and they are mainly used to jump-start julia's type system. It rarely make a sense to define a special primitive type, as it make sense only if you define special functions operating on its bits, which makes mostly sense if you want to expose special operations provided by underlying CPU / LLVM compiler. For example + for Int32 is different from + for Float32 as they call a different intrinsic operation. You can inspect this jump-starting of type system by yourself by inspecting Julia's source.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"julia> @which +(1,2)\n+(x::T, y::T) where T<:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8} in Base at int.jl:87","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"At int.jl:87 ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"(+)(x::T, y::T) where {T<:BitInteger} = add_int(x, y)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"we seen that + of integers is calling function add_int(x, y), which is defined in a core part of the compiler in Intrinsics.cpp (yes, in C++).","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"From Julia docs: Core is the module that contains all identifiers considered \"built in\" to the language, i.e. part of the core language and not libraries. Every module implicitly specifies using Core, since you can't do anything without those definitions.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Primitive types are rarely used, and they will not be used in this course. We touch them for the sake of completness and refer reader to the official Documentation (and source code of Julia).","category":"page"},{"location":"lecture_02/lecture/#composite_types","page":"Lecture","title":"Composite types","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"The composite types are similar to struct in C (they even have the same memory layout). It is not a great idea to think about them as objects (in OOP sense), because objects tie together data and functions over owned data. Contrary in Julia (as in C), the function operates over data, but are not tied to them. Composite types are a workhorses of Julia's type system, as most user-defined types are composite.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"The composite type is defined as","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"struct Position\n  x::Float64\n  y::Float64\nend","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"which defines a structure with two fields x and y of type Float64. Julia compiler creates a default constructor, where both (but generally all) arguments are converted using (convert(Float64, x), convert(Float64, y) to the correct type. This means that we can construct a Position with numbers of different type that are convertable to Float, e.g. Position(1,1//2).","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Composite types do not have to have a specified type, e.g.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"struct VaguePosition\n  x \n  y \nend","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"which would work as the definition above and allows to store different values in x, for example String. But it would limit compiler's ability to specialize, which can have a negative impact on the performance. For example","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"using BenchmarkTools\nmove(a::T, b::T) where {T} = T(a.x + b.x, a.y + b.y)\nx = [Position(rand(), rand()) for _ in 1:100]\ny = [VaguePosition(rand(), rand()) for _ in 1:100]\njulia> @btime reduce(move, x);\n  114.105 ns (1 allocation: 32 bytes)\n\njulia> @btime reduce(move, y);\n  3.879 μs (199 allocations: 3.12 KiB)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"The same holds if the Composite type contains field with AbstractType, for example","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"struct LessVaguePosition\n  x::Real\n  y::Real \nend\nz = [LessVaguePosition(rand(), rand()) for _ in 1:100];\njulia> @btime reduce(move, z);\n  16.260 μs (496 allocations: 9.31 KiB)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"A recommended way to fix this is to parametrize the struct is to parametrize the type definition as follows","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"struct Position2{T}\n  x::T\n  y::T \nend\nu = [Position2(rand(), rand()) for _ in 1:100];\njulia> @btime reduce(move, u);\n  110.043 ns (1 allocation: 32 bytes)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"and notice that the compiler can take advantage of specializing for differenty types (which does not have effect as in modern processrs have addition of Float and Int takes the same time)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"v = [Position2(rand(1:100), rand(1:100)) for _ in 1:100];\n@btime reduce(move, v);\n  110.043 ns (1 allocation: 32 bytes)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"All structs defined above are immutable (as we have seen above in the case of Tuple), which means that one cannot change a field (unless the struct wraps a container, like and array, which allows that). For example this raises an error","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"a = Position(1, 2)\na.x = 2","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"If one needs to make a struct mutable, use the keyword mutable as follows","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"mutable struct MutablePosition{T}\n  x::T\n  y::T\n\nend\n\na = MutablePosition(1e0, 2e0)\na.x = 2","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"but there might be some performance penalty(not observable at this simple demo).","category":"page"},{"location":"lecture_02/lecture/#Abstract-Type","page":"Lecture","title":"Abstract Type","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"((Image: Julia documentation)) Abstract types cannot be instantiated, which means that we cannot create a variable that would have an abstract type (try typeof(Number(1f0))). Also, Abstract types cannot have any fields (therefore there is no composition). The most important use of abstract type is for structuring the code and defining general functions over semantically similar entities with different implementation. ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"An abstract types are defined by preceding a definition of a type (declared using struct keyword) with a keyword abstract. For example following set of abstract types defines part of julia's number systems.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"abstract type Number end\nabstract type Real     <: Number end\nabstract type AbstractFloat <: Real end\nabstract type Integer  <: Real end\nabstract type Signed   <: Integer end\nabstract type Unsigned <: Integer end","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"The <: means \"is a subtype of\" and it is used in declarations where the right-hand is an immediate sypertype of a given type (Integer has an immediate supertype Real.) The abstract type Number is derived from Any which is a default supertype of any type (this means all subtypes are derived from Any).  ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"The type hiearchy is used for defining general functions, that are known to provide a correct output on all subtypes of a given abstract type. For example a sgn function can be defined for all real numbers as ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"sgn(x::Real) = x > 0 ? 1 : x < 0 ? -1 : 0","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"and we know it would be correct for all real numbers. This means that if anyone creates a new subtype of Real, the above function can be used.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"For unsigned numbers, the sgn can be simplified, as it is sufficient to verify if they are different (greated) then zeros, therefore the function can read","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"sgn(x::Unsigned) = Int(x > 0)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"and again, it applies to all numbers derived from Unsigned. Recall that Unsigned <: Integer <: Real, how does Julia decides, which version of the function sgn to use for UInt8(0)? It chooses the most specific version, and therefore for sgn(UInt8(0)) it will use sgn(x::Unsinged). If the compiler cannot decide, typically it encounters an ambiguity, it throws an error and recommend which function you should define to resolve it.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"The above behavior allows to define default \"fallback\" implementations and while allowing to specialize for sub-types. A usual example is a matrix multiplication, which has a generic (and slow) implementation with many specializations, which can take advantage of structure (sparse, banded), or of optimized implementations (e.g. blas implementation for dense matrices with eltype Float32 and Float64).","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Again, Julia does not make a difference between abstract types defined in Base libraries shipped with the language and those defined by you (the user). All are treated the same.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Like Composite types, Abstract types can have parameters. For example Julia defines an array of arbitrary dimension N and type T of its items as","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"abstract type AbstractArray{T,N} end","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Different T and N gives rise to different variants of AbstractArrays, therefore AbstractArray{Float32,2} is different from AbstractArray{Float64,2} and from AbstractArray{Float64,1}. Note that these are still Abstract types, which means you cannot instantiate them. They purpose is","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"to allow to define operations for broad class of concrete types\nto inform compiler about constant values, which can be used ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"For convenience, you can name some important partially instantiated Abstract types, for example AbstractVector as ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"const AbstractVector{T} = AbstractArray{T,1}","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"is defined in array.jl:23 (in Julia 1.6.2), which allows us to define for example general prescription for dot product of two abstract vectors as ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"function dot(a::AbstractVector, b::AbstractVector)\n  @assert length(a) == length(b)\n  mapreduce(*, +, a, b)\nend","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"You can verify that the above general function can be compiled to a performant code if specialized for a particular arguments.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"@code_native mapreduce(*,+, [1,2,3], [1,2,3])","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":".","category":"page"},{"location":"lecture_02/lecture/#More-on-Type-hierarchy-and-Parametric-types","page":"Lecture","title":"More on Type hierarchy and Parametric types","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"How types and functions comes together and what is the role of their parametrisation?","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"An interesting feature of Julia's type system is parametrisation of types, which we have slightly touched above. Abstract and Composite types can be parametrised, where the parameter can be other type, sets of types, or or a value of any bits type.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Let's look at some examples. Julia defines an abstract type of arrays of various sizes and shapes as ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"abstract type AbstractArray{T,N} end","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"where it is expected T to be a type of the element of arrays and and N the number of dimenctions. It is expected that every type derived from an abstract array will implement certain function (there is an expected interface)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Depending on the variance of the type constructor, the subtyping relation of the simple types may be either preserved, reversed, or ignored for the respective complex types. In the OCaml programming language, for example, \"list of Cat\" is a subtype of \"list of Animal\" because the list type constructor is covariant. This means that the subtyping relation of the simple types are preserved for the complex types. ","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"On the other hand, \"function from Animal to String\" is a subtype of \"function from Cat to String\" because the function type constructor is contravariant in the parameter type. Here the subtyping relation of the simple types is reversed for the complex types. ","category":"page"},{"location":"lecture_02/lecture/#The-power-of-Type-System-\\-and-multiple-dispatch","page":"Lecture","title":"The power of Type System \\& multiple dispatch","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Zero cost abstraction the compiler has information about types and can freely inline x |> identity |> identity |> identity |> identity |> identity","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"julia> f(x) = x |> identity |> identity |> identity |> identity |> identity\n@code_lowered f(1)\n@code_lowered f(1)","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Why the type system is important for efficiency\nBad practices \nLABS:\nNumber type-tree\nDesign Interval Aritmetics (for ODES)","category":"page"},{"location":"lecture_02/lecture/#VS-NOtes:","page":"Lecture","title":"VS NOtes:","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Basics:","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"type hierarchy\nsubtyping\nUnions","category":"page"},{"location":"lecture_02/lecture/#Pevnak's-idea","page":"Lecture","title":"Pevnak's idea","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Type hierarchy and rationale behind","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"* Why I cannot create an abstract struct with fields.\n* Why a type cannot subtype more than one types\n* How the type matching system works and what are the rules (Would take Jan Vitek's lecture or earlier) https://youtu.be/Y95fAipREHQ?t=958c","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"What types do in practice and how it matters?","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"* Allow to structure the program (example two types with the same memory layout (even empty) specializes methods)\n* Provides an information how to arrange variables in computer memory\n* Inform compiler how things can be stored (possibly on stack (bit types) vs strictly on heap (arrays))\n* Inform compiler about what is known (mutable vs non-mutable structs). Explain that when things are mutable, they have to be \"boxed\", meaning the variable is on stack and the structure contains pointer. \n* The effect of not strictly typed structs, where the type inference of objects is left to runtime","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Performance gotchas","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"- Why global is slow and how `const` comes to rescue","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Show the above with @codetyped, @codenative and @btime the effects, such that they can see that.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Stefans's C++ example of overloading https://discourse.julialang.org/t/claim-false-julia-isnt-multiple-dispatch-but-overloading/42370/16","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"_ Discussion about multiple inheritance https://github.com/JuliaLang/julia/issues/5","category":"page"},{"location":"lecture_02/lecture/#Examples","page":"Lecture","title":"Examples","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"why Vector{AbstractFloat} is a bad idea, while Vector{Float64} is a good one?\nwhy Vector{AbstractFloat} is different to Vector{<:AbstractFloat} or Vector{T} where {T<:AbstractFloat} ","category":"page"},{"location":"lecture_02/lecture/#Why-[1,2,3]-is-not-a-Vector{Number}","page":"Lecture","title":"Why [1,2,3] is not a Vector{Number}","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Vector{Number} is a concrete type, and [1, 2, 3] has type Vector{Int}, which is also a concrete type. One concrete type is never a subtype of another concrete type, they are the leaves of the type tree.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Vector{Number} is concrete, even though Number is not a concrete type. That’s because it has a concrete implementation which can store all types that are subtypes of Number, it has a specific memory layout etc. On the other hand, AbstractVector{Int} is the other way around and not a concrete type, because the container is abstract even though the element is concrete.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"What you can do instead is [1, 2, 3] isa Vector{<:Number} which is true. That’s because <:Number is a sort of placeholder which means “any type which is a subtype of Number”. This is often needed for dispatching on containers where you want to allow set of element types. f(x::Vector{Number}) can take only arguments of type Vector{Number}, whereas g(x::Vector{<:Number}) can take e.g. Vector{Int}, Vector{Float64}, Vector{Real}, Vector{Number}, etc.","category":"page"},{"location":"lecture_02/lecture/#Frequently-asked-(and-discussed)-questions","page":"Lecture","title":"Frequently asked (and discussed) questions","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"Why Abstract type cannot have a fields. In OOP, abstract classes can define fields that would be common to all derived classes. \nWhy type cannot be derived from multiple abstract type (mimicking Multiple inheritance). It seems like the function resolution might be difficult. An example copied from discussion in a 5th issue of the language opened in 2011 (and still not closed) (Image: ) show this usecase","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"abstract type A end;\nabstract tyle B end;\n\nf(::A) = 1\nf(::B) = 2\n\nstruct C <: A,B end;  # read as multiple inheritance.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"with that, it is not clear which function the compiler should call when f(C()). A current consensus seems to favour trait system support on the language level then the multiple inheritance, but priorities are elsewhere at the moment.","category":"page"},{"location":"lecture_02/lecture/#A-Headache-examples","page":"Lecture","title":"A Headache examples","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"This is a great example for type resolution.","category":"page"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"function Base.reduce(::typeof(hcat), xs::Vector{TV})  where {T, L, TV<:OneHotLike{T, L}}\n  OneHotMatrix(reduce(vcat, map(_indices, xs)), L)\nend","category":"page"},{"location":"lecture_02/lecture/#Turning-multiple-distpatch-to-single-dispatch","page":"Lecture","title":"Turning multiple-distpatch to single dispatch","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"https://stackoverflow.com/questions/39133424/how-to-create-a-single-dispatch-object-oriented-class-in-julia-that-behaves-l/39150509#39150509","category":"page"},{"location":"lecture_02/lecture/#conversion-among-variables","page":"Lecture","title":"conversion among variables","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"reinterpret(Float32, ref_sketch)","category":"page"},{"location":"lecture_02/lecture/#Trivia","page":"Lecture","title":"Trivia","text":"","category":"section"},{"location":"lecture_02/lecture/","page":"Lecture","title":"Lecture","text":"why this is true Vector{Int} <: AbstractVector{<:Any} why this is false Vector{Int} <: Vector{Any} why this is true Vector{Int} <: Vector{<:Any}","category":"page"},{"location":"installation/#install","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"In order to participate in the course, everyone should install a recent version of Julia together with some text editor of choice. Furthermore during the course we will introduce some best practices of creating/testing and distributing your own Julia code, for which we will require a GitHub account.","category":"page"},{"location":"installation/#Julia-IDE","page":"Installation","title":"Julia IDE","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"As there does not exist any proper IDE for Julia yet, there is no one way to install/develop and run Julia. However following the bachelor course TODO LINK we will be using currently the most widely adopted way to code in Julia and that is in combination with VSCode editor. If you are still rocking Windows machine there is a great guide on getting such setup working on the bachelor course. TODO LINK or COPY When deciding which version to download we recommend the latest stable release as of August 2021, 1.6.x, which has some quality of life improvements mainly with regards to exception readability. This is however not a strict requirement and any text editor with the option to send code to the terminal, such as Sublime Text, Vim+tmux or Atom will suffice (a major convenience when dealing with programming languages that support interactivity through a Read-Eval-Print Loop - REPL).","category":"page"},{"location":"installation/#GitHub-registration-and-Git-setup","page":"Installation","title":"GitHub registration & Git setup","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"If you are familiar with git and GitHub, we recommend following the guide at TODO LINK or COPY to create your own GitHub account and install a git client.","category":"page"},{"location":"installation/#Advanced-setup-(not-required)","page":"Installation","title":"Advanced setup (not required)","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"More advanced users can experiment with the following setups on Windows and/or Linux/MacOS platforms. More specifically we believe that knowing how to run any language inside a Docker container helps to understand the problem of dependencies and reproducible code in more depth than with a simple local installation. Moreover given the convenience of remote development in VSCode both of the setups feel almost like a local installation.","category":"page"},{"location":"installation/#Julia-in-WSL","page":"Installation","title":"Julia in WSL","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"This setup is specific to Windows 10, which as of 2016 allows to run any Linux distribution almost natively on top of the Windows kernel.","category":"page"},{"location":"installation/#Julia-in-Docker","page":"Installation","title":"Julia in Docker","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Install Docker client\nSetup the permissions\nBuild a simple docker with Julia Hello world\nCaveats around such setup - GUI, dependencies, file system, running as root","category":"page"},{"location":"lecture_01/motivation/#Introduction-to-Scientific-Programming","page":"Motivation","title":"Introduction to Scientific Programming","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Loose def: a scientific programming language is designed and optimized for the use of mathematical formula and matrices wiki","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Examples of Scientific programming languages include ALGOL, APL, Fortran, J, Julia, Maple, MATLAB and R.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Key requirements:","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"fast execution of the code (complex algorithms)\nease of code reuse / restructuring \nreproducibility of the results","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Contrast to general-purpose language:","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"less concern with business models (library + header files)\nless concern with ABI \nless concern with public/private separation","category":"page"},{"location":"lecture_01/motivation/#TODO","page":"Motivation","title":"TODO","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Zero cost abstraction - Rackcaucas","category":"page"},{"location":"lecture_01/motivation/#Example","page":"Motivation","title":"Example","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"In many applications, we encounter the task of optimization a function given by a routine (e.g. engineering, finance, etc.)","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"using Optim\n\nP(x,y) = x^2 - 3x*y + 5y^2 - 7y + 3   # user defined function\n\nz₀ = [ 0.0\n       0.0 ]     # starting point for optimization algorithm\n\noptimize(z -> P(z...), z₀, Newton())\n#optimize(z -> P(z...), z₀, Newton();autodiff = :forward)\n#optimize(z -> P(z...), z₀, ConjugateGradient())\n","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Very simple for a user, very complicated for a programmer. The program should:","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"pick the right optimization method (easy by config-like approach)\ncompute gradient (Hessian) of a user function","category":"page"},{"location":"lecture_01/motivation/#Classical-thinking:-create-a-library,-call-it.","page":"Motivation","title":"Classical thinking: create a library, call it.","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Think of an experiment: main taking a configuration file. The configuration file can be simple: input file, what to do with it, output file.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"The more complicated experiments you want to do, the more complex your configuration file becomes. Sooner or later, you will create a new configuration language, or scripting language.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Ending up in 2 language problem. ","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Low-level programming = computer centric\nclose to the hardware\nallows excellent optimization for fast execution\nHigh-level programming = user centric\nexperimenting = running multiple configurations\nrunning code with many different parameters as easily as possible\nallowing high level of abstraction","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"In scientific programming, the most well known scipting languages are: Python,  Matlab, R","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"If you care about standard \"configurations\" they are just perfect. \nYou hit a problem with more complex experiments. ","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"The scripting language typically makes decisions (if) at runtime. Becomes slow.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"(Image: )","category":"page"},{"location":"lecture_01/motivation/#Other-approaches","page":"Motivation","title":"Other approaches","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Just in time compilation (HL -> LL)\nautomatic typing (auto in C++) (LL->HL)","category":"page"},{"location":"lecture_01/motivation/#Challenge","page":"Motivation","title":"Challenge","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Translate high-level thinking with as much abstraction as possible into fast machine code.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Indexing array x in Matlab:","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"y=x(4/2)\ny=x(5/2)","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"In the first case it works, in the second throws an error.","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"function inde(x,n,m), x(n/m) can never be fast.","category":"page"},{"location":"lecture_01/motivation/#Julia-way","page":"Motivation","title":"Julia way","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"strong but flexible type system\nmultiple dispatch\nsingle language from high to low levels (as much as possible)\noptimize execution as much as you can during runtime\nfunctions are symbolic abstract layers\nabstraction should have zero computational cost","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"(Image: )","category":"page"},{"location":"lecture_01/motivation/#Example:","page":"Motivation","title":"Example:","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Function recursion with arbitrary number of arguments:","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"fsum(x) = x\nfsum(x,p...) = x+fsum(p[1],p[2:end]...)\n\nfsum(1,2,3)\n@code_llvm fsum(1,2,3)\n@code_llvm fsum(1.0,2.0,3.0)\nfz()=fsum(1,2,3)\n@code_llvm fz()","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"More involved example:","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"using Zygote\n\nf(x)=3x+1\n@code_llvm f'(10)","category":"page"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"Fuctions can act eiter as regular functions or like templates in C++.","category":"page"},{"location":"lecture_01/motivation/#Advantages-and-disadvantages","page":"Motivation","title":"Advantages and disadvantages","text":"","category":"section"},{"location":"lecture_01/motivation/","page":"Motivation","title":"Motivation","text":"compilation of everything to \nvery fast code\nslow interaction (caching...)\ngenerating libraries is harder \nthink of fsum, \neverything is \".h\" file\ndebugging will be harder\nMultiple dispatch\nallows great extensibility and code composition\nnot (yet) mainstream thinking","category":"page"},{"location":"lecture_07/macros/#Macros","page":"Macros","title":"Macros","text":"","category":"section"},{"location":"lecture_07/macros/#Homework-example??","page":"Macros","title":"Homework example??","text":"","category":"section"},{"location":"lecture_07/macros/","page":"Macros","title":"Macros","text":"Let them implement the accessors of the Ecosystem from labs 2 & 3 via metaprogramming (i.e. show them how Lazy.jl works)?","category":"page"},{"location":"how_to_submit_hw/#homeworks","page":"How to submit homeworks","title":"Homework submission","text":"","category":"section"},{"location":"how_to_submit_hw/","page":"How to submit homeworks","title":"How to submit homeworks","text":"This document should describe the homework submission procedure.","category":"page"},{"location":"howto/#How-to-use-admonitions","page":"How To ...","title":"How to use admonitions","text":"","category":"section"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"Documenter.jl provides five special styles for admonitions and one style for custom admonition types","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"Admonition type html class\ninfo \"admonition is-info\"\ncompat \"admonition is-compat\"\ndange \"admonition is-danger\"\nwarning \"admonition is-warning\"\ntip \"admonition is-success\"\ncustom \"admonition is-category-custom\"","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"All these admonitions can be used in the following way","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"!!! tip \"Header\"\n    Text ...\n    ```@repl\n    a = 1\n    b = 2\n    a + b\n    ```","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"The resulting admonition looks as follows","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"tip: Header\nText ...a = 1\nb = 2\na + b","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"The problem is, that the evaluation of the block of code inside admonitions is not currently supported. To allow code evaluation inside admonitions, we can use two raw HTML blocks to wrap the admonition body. The syntax of the code between the HTML block is the same as everywhere else in the document.","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"```@raw html\n<div class=\"admonition is-success\">\n<header class=\"admonition-header\">Header</header>\n<div class=\"admonition-body\">\n```\n\nText ...\n\n```@repl\na = 1\nb = 2\na + b\n```\n\n```@raw html\n</div></div>\n```","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"The resulting admonition then looks as follows","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"<div class=\"admonition is-success\">\n<header class=\"admonition-header\">Header</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"Text ...","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"a = 1\nb = 2\na + b","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"</div></div>","category":"page"},{"location":"howto/#Additional-admonition-types","page":"How To ...","title":"Additional admonition types","text":"","category":"section"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"The css style downloaded in the make.jl provides three additional admonition types","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"Admonition type html class\ntheorem \"admonition is-category-theorem\"\nexercise \"admonition is-category-exercise\"\nhomework \"admonition is-category-homework\"","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"Currently, the first two types use the style of the default admonitions types. However, it may change in the future.","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"theorem: Theorem\nText...","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"exercise: Exercise\nText...","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"homework: Homework\nText...","category":"page"},{"location":"howto/#Exercise-with-solution","page":"How To ...","title":"Exercise with solution","text":"","category":"section"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"The used css style also provides style for collapsible admonition that can be used for example to define exercise with the hidden solution. To use this feature, we have to use raw HTML blocks.","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"```@raw html\n<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Header</header>\n<div class=\"admonition-body\">\n```\n\nSome text that describes the exercise\n\n```@raw html\n</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>\n```\n\nSolution\n\n```@raw html\n</p></details>\n```","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"The result is following","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Header</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"Some text that describes the exercise","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"Solution","category":"page"},{"location":"howto/","page":"How To ...","title":"How To ...","text":"</p></details>","category":"page"},{"location":"lecture_02/hw/#Homework-2:-Predator-Prey-Agents","page":"Homework","title":"Homework 2: Predator-Prey Agents","text":"","category":"section"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"using Scientific_Programming_in_Julia\nusing Scientific_Programming_in_Julia.Ecosystem: eat!, find_food, agent_count","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"In this homework we will continue working on our agent simulation.  All your code must be in a single file called Ecosystem.jl containing all the type definitions and functions we created in Lab 2 and the work you do in this homework. Zip this file and upload it to BRUTE to receive your points for the homework.","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"To monitor the different populations in our world we need a function that counts each type of agent. For AbstractAnimals we simply have to count how many of each type are currently in our World. In the case of AbstractPlants we only want to count the ones that are fully grown.","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"<div class=\"admonition is-category-homework\">\n<header class=\"admonition-header\">Homework (2 points)</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"Implement a function agent_count that can be called on a single AbstractAgent and returns either 0 or 1 (i.e. always 1 for animals; 1 for a fully grown plant and 0 otherwise).\nAdd a method for a vector of agents Vector{<:AbstractAgent}.\nAdd a method for a World which returns a dictionary that contains pairs of Symbols and the agent count like below:","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"grass1 = Grass(true,5.0,5.0);\ngrass2 = Grass(false,5.0,2.0);\nsheep = Sheep(10.0,5.0,1.0,1.0);\nwolf  = Wolf(20.0,10.0,1.0,1.0);\nworld = World([grass1, grass2, sheep, wolf]);\n\nagent_count(world)  # the grass that is not fully grown is not counted","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"Hint: You can get the name of a type by using the nameof function:","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"nameof(Grass)","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"Use as much dispatch as you can! ;)","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"# first solution using foldl instead of a for loop\nagent_count(g::AbstractPlant) = g.fully_grown ? 1 : 0\nagent_count(::AbstractAnimal) = 1\nagent_count(as::Vector{<:AbstractAgent}) = sum(agent_count,as)\n\nfunction agent_count(w::World)\n    function op(d::Dict,a::T) where T<:AbstractAgent\n        n = nameof(T)\n        if n in keys(d)\n            d[n] += agent_count(a)\n        else\n            d[n] = agent_count(a)\n        end\n        return d\n    end\n    foldl(op, w.agents, init=Dict{Symbol,Int}())\nend","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"# second solution with StastBase.countmap\ncountsym(g::T) where T<:AbstractPlant = g.fully_grown ? nameof(T) : :NoCount\ncountsym(::T) where T<:AbstractAnimal = nameof(T)\n\nfunction agent_count(w::World)\n    cs = StatsBase.countmap(countsym.(w.agents))\n    delete!(cs,:NoCount)\nend","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"</p></details>","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise (voluntary)</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"Using the world below, run a simple simulation with 7 iterations.  In each iteration the wolf has to find_food and eat!.  Plot trajectories of the agent count over time.","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"(Do not include this code in your submission to BRUTE)","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"grass = [Grass(true,5.0,5.0) for _ in 1:2];\nsheep = [Sheep(10.0,5.0,1.0,1.0) for _ in 1:5];\nwolf  = Wolf(20.0,10.0,1.0,1.0);\nworld = World(vcat([wolf], sheep, grass));","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"grass = [Grass(true,5.0,5.0) for _ in 1:2];\nsheep = [Sheep(10.0,5.0,1.0,1.0) for _ in 1:5];\nwolf  = Wolf(20.0,10.0,1.0,1.0);\nworld = World(vcat([wolf], sheep, grass));\n\nns = nameof.(unique(typeof.(world.agents)))\ncounts = Dict(n=>[] for n in ns);\nfor _ in 1:7\n    cs = agent_count(world)\n    eat!(wolf, find_food(wolf,world), world)\n    for (n,c) in cs\n        push!(counts[n], c)\n    end\nend\n\nusing Plots\nplt = plot();\nfor n in ns\n    plot!(plt, counts[n], label=\"$n\", lw=2, ylims=(0,5))\nend\nplt","category":"page"},{"location":"lecture_02/hw/","page":"Homework","title":"Homework","text":"</p></details>","category":"page"},{"location":"lecture_01/hw/#Homework-1","page":"Homework","title":"Homework 1","text":"","category":"section"},{"location":"lecture_01/hw/#Assignment-1-(2-points)","page":"Homework","title":"Assignment 1 (2 points)","text":"","category":"section"},{"location":"lecture_01/hw/#Assignment-2-(4-points)","page":"Homework","title":"Assignment 2 (4 points)","text":"","category":"section"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"...","category":"page"},{"location":"lecture_01/hw/#How-to-submit?","page":"Homework","title":"How to submit?","text":"","category":"section"},{"location":"lecture_01/hw/","page":"Homework","title":"Homework","text":"The guide is located here","category":"page"},{"location":"lecture_02/example/#from-introduction","page":"-","title":"from introduction","text":"","category":"section"},{"location":"lecture_02/example/","page":"-","title":"-","text":"Recursive call","category":"page"},{"location":"lecture_02/example/","page":"-","title":"-","text":"fsum(x) = x\nfsum(x,p...) = x+fsum(p[1],p[2:end]...)","category":"page"},{"location":"lecture_02/example/","page":"-","title":"-","text":"Is a template how to behave:","category":"page"},{"location":"lecture_02/example/","page":"-","title":"-","text":"julia is a typed language: x, and p are of type Any\nwhat happens when calling:","category":"page"},{"location":"lecture_02/example/","page":"-","title":"-","text":"fsum(1,2,3)\nfsum(1,'c')\nfsum(1,\"c\")","category":"page"},{"location":"lecture_02/example/","page":"-","title":"-","text":"Show what \"+\" function do, ","category":"page"},{"location":"lecture_02/example/","page":"-","title":"-","text":"methods(+)","category":"page"},{"location":"lecture_02/example/","page":"-","title":"-","text":"what is multiple dispatch, how differnt it is from operator overloading. (Stefans example from lecture)","category":"page"},{"location":"lecture_02/example/#Show-error-message:","page":"-","title":"Show error message:","text":"","category":"section"},{"location":"lecture_02/example/","page":"-","title":"-","text":"explain why fsum(1,\"c\") failed.","category":"page"},{"location":"lecture_02/example/#Introduce-type-hierarchy","page":"-","title":"Introduce type hierarchy","text":"","category":"section"},{"location":"lecture_02/example/","page":"-","title":"-","text":"(Image: )","category":"page"},{"location":"lecture_02/example/","page":"-","title":"-","text":"Define fsum(x::Number,p...) = x+fsum(p[1],p[2:end]...)\nShow how to extend to Arrays\nDefine fsum(x::AbstractArray,p...) = x+fsum(p[1],p[2:end]...)\nUnion","category":"page"},{"location":"lecture_01/outline/#Course-outline","page":"Outline","title":"Course outline","text":"","category":"section"},{"location":"lecture_01/outline/","page":"Outline","title":"Outline","text":"type system\nuser: tool for abstraction\ncompiler: tool for memory layout\ndesign patterns (mental setup)\njulia is a type-based language\ngeneralizes OOP and FP\nPackages\nway how to organize code\ncode reuse (alternative to libraries)\nexperiment reproducibility\n","category":"page"},{"location":"lecture_01/outline/#How-to-write-fast-code:","page":"Outline","title":"How to write fast code:","text":"","category":"section"},{"location":"lecture_01/outline/","page":"Outline","title":"Outline","text":"(Image: )","category":"page"},{"location":"lecture_01/outline/","page":"Outline","title":"Outline","text":"cache misses.","category":"page"},{"location":"lecture_01/outline/#Syntax","page":"Outline","title":"Syntax","text":"","category":"section"},{"location":"lecture_01/outline/","page":"Outline","title":"Outline","text":"Syntactic Sugar: Cheat sheet: https://cheatsheets.quantecon.org/","category":"page"},{"location":"lecture_01/outline/#Typing-Lecture-2","page":"Outline","title":"Typing -> Lecture 2","text":"","category":"section"},{"location":"lecture_01/outline/","page":"Outline","title":"Outline","text":"static\ndynamic","category":"page"},{"location":"lecture_01/outline/#","page":"Outline","title":"","text":"","category":"section"},{"location":"lecture_03/hw/#Homework-3","page":"Homework","title":"Homework 3","text":"","category":"section"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"using Scientific_Programming_in_Julia\nusing Scientific_Programming_in_Julia.Ecosystem: eat!, find_food, count","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"The goal of this homework is to demonstrate the forwarding method by implementing a gendered sheep that can only reproduce with another sheep of opposite gender.","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"The gendered sheep need an additonal field gender::Symbol which can be either :male or :female. In OOP we would now simply inherit from Sheep and create a GenderedSheep with an additional field. In Julia there is no inheritance - only subtyping of abstract types. As you cannot inherit from a concrete type in Julia, we will have to create a wrapper type and forward all necessary methods. This is typically a sign of unfortunate type tree design and should be avoided, but if you want to extend a code base by a type that was not thought of during the inital design, this forwarding of methods is a nice work-around.  Our GenderedSheep type will simply contain a classic sheep and a gender field","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"struct GenderedSheep{T<:Real} <: AbstractAnimal\n    sheep::Sheep{T}\n    gender::Symbol\nend\nGenderedSheep(E,ΔE,pr,pf,gender) = GenderedSheep(Sheep(E,ΔE,pr,pf),gender)","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"GenderedSheep(1.0,1.0,1.0,1.0,:female)","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"In our case, the methods that have to be forwarded are agent_step!, reproduce!, eats and eat!.  The custom reproduction behaviour will of course be taken care of by a reproduce! function that does not just forward but also contains specialized behaviour for the GenderedSheep.","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"<div class=\"admonition is-category-homework\">\n<header class=\"admonition-header\">Homework</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"Forward the accessors energy, energy!, reproduction_prob, and food_prob, as well as our core methods eats and eat! to Sheep.","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"energy(g::GenderedSheep) = energy(g.sheep)\nenergy!(g::GenderedSheep, ΔE) = energy!(g.sheep, ΔE)\nreproduction_prob(g::GenderedSheep) = reproduction_prob(g.sheep)\nfood_prob(g::GenderedSheep) = food_prob(g.sheep)\n\neats(::GenderedSheep, ::Grass) = true\neats(::GenderedSheep, ::PoisonedGrass) = true\neat!(s::GenderedSheep, g::AbstractPlant, w::World) = eat!(s.sheep, g, w)","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"</p></details>","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"<div class=\"admonition is-category-homework\">\n<header class=\"admonition-header\">Homework</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"Implement the reproduce! method for the GenderedSheep.  Note that you first have to find another sheep of opposite gender in your World, and only if you can find one you can reproduce.","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"mates(a::AbstractPlant, ::GenderedSheep) = false\nmates(a::AbstractAnimal, ::GenderedSheep) = false\nmates(g1::GenderedSheep, g2::GenderedSheep) = g1.gender != g2.gender\nfunction find_mate(g::GenderedSheep, w::World)\n    ms = filter(a->mates(a,g), w.agents)\n    isempty(ms) ? nothing : sample(ms)\nend\n\nfunction reproduce!(s::GenderedSheep, w::World)\n    m = find_mate(s,w)\n    if !isnothing(m)\n        s.sheep.energy /= 2\n        # TODO: should probably mix s/m\n        push!(w.agents, deepcopy(s))\n    end\nend","category":"page"},{"location":"lecture_03/hw/","page":"Homework","title":"Homework","text":"</p></details>","category":"page"},{"location":"lecture_01/lab/#Lab-01:-Introduction-to-Julia","page":"Lab","title":"Lab 01: Introduction to Julia","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"This lab should get everyone up to speed in the basics of Julia's installation, syntax and basic coding. For more detailed introduction you can check out Lectures 1-3 of the bachelor course.","category":"page"},{"location":"lecture_01/lab/#Testing-Julia-installation","page":"Lab","title":"Testing Julia installation","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"In order to proceed further let's run a simple script to see, that the setup described in chapter Installation is working properly. After spawning a terminal run this command:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"julia ./test_setup.jl","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The script does the following ","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"\"Tests\" if Julia is added to path and can be run with julia command from anywhere\nPrints Hello World and Julia version info\nCreates an environment configuration files\nInstalls a basic pkg called BenchmarkTools, which we will use for benchmarking a simple function later in the labs.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"There are some quality of life improvements over long term support versions of Julia and thus for the course of these lectures we will use the latest stable release of Julia 1.6.x.","category":"page"},{"location":"lecture_01/lab/#Polynomial-evaluation-example","page":"Lab","title":"Polynomial evaluation example","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Let's consider a common mathematical example for evaluation of nth-degree polynomial","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"f(x) = a_nx^n + a_n-1x^n-1 + dots + a_0x^0","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"where x in mathbbR and veca in mathbbR^n+1.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The simplest way of writing this is just realizing that essentially the function f is really implicitly containing argument veca, i.e. f equiv f(veca x), yielding the following function","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"function polynomial(a, x)\n    accumulator = 0\n    for i in length(a):-1:1\n        accumulator += x^(i-1) * a[i] # ! 1-based indexing for arrays\n    end\n    return accumulator\nend\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Evaluate the code of the function called polynomial in Julia REPL and evaluate the function itself with the following arguments.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"a = [-19, 7, -4, 6] # list coefficients a from a^0 to a^n\nx = 3               # point of evaluation\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The simplest way is to just copy&paste into an already running terminal manually. As opposed to the default Python REPL, Julia can deal with the blocks of code and different indentation much better without installation of an ipython-like REPL. There are ways to make this much easier in different text editors/IDEs:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"VSCode - when using Julia extension, by default Ctrl+Enter will spawn Julia REPL, when a .jl file is opened\nSublime Text - Send Code pkg (works well with Linux terminal or tmux, support for Windows is poor)\nVim - there is a Julia language plugin, which can be combine with vimcmdline","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Either way, you should see the following:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"function polynomial(a, x)\n    accumulator = 0\n    for i in length(a):-1:1\n        accumulator += x^(i-1) * a[i] # ! 1-based indexing for arrays\n    end\n    return accumulator\nend","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Similarly we enter the arguments of the function a and x:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"a = [-19, 7, -4, 6]\nx = 3","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Function call intuitively takes the name of the function with round brackets as arguments, i.e. works in the same way as majority of programming languages. The result is printed unless a ; is added at the end of the statement.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"polynomial(a, x)    # function call","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Thanks to the high level nature of Julia language it is often the case that examples written in pseudocode are almost directly rewritable into the language itself without major changes and the code can be thus interpreted easily.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"(Image: polynomial_explained)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The indentation is not necessary as opposed to other languages such as Python, due to the existence of the end keyword, however it is strongly recommended to use it, see style guide. Furthermore the return keyword can be omitted if the last line being evaluated contains the result, unless the line ends with ;.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Though there are libraries/IDEs that allow us to step through Julia code (Rebugger.jl link and VSCode link), we can (having defined the arguments with the same name as inside the actual function) evaluate pieces of code separately. ","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Evaluate the following pieces of code and check their type with typeof function, e.g. typeof(a) or typeof([-19, 7, -4, 6])","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"BONUS: Try to \"call for help\" by accessing the build in help terminal by typing ? followed by a keyword to explain. Use this for basic functions such as length, typeof, ^.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"a = [-19, 7, -4, 6]\nx = 3\naccumulator = 0\nlength(a):-1:1\n\ni = length(a)\naccumulator += x^(i-1) * a[i]\naccumulator\n\npolynomial\n^\n*","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"When defining a variable through an assignment we get the representation of the right side, again this is different from the default  behavior in Python, where the output of a = [-19, 7, -4, 6], prints nothing. In Julia REPL we get the result of the display function.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"julia> a = [-19, 7, -4, 6]\njulia> display(a) # should return the same thing as the line above","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"As you can see, the string that is being displayed contains information about the contents of a variable along with it's type in this case this is a Vector of Int types. Which can be checked further with the typeof function:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(a)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"In most cases variables store just a reference to a place in memory either stack/heap (exceptions are primitive types such as Int, Float) and therefore creating an array a, storing the reference in b with b = a and changing elements of b, e.g. b[1] = 2, changes also the values in a.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The other two assignments are exactly the same as they both generate an instance of Int type with different values. Though now one has to call for hell the typeof function, because by default this information is omitted in the display of simple types.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"x = 3\naccumulator = 0\ntypeof(x), typeof(accumulator)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The next expression creates an instance of a range, which are inclusive in Julia, i.e. containing number from start to end - in this case running from 4 to 1 with negative step -1, thus counting down.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"length(a):-1:1\ntypeof(length(a):-1:1)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Let's confirm the fact that the update operator += really does update the variable accumulator by running the following","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"i = length(a) # \naccumulator += x^(i-1) * a[i]\naccumulator","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Notice that evaluating a variable, which can be used instead of the return keyword at the end of a function.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"We have already seen the output of evaluating polynomial function name in the REPL By creating the function polynomial we have defined a variable polynomial, that from now on always refers to a function and cannot be redefined with a different type.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"polynomial","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"This is cause by the fact that each function defines essentially a new type, the same like Int ~ Int64 or Vector{Int}.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(polynomial)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"You can check that it is a subtype of the Function abstract type, with the subtyping operator <:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(polynomial) <: Function","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"These concepts will be expanded further in the type lecture, however for now note that this construction is quite useful for example if we wanted to create derivative rules for our function derivativeof(::typeof(polynomial), ...).","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Looking at the last two expersions +, *, we can see that in Julia, operators are also functions. ","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"+\n*","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The main difference from our polynomial function is that there are multiple methods, for each of these functions. Each one of the methods coresponds to a specific combination of arguments, for which the function can be specialized to. You can see the list by calling a methods function:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"methods(+)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"One other notable difference is that these functions allow using both infix and postfix notation a + b and +(a,b), which is a speciality of elementary functions such as arithmetic operators or set operation such as ∩, ∪, ∈.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"BONUS: Accessing help terminal ? and looking up a keyword, searches for documentation of individual methods/functions in the source code. When creating a pkg, it is desirable to create so called docstrings for each method that is going to be exported. docstrings are multiline strings written above a function. More on this in lecture on pkg development.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"\"\"\"\n    polynomial(a, x)\n\nReturns value of a polynomial with coefficients `a` at point `x`.\n\"\"\"\nfunction polynomial(a, x)\n    # function body\nend","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"As the arguments of the polynomial functions are untyped, i.e. they do not specify the allowed types like for example polynomial(a, x::Number) does, the following exercise explores how wide range of arguments does the","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"What happens if you call our polynomial function with with the following coefficients?","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"af = [-19.0, 7.0, -4.0, 6.0]\nat = (-19, 7, -4, 6)\nant = (a₀ = -19, a₁ = 7, a₂ = -4, a₃ = 6)\na2d = [-19 -4; 7 6]\nach = ['1', '2', '3', '4']\nac = [2i^2 + 1 for i in -2:1]\nag = (2i^2 + 1 for i in -2:1)\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Check first the types of each of these coefficients by calling typeof and eltype.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"BONUS: In the case of ag, use the collect function to get the desirable result. What does it do? Check again the type of the result.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(af), eltype(af)\npolynomial(af, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"As opposed to the basic definition of a type the array is filled with Float64 types and the resulting value gets promoted as well to the Float64.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(at), eltype(at)\npolynomial(at, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"With round brackets over a fixed length vector we get the Tuple type, which is a fixed size, so called immutable \"array\" of a fixed size (its elements cannot be changed, unless initialized from scratch). Each element can be of a different type, but here we have only one and thus the Tuple is aliased into NTuple. There are some performance benefits for using immutable structure, which will be discussed later or even later.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Defining key=value pairs inside round brackets creates a structure called NamedTuple, which has the same properties as Tuple and furthermore it's elements can be conveniently accessed by dot syntax, e.g. ant.a₀.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(ant), eltype(ant)\npolynomial(ant, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Defining a 2D array is a simple change of syntax, which initialized a matrix row by row separated by ; with spaces between individual elements. The function works in the same way because linear indexing works in 2d arrays in the column major order.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(a2d), eltype(a2d)\npolynomial(a2d, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Consider the vector/array of characters, which themselves have numeric values (you can check by converting them to Int Int('1') or convert(Int, 'l')). In spite of that, our untyped function cannot process such input, as there isn't an operation/method that would allow  multiplication of Char and Int type. Julia tries to promote the argument types to some common type, however checking the promote_type(Int, Char) returns Any (union of all types), which tells us that the conversion is not possible automatically.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(ach), eltype(ach)\npolynomial(ach, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"In the stacktrace we can see the location of each function call. If we include the function polynomial from some file poly.jl using include(\"poly.jl\"), we will see that the location changes from REPL[X]:10 to the the actual file name.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The next example shows so called array comprehension syntax, where we define and array of known length using and for loop iteration. Resulting array/vector has integer elements, however even mixed type is possible yielding Any, if there isn't any other common supertype to promote every entry into. (Use ? to look what promote and promote_type does.)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(ac), eltype(ac)\npolynomial(ac, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"By swapping square brackets for round we have defined so called generator/iterator, which as opposed to the previous example does not allocate an array, only the structure that produces it. You may notice that the element type in this case is Any, which means that a function using such generator as an argument cannot specialize based on the type and has to infer it every time an element is generated/returned. We will touch on how this affects performance in one of the later lectures.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"typeof(ag), eltype(ag)\npolynomial(ag, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"BONUS: In general generators may have unknown length, this can be useful for example in batch processing of files, where we do not know beforehand how many files are in a given folder. However the problem here originated from a missing indexing operation getindex, which can be easily solved by collecting the generator with collect and thus transforming it into and array.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"agc = ag |> collect # pipe syntax, equivalent to collect(ag)\ntypeof(agc), eltype(agc)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"You can see now that eltype is no longer Any, as a proper type for the whole container has been found in the collect function, however we have lost the advantage of not allocating an array.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_01/lab/#Extending/limiting-the-polynomial-example","page":"Lab","title":"Extending/limiting the polynomial example","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Following up on the polynomial example, let's us expand it a little further in order to facilitate the the arguments, that have been throwing exceptions. The first direction, that we will move forward to, is providing the user with more detailed error message when an incorrect type of coefficients has been provided.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Design an if-else condition such that the array of Char example throws an error with custom string message, telling the user what went wrong and printing the incorrect input alongside it. Confirm that we have not broken the functionality of other examples from previous exercise.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"HINTS:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Throw the ArgumentError(msg) with throw function and string message msg. More details in help mode ? or at the end of this document.\nStrings are defined like this s = \"Hello!\"\nUse string interpolation to create the error message. It allows injecting an expresion into a string with the $ syntax b = 1; s = \"Hellow Number $(b)\"\nCompare eltype of the coefficients with Char type.\nThe syntax for if-else:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"if condition\n    println(\"true\") # true branch code\nelse\n    println(\"false\") # false branch code\nend","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Not equal condition can be written as a != b.\nThrowing an exception automatically returns from the function. Use return inside one of the branches to return the correct value.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The simplest way is to wrap the whole function inside an if-else condition and returning only when the input is \"correct\" (it will still fail in some cases).","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"function polynomial(a, x)\n    if eltype(a) != Char\n        accumulator = 0\n        for i in length(a):-1:1\n            accumulator += x^(i-1) * a[i] # ! 1-based indexing for arrays\n        end\n        return accumulator\n    else\n        throw(ArgumentError(\"Invalid coefficients $(a) of type Char!\"))\n    end\nend\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Now this should show our predefined error message.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"polynomial(ach, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Testing on other examples should pass without errors and give the same output as before.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"polynomial(a, x)\npolynomial(af, x)\npolynomial(at, x)\npolynomial(ant, x)\npolynomial(a2d, x)\npolynomial(ac, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The second direction concerns the limitation to index-able structures, which the generator example is not. For this we will have to rewrite the whole loop in a more functional programming approach using map, anonymous function and other concepts.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Rewrite the following code inside our original polynomial function with map, enumerate and anonymous function.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"accumulator = 0\nfor i in length(a):-1:1\n    accumulator += x^(i-1) * a[i] # ! 1-based indexing for arrays\nend","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Anonymous functions reminder:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"x -> x + 1              # unless the reference is stored it cannot be called\nplusone = x -> x + 1    # the reference can be stored inside a variable\nplusone(x)              # calling with the same syntax","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"HINTS:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Use enumerate to obtain iterator over a that returns a tuple of ia = (i, aᵢ). With Julia 1-based indexing i starts also from 1 and goes up to length(a).\nPass this into a map with either in-place or predefined anonymous function that does the operation of x^(i-1) * aᵢ.\nUse sum to collect the resulting array into accumulator variable or directly into the return command.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"BONUS: There is even shorter way how to write this using one line function syntax and recently added options to the sum function. See entry in the help mode ?.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Ordered from the longest to the shortest, here are three (and there are definitely more) examples with the same functionality. Using the map(iterable) do itervar ... end syntax, that creates anonymous function from the block of code.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"function polynomial(a, x)\n    powers = map(enumerate(a)) do (i, aᵢ)\n        x^(i-1) * aᵢ\n    end\n    accumulator = sum(powers)\n    return accumulator\nend\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Using the default syntax for map and storing the anonymous into a variable","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"function polynomial(a, x)\n    polypow = ia -> x^(ia[1]-1) * ia[2] # \n    powers = map(polypow, enumerate(a))\n    return sum(powers)\nend\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"As the function polypow is used only once, there is no need to assign it to a local variable.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"function polynomial(a, x)\n    powers = map(ia -> x^(ia[1]-1) * ia[2], enumerate(a))\n    sum(powers)\nend\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Checking the behavior on all the inputs.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"polynomial(a, x)\npolynomial(af, x)\npolynomial(at, x)\npolynomial(ant, x)\npolynomial(a2d, x)\npolynomial(ach, x)\npolynomial(ac, x)\npolynomial(ag, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"BONUS: Using one line function definition and the recently added option of a function in the first argument of sum:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"polynomial(a, x) = sum(ia -> x^(ia[1]-1) * ia[2], enumerate(a))\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_01/lab/#How-to-use-code-from-other-people","page":"Lab","title":"How to use code from other people","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The script that we have run at the beginning of this lab has created a folder test with the following files.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"./test/\n    ├── Manifest.toml\n    ├── Project.toml\n    └── src\n        └── test.jl","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Every folder with a toml file called Project.toml, can be used by Julia's pkg manager into setting so called environment. Each of these environments has a specific name, unique identifier and most importantly a list of pkgs to be installed. Setting up or more often called activating an environment can be done either before starting Julia itself by running julia with the --project XXX flag or from withing the Julia REPL, by switching to Pkg mode with ] key (similar to the help mode activated by pressing ?) and running command activate.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"So far we have used the general environment, which by default does not come with any 3rd party packages and includes only the base and standard libraries - already quite powerful on its own. ","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"In order to find which environment is currently active, run the following:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"] status","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The output of such command usually indicates the general environment located at .julia/ folder (${HOME}/.julia/ or ${APPDATA}/.julia/ in case of Unix/Windows based systems respectively)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"(@v1.6) pkg> status\nStatus `~/.julia/environments/v1.6/Project.toml` (empty project)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Generally one should avoid working in the general environment, with the exception using some generic pkgs, such as PkgTemplates.jl, which is used for generating pkg templates/folder structure like the one above (link), more on this in the lecture on pkg development. ","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Activate the test environment inside ./test and check that the BenchmarkTools package has been installed. Use BenchmarkTools pkg's @btime to benchmark our polynomial function with the following arguments.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"aexp = ones(10) ./ factorial.(0:9)\nx = 1.1\nnothing #hide","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"HINTS:","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"In pkg mode use the command activate and status to check the presence. \nIn order to import the functionality from other package, lookup the keyword using in the repl help mode ?. \nThe functionality that we want to use is the @btime macro (it acts almost like a function but with a different syntax @macro arg1 arg2 arg3 ...). More on macros in the corresponding lecture.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"BONUS: Compare the output of polynomial(aexp, x) with the value of exp(x), which it approximates.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"There are other options to import a function/macro from a different package, however for now let's keep it simple with the using Module syntax, that brings to the REPL, all the variables/function/macros exported by the BenchmarkTools pkg. If @btime is exported, which it is, it can be accessed without specification i.e. just by calling @btime without the need for BenchmarkTools.@btime. More on the architecture of pkg/module loading in the package developement lecture.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"using BenchmarkTools\n@btime polynomial(aexp, x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The output gives us the time of execution averaged over multiple runs (the number of samples is defined automatically based on run time) as well as the number of allocations and the output of the function, that is being benchmarked.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"BONUS: The difference between our approximation and the \"actual\" function value computed as a difference of the two. ","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"polynomial(aexp, x) - exp(x)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"The apostrophes in the previous sentece are on purpose, because implementation of exp also relies too on a finite sum, though much more sophisticated than the basic Taylor expansion.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_01/lab/#Useful-resources","page":"Lab","title":"Useful resources","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Getting Started tutorial from JuliaLang documentation - Docs\nConverting syntax between MATLAB ↔ Python ↔ Julia - Cheatsheet\nBachelor course for refreshing your knowledge - Course\nStylistic conventions - Style Guide\nReserved keywords - List","category":"page"},{"location":"lecture_01/lab/#lab_errors","page":"Lab","title":"Various errors and how to read them","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"This section summarizes most commonly encountered types of errors in Julia and shows how to read them. Documentation contains the complete list and each individual error can be queried against the ? mode of the REPL.","category":"page"},{"location":"lecture_01/lab/#MethodError","page":"Lab","title":"MethodError","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"This type of error is most commonly thrown by Julia's multiple dispatch system with a message like no method matching X(args...), seen in two examples bellow.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"2 * 'a'                       # many candidates\ngetindex((i for i in 1:4), 3) # no candidates","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Both of these examples have a short stacktrace, showing that the execution failed on the top most level in REPL, however if this code is a part of some function in a separate file, the stacktrace will reflect it. What this error tells us is that the dispatch system could not find a method for a given function, that would be suitable for the type of arguments, that it has been given. In the first case Julia offers also a list of candidate methods, that match at least some of the arguments","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"When dealing with basic Julia functions and types, this behavior can be treated as something given and though one could locally add a method for example for multiplication of Char and Int, there is usually a good reason why Julia does not support such functionality by default. On the other hand when dealing with user defined code, this error may suggest the developer, that either the functions are too strictly typed or that another method definition is needed in order to satisfy the desired functionality.","category":"page"},{"location":"lecture_01/lab/#InexactError","page":"Lab","title":"InexactError","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"This type of error is most commonly thrown by the type conversion system (centered around convert function), informing the user that it cannot exactly convert a value of some type to match arguments of a function being called.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Int(1.2)                      # root cause\nappend!([1,2,3], 1.2)         # same as above but shows the root cause deeper in the stack trace","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"In this case the function being Int and the value a floating point. The second example shows InexactError may be caused deeper inside an inconspicuous function call, where we want to extend an array by another value, which is unfortunately incompatible.","category":"page"},{"location":"lecture_01/lab/#ArgumentError","page":"Lab","title":"ArgumentError","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"As opposed to the previous two errors, ArgumentError can contain user specified error message and thus can serve multiple purposes. It is however recommended to throw this type of error, when the parameters to a function call do not match a valid signature, e.g. when factorial were given negative or non-integer argument (note that this is being handled in Julia by multiple dispatch and specific DomainError).","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"This example shows a concatenation of two 2d arrays of incompatible sizes 3x3 and 2x2.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"hcat(ones(3,3), zeros(2,2))","category":"page"},{"location":"lecture_01/lab/#KeyError","page":"Lab","title":"KeyError","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"This error is specific to hash table based objects such as the Dict type and tells the user that and indexing operation into such structure tried to access or delete a non-existent element.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"d = Dict(:a => [1,2,3], :b => [1,23])\nd[:c]","category":"page"},{"location":"lecture_01/lab/#TypeError","page":"Lab","title":"TypeError","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Type assertion failure, or calling an intrinsic function (inside LLVM, where code is strictly typed) with incorrect argument type. In practice this error comes up most often when comparing value of a type against the Bool type as seen in the example bellow.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"if 1 end                # calls internally typeassert(1, Bool)\ntypeassert(1, Bool)","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"In order to compare inside conditional statements such as if-elseif-else or the ternary operator x ? a : b the condition has to be always of Bool type, thus the example above can be fixed by the comparison operator: if 1 == 1 end (in reality either the left or the right side of the expression contains an expression or a variable to compare against).","category":"page"},{"location":"lecture_01/lab/#UndefVarError","page":"Lab","title":"UndefVarError","text":"","category":"section"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"While this error is quite self-explanatory, the exact causes are often quite puzzling for the user. The reason behind the confusion is to do with code scoping, which comes into play for example when trying to access a local variable from outside of a given function or just updating a global variable from within a simple loop. ","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"In the first example we show the former case, where variable is declared from within a function and accessed from outside afterwards.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"function plusone(x)\n    uno = 1\n    return x + uno\nend\nuno # defined only within plusone","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Unless there is variable I_am_not_defined in the global scope, the following should throw an error.","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"I_am_not_defined","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"Often these kind of errors arise as a result of bad code practices, such as long running sessions of Julia having long forgotten global variables, that do not exist upon new execution (this one in particular has been addressed by the authors of the reactive Julia notebooks Pluto.jl).","category":"page"},{"location":"lecture_01/lab/","page":"Lab","title":"Lab","text":"For more details on code scoping we recommend particular places in the bachelor course lectures here and there.","category":"page"},{"location":"lecture_02/lab/#lab02","page":"Lab","title":"Lab 2: Predator-Prey Agents","text":"","category":"section"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"using Scientific_Programming_in_Julia\nusing Scientific_Programming_in_Julia.Ecosystem: eat!, find_food, count","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"In the next two labs you will implement your own, simplified, agent-based simulation of a predator-prey model.  The model will contain wolves, sheep, and - to feed your sheep - some grass.  Running and plotting your final result could look something like the plot below.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"(Image: img)","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"As you can see, in this model, the wolves unfortunately died out :(.","category":"page"},{"location":"lecture_02/lab/#Creating-the-world","page":"Lab","title":"Creating the world","text":"","category":"section"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"To get started we need a type hierarchy. In order to be able to extend this model in later labs we will create an AbstractAgent that acts as the root of our tree. All animals and plants will be subtypes of AbstractAgent (it is a good convention to start the name of an abstract type with Abstract...). There are different kinds of animals and plants so it makes sense to create an AbstractAnimal type which will be the supertype of all animals. The same is true for AbstractPlants:","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"abstract type AbstractAgent end\nabstract type AbstractAnimal <: AbstractAgent end\nabstract type AbstractPlant <: AbstractAgent end","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"The first concrete type we implement is the basis of life in our simulation and source of all energy: Grass. Our Grass will be growing over time and it will need a certain amount of time steps to fully grow before it can be eaten. This has to be reflected in the fields of our grass struct:","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"mutable struct Grass <: AbstractPlant\n    fully_grown::Bool\n    regrowth_time::Int\n    countdown::Int\nend\n# constructor for grass with random growth countdown\nGrass(t) = Grass(false, t, rand(1:t))","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Note that Grass is a subtype of AbstractPlant. Let us assume that all plants have at least the fields fully_grown, regrowth_time, and countdown, because all plants need some time to grow. If this is the case we can define a common interface for all AbstractPlants.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"# get field values\nfully_grown(a::AbstractPlant) = a.fully_grown\ncountdown(a::AbstractPlant) = a.countdown\n\n# set field values\n# (exclamation marks `!` indicate that the function is mutating its arguments)\nfully_grown!(a::AbstractPlant, b::Bool) = a.fully_grown = b\ncountdown!(a::AbstractPlant, c::Int) = a.countdown = c\nincr_countdown!(a::AbstractPlant, Δc::Int) = countdown!(a, countdown(a)+Δc)\n\n# reset plant couter once its grown\nreset!(a::AbstractPlant) = a.countdown = a.regrowth_time","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Grass cannot grow in a void, hence we need a World.  In our simple case this world will just be a container for all our agents.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Define a World struct that will hold all your AbstractAgents in a Vector called agents. Try to avoid fields with abstract types. Julia's compiler will not be able to infer the type for those (which leads to type instabilities and performance losses; see the composite types section in the lecture).","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"struct World{T<:AbstractAgent}\n    agents::Vector{T}\nend\n\n# if you want you can overload the `show` method to get custom printing of your World\nfunction Base.show(io::IO, w::World)\n    println(io, typeof(w))\n    map(a->println(io,\"  $a\"),w.agents)\nend","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Now you should be able to create a world some grass in it that will soon be eaten by sheep:","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"grass = Grass(5)\nworld = World([grass])","category":"page"},{"location":"lecture_02/lab/#Sheep-eat-grass","page":"Lab","title":"Sheep eat grass","text":"","category":"section"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Our simulated Sheep will have a certain amount of energy E, a reproduction probability p_r, and a probablity to find food p_f in each iteration of our simulation. Additionally, each sheep with get a certain amout of energy Delta E from eating a Grass. The corresponding struct then looks like this","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"mutable struct Sheep{T<:Real} <: AbstractAnimal\n    energy::T\n    Δenergy::T\n    reproduction_prob::T\n    food_prob::T\nend","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Again we will use Sheep as a generic example for an AbstractAnimal which leaves us with the interface below. We only have setters for energy because all other fields of our animals will stay constant.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"# get field values\nenergy(a::AbstractAnimal) = a.energy\nΔenergy(a::AbstractAnimal) = a.Δenergy\nreproduction_prob(a::AbstractAnimal) = a.reproduction_prob\nfood_prob(a::AbstractAnimal) = a.food_prob\n\n# set field values\nenergy!(a::AbstractAnimal, e) = a.energy = e\nincr_energy!(a::AbstractAnimal, Δe) = energy!(a, energy(a)+Δe)","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"In every iteration of the simulation each sheep will get a chance to eat some grass. The process of one animal eating a plant (or another animal) will be implemented via the eat!(a::AbstractAgent,b::AbstractAgent,::World) function. Calling the function will cause agent a to eat agent b, possibly mutating them and the world. The eat! function will do something different for different input types and is our first practical example of multiple dispatch. The eat! function is part of our interface and we will have to implement a special methods for each new type that we introduce.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Implement a function eat!(::Sheep, ::Grass, ::World) which increases the sheep's energy by Delta E and sets fully_grown of the grass to false.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"function eat!(sheep::Sheep, grass::Grass, w::World)\n    if fully_grown(grass)\n        fully_grown!(grass, false)\n        incr_energy!(sheep, Δenergy(sheep))\n    end\nend","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Below you can see how a fully grown grass is eaten by a sheep.  The sheep's energy changes and the fully_grown field of the grass becomes false.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"grass = Grass(true,5.0,5.0);\nsheep = Sheep(10.0,5.0,0.1,0.1);\nworld = World([grass, sheep])\neat!(sheep,grass,world);\nworld","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Note that the order of the arguments has a meaning here. Calling eat!(grass,sheep,world) results in a MethodError which is great, because Grass cannot eat Sheep.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"grass = Grass(true,5.0,5.0);     # hide\nsheep = Sheep(10.0,5.0,0.1,0.1); # hide\nworld = World([grass, sheep]);   # hide\neat!(grass,sheep,world);","category":"page"},{"location":"lecture_02/lab/#Wolves-eat-sheep","page":"Lab","title":"Wolves eat sheep","text":"","category":"section"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Next, implement a Wolf with the same properties as the sheep (E, Delta E, p_r, and p_f) as well as the correspoding eat! method which increases the wolf's energy and kills the sheep (i.e. removes the sheep from the world).","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Hint: You can use findall and deleteat! to remove agents from your world.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"mutable struct Wolf{T<:Real} <: AbstractAnimal\n    energy::T\n    Δenergy::T\n    reproduction_prob::T\n    food_prob::T\nend\n\nfunction eat!(wolf::Wolf, sheep::Sheep, w::World)\n    kill_agent!(sheep,w)\n    incr_energy!(wolf, Δenergy(wolf))\nend\n\nkill_agent!(a::AbstractAnimal, w::World) = deleteat!(w.agents, findall(x->x==a, w.agents))","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"With a correct eat! method you should get results like this:","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"grass = Grass(true,5.0,5.0);\nsheep = Sheep(10.0,5.0,0.1,0.1);\nwolf  = Wolf(20.0,10.0,0.1,0.1);\nworld = World([grass, sheep, wolf])\neat!(wolf,sheep,world);\nworld","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"The sheep is removed from the world and the wolf's energy increased by Delta E.","category":"page"},{"location":"lecture_02/lab/#Finding-food-for-sheep","page":"Lab","title":"Finding food for sheep","text":"","category":"section"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"The next mechanism in our simulation models an animal's search for food.  For example, a sheep can only try to eat if the world currently holds some grass. The process of finding food for a given animal will be implemented by the function find_food(a::AbstractAnimal, ::World). This function will either return nothing or another animal that can be eaten by a with the given food probability p_f.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Implement the method find_food(::Sheep, ::World) which returns either a Grass (sampled randomly from all Grasses with the given food probability p_f) or returns nothing.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Hint: You can use StatsBase.sample to choose a random element from a vector.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"function find_food(a::Sheep, w::World)\n    if rand() <= food_prob(a)\n        as = filter(x->isa(x,Grass), w.agents)\n        isempty(as) ? nothing : sample(as)\n    end\nend","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"To test your function your can create sheep with different p_f. A sheep with p_f=1 will always find some food if there is some in the world, so you should get a result like below.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"grass = Grass(true,5.0,5.0);\nsheep = Sheep(10.0,5.0,1.0,1.0);\nwolf  = Wolf(20.0,10.0,1.0,1.0);\nworld = World([grass, sheep, wolf]);\n\ndinner = find_food(sheep,world)\neat!(sheep,dinner,world);\nsheep","category":"page"},{"location":"lecture_02/lab/#Finding-food-for-wolves","page":"Lab","title":"Finding food for wolves","text":"","category":"section"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Implement a function find_food(::Wolf, ::World) which returns either a Sheep (with the given food probability p_f) or returns nothing.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"function find_food(a::Wolf, w::World)\n    if rand() <= food_prob(a)\n        as = filter(x->isa(x,Sheep), w.agents)\n        isempty(as) ? nothing : sample(as)\n    end\nend","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_02/lab/#General-food-finding","page":"Lab","title":"General food finding","text":"","category":"section"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Identify the code duplications between find_food(::Sheep,::World) and find_food(::Wolf,::World) and generalize the function to find_food(::AbstractAnimal, ::World)","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"function find_food(a::AbstractAnimal, w::World)\n    if rand() <= food_prob(a)\n        as = filter(x->eats(a,x), w.agents)\n        isempty(as) ? nothing : sample(as)\n    end\nend\n\neats(::Sheep,::Grass) = true\neats(::Wolf,::Sheep) = true\neats(::AbstractAgent,::AbstractAgent) = false","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"lecture_02/lab/#Eating-nothing","page":"Lab","title":"Eating nothing","text":"","category":"section"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"<div class=\"admonition is-category-exercise\">\n<header class=\"admonition-header\">Exercise</header>\n<div class=\"admonition-body\">","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"What happens if you call eat!(wolf, find_food(wolf,world), world) and there are no sheep anymore? Or if the wolf's p_f1?","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Write a simple for-loop that runs 7 iterations of a simple simulation that lets a wolf eat one sheep in each iteration with this given world:","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"sheep = [Sheep(10.0,5.0,1.0,1.0) for _ in 1:5]\nwolf  = Wolf(20.0,10.0,1.0,0.0)\nworld = World(vcat(sheep, [wolf]))","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"Hint: You can try to overload the eat! function appropriately.","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</div></div>\n<details class = \"solution-body\">\n<summary class = \"solution-header\">Solution:</summary><p>","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"# make sure any animal can also eat `nothing`\neat!(a::AbstractAnimal,b::Nothing,w::World) = nothing\n\nfor _ in 1:10\n    dinner = find_food(wolf,world)\n    eat!(wolf,dinner,world)\nend","category":"page"},{"location":"lecture_02/lab/","page":"Lab","title":"Lab","text":"</p></details>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<img class=\"docs-light-only\"; src=\"https://raw.githubusercontent.com/JuliaTeachingCTU/JuliaCTUGraphics/master/logo/Scientific-Programming-in-Julia-logo.svg\"; alt=\"Scientific Programming in Julia logo\"; max-width: 100%; height: auto>\n<img class=\"docs-dark-only\"; src=\"https://raw.githubusercontent.com/JuliaTeachingCTU/JuliaCTUGraphics/master/logo/Scientific-Programming-in-Julia-logo-dark.svg\"; alt=\"Scientific Programming in Julia logo\"; max-width: 100%; height: auto;>","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Plots\nENV[\"GKSwstype\"] = \"100\"\ngr()","category":"page"},{"location":"","page":"Home","title":"Home","text":"Welcome to our course Scientific Programming in Julia.","category":"page"},{"location":"#Information-about-the-course","page":"Home","title":"Information about the course","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Teachers: Tomáš Pevný and Vašek Šmídl\nLabs: Niklas Heim and Jan Franců\nCredits: 4\nFormat: 2+2\nEnrollment: search code XXX in KOS\nRequirements for the course:\nHomeworks (after every lab)\nFinal project on a topic agreed with the lecturers\nGrading: 60% final project defended at exam and 40% homework \nLocation: TBD","category":"page"},{"location":"","page":"Home","title":"Home","text":"Some homeworks are harder than others, so each of them is rewarded with a different amount of points:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Homework 1 2 3 4 5 6 7 8 9 10 11 12 13\nPoints - 2 - - - - - - - - - - -","category":"page"},{"location":"#What-will-we-emphasize?-/-What-will-you-learn?","page":"Home","title":"What will we emphasize? / What will you learn?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The main goals of the course are the following: (make it longer? Split into two.)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Think in Julia.\nWrite extensible and reusable code.\nDig deeper into your code with debugging and introspection\nAutomatic Differentiation (AD) from scratch - the backbone of modern machine learning.\nExperience the power of code composability with Neural Ordinary Differential Equations - NeuralODEs.","category":"page"},{"location":"#Recommended-courses","page":"Home","title":"Recommended courses","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia for Optimization and Learning - bachelor course on Julia, which we recommend for beginners before enrolling to this course\nFunctional Programming - TODO fill in the url","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Official documentation\nThink Julia: How to Think Like a Computer Scientist\nFrom Zero to Julia!\nWikiBooks","category":"page"}]
}
