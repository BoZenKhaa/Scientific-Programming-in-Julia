<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lecture · Scientific Programming in Julia</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://JuliaTeachingCTU.github.io/Scientific-Programming-in-Julia/lecture_02/lecture/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Scientific Programming in Julia logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Scientific Programming in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scientific Programming in Julia</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation/">Installation</a></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">1: Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/motivation/">Motivation</a></li><li><a class="tocitem" href="../../lecture_01/basics/">Basics</a></li><li><a class="tocitem" href="../../lecture_01/demo/">Examples</a></li><li><a class="tocitem" href="../../lecture_01/outline/">Outline</a></li><li><a class="tocitem" href="../../lecture_01/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_01/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">2: The power of Type System &amp; multiple dispatch</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Lecture</a><ul class="internal"><li><a class="tocitem" href="#Structuring-the-code"><span>Structuring the code</span></a></li><li><a class="tocitem" href="#Intention-of-use-and-restrictions-on-compilers"><span>Intention of use and restrictions on compilers</span></a></li><li class="toplevel"><a class="tocitem" href="#The-type-system"><span>The type system</span></a></li><li><a class="tocitem" href="#Julia-is-dynamicaly-typed"><span>Julia is dynamicaly typed</span></a></li><li><a class="tocitem" href="#Types-of-types"><span>Types of types</span></a></li><li><a class="tocitem" href="#How-types-are-used-in-function-definitions"><span>How types are used in function definitions</span></a></li></ul></li><li><a class="tocitem" href="../lab/">Lab</a></li><li><a class="tocitem" href="../hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">3: Design patterns</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_03/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_03/lab/">Lab</a></li><li><a class="tocitem" href="../../lecture_03/hw/">Homework</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">4: Packages development, environments, etc...</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_04/lecture/">Lecture</a></li><li><a class="tocitem" href="../../lecture_04/lab/">Lab</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-7" type="checkbox"/><label class="tocitem" for="menuitem-7"><span class="docs-label">5: Benchmarking, profiling, and performance gotchas</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_05/lecture/">Lecture</a></li></ul></li><li><span class="tocitem">6: Language introspection</span></li><li><input class="collapse-toggle" id="menuitem-9" type="checkbox"/><label class="tocitem" for="menuitem-9"><span class="docs-label">7: Macros</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/lecture/">Lecture</a></li></ul></li><li><span class="tocitem">8: Introduction to automatic differentiation</span></li><li><span class="tocitem">9: Manipulating intermediate representation</span></li><li><span class="tocitem">10: Different levels of parallel programming</span></li><li><span class="tocitem">11: Julia for GPU programming</span></li><li><span class="tocitem">12: Uncertainty propagation in ODE</span></li><li><span class="tocitem">13: Learning ODE from data</span></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">2: The power of Type System &amp; multiple dispatch</a></li><li class="is-active"><a href>Lecture</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lecture</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaTeachingCTU/Scientific-Programming-in-Julia/blob/master/docs/src/lecture_02/lecture.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="type_lecture"><a class="docs-heading-anchor" href="#type_lecture">Motivation</a><a id="type_lecture-1"></a><a class="docs-heading-anchor-permalink" href="#type_lecture" title="Permalink"></a></h1><p>Before going into details about Julia type system, we spent few minutes motivating the two main role of type system, which is (i) structuring the code and (ii) and communicating to the compiler your intentions how the type will be used. The first aspect is important for the convenience of programmer and possible abstraction in the language, the latter aspect is important for the speed of generated code.</p><p>What Wikipedia tells about type and type system?</p><p><em>In computer science and computer programming, a <strong>data type</strong> or simply <strong>type</strong> is an attribute of data which tells the compiler or interpreter how the programmer intends to use the data (see <img src="https://en.wikipedia.org/wiki/Data_type]" alt="wiki"/>).</em></p><p><em>A <strong>type system</strong> is a logical system comprising a set of rules that assigns a property called a type to the various constructs of a computer program, such as variables, expressions, functions or modules. These types formalize and enforce the otherwise implicit categories the programmer uses for algebraic data types, data structures, or other components (see <img src="https://en.wikipedia.org/wiki/Type_system]" alt="wiki"/>).</em></p><h2 id="Structuring-the-code"><a class="docs-heading-anchor" href="#Structuring-the-code">Structuring the code</a><a id="Structuring-the-code-1"></a><a class="docs-heading-anchor-permalink" href="#Structuring-the-code" title="Permalink"></a></h2><p>The main role is therefore aiding help to <strong>structure</strong> the code and impose semantic restriction. Consider for example two types with the same definition but different names.</p><pre><code class="language-julia hljs">struct Wolf
	name::String
  energy::Int
end

struct Sheep
	name::String
  energy::Int
end</code></pre><p>This allows us to define functions applicable only to the corresponding type</p><pre><code class="language-julia hljs">howl(wolf::Wolf) = println(wolf.name, &quot; has howled.&quot;)
baa(sheep::Sheep) = println(sheep.name, &quot; has baaed.&quot;)</code></pre><p>Therefore the compiler (or interpretter) <strong>enforces</strong> that wolf can only <code>howl</code> and never <code>baa</code> and vice versa sheep can only <code>baa</code>. In this sense, it ensures that <code>howl(sheep)</code> and <code>baa(wolf)</code> never happen. For a comparison, consider alternative definition as follows</p><pre><code class="language-julia hljs">bark(animal) = println(animal.name, &quot; has howled.&quot;)
baa(animal)  = println(animal.name, &quot; has baaed.&quot;)</code></pre><p>in which case the burden of ensuring that wolf will not baa rest upon the programmer which will inevitably lead to errors.</p><h2 id="Intention-of-use-and-restrictions-on-compilers"><a class="docs-heading-anchor" href="#Intention-of-use-and-restrictions-on-compilers">Intention of use and restrictions on compilers</a><a id="Intention-of-use-and-restrictions-on-compilers-1"></a><a class="docs-heading-anchor-permalink" href="#Intention-of-use-and-restrictions-on-compilers" title="Permalink"></a></h2><p>The <em>intention of use</em> in types is related to how efficient code can compiler produce for that given intention. As an example, consider a following two alternatives to represent a set of animals:</p><pre><code class="language-julia hljs">a = [Wolf(&quot;1&quot;, 1), Wolf(&quot;2&quot;, 2), Sheep(&quot;3&quot;, 3)]
b = (Wolf(&quot;1&quot;, 1), Wolf(&quot;2&quot;, 2), Sheep(&quot;3&quot;, 3))</code></pre><p>and define a function to sum energy of all animals as</p><pre><code class="language-julia hljs">energy(animals) = mapreduce(x -&gt; x.energy, +, animals)</code></pre><p>Inspecting the compiled code using</p><pre><code class="language-julia hljs">@code_native energy(a)
@code_native energy(b)</code></pre><p>one observes the second version produces more optimal code. Why is that?</p><ul><li>In the first representation, <code>a</code>, animals are stored in <code>Array</code> which can have arbitrary size and can contain arbitrary animals. This means that compiler has to compile <code>energy(a)</code> such that it works on such arrays.</li><li>In the second representation, <code>b</code>, animals are stored in <code>Tuple</code>, which specializes for lengths and types of items. This means that the compiler knows the number of animals and the type of each animal on each position within the tuple, which allows him to specialize.</li></ul><p>This difference will indeed have an impact on the time of code execution. On my i5-8279U CPU, the difference (as measured by BenchmarkTools) is</p><pre><code class="language-julia hljs">using BenchmarkTools
@btime energy(a);
@btime energy(b);
nothing #hide</code></pre><p>Which nicely demonstrates that smart choice of types can greatly affect the performance. Does it mean that we should always use <code>Tuples</code> instead of <code>Arrays</code>? Surely not, it is just that each is better for different use-case. Using Tuples means that compiler will compile special function for each tuple it observes, which is clearly wasteful.</p><h1 id="The-type-system"><a class="docs-heading-anchor" href="#The-type-system">The type system</a><a id="The-type-system-1"></a><a class="docs-heading-anchor-permalink" href="#The-type-system" title="Permalink"></a></h1><h2 id="Julia-is-dynamicaly-typed"><a class="docs-heading-anchor" href="#Julia-is-dynamicaly-typed">Julia is dynamicaly typed</a><a id="Julia-is-dynamicaly-typed-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-is-dynamicaly-typed" title="Permalink"></a></h2><p>Julia&#39;s type system is dynamic, which means that all types are resolved during runtime. <strong>But</strong>, if the compiler can infer types of all variables of a function, it can specialize the function for that given type of variables which lead to an efficient code. Consider a modified example where we represent two wolfpacks:</p><pre><code class="language-julia hljs">wolfpack_a =  [Wolf(&quot;1&quot;, 1), Wolf(&quot;2&quot;, 2), Wolf(&quot;3&quot;, 3)]
wolfpack_b =  Any[Wolf(&quot;1&quot;, 1), Wolf(&quot;2&quot;, 2), Wolf(&quot;3&quot;, 3)]</code></pre><p><code>wolfpack_a</code> carries a type <code>Vector{Wolf}</code> while <code>wolfpack_b</code> has a type <code>Vector{Any}</code>. This means that in the first case, the compiler know that all items are of the type <code>Wolf</code> and it can specialize functions using this information. In case of <code>wolfpack_b</code>, he does not know which animal he will encounter (although all are of the same type), and therefore it needs to dynamically resolve the type of each item upon its use. This ultimately leads to less performant code.</p><pre><code class="language-julia hljs">@btime energy(wolfpack_a)
@btime energy(wolfpack_b)</code></pre><p>To conclude, julia is indeed dynamically typed language, <strong>but</strong> if the compiler can infer all types in called function in advance, it does not have to perform a type resolution during execution, which produces a performant code.</p><h2 id="Types-of-types"><a class="docs-heading-anchor" href="#Types-of-types">Types of types</a><a id="Types-of-types-1"></a><a class="docs-heading-anchor-permalink" href="#Types-of-types" title="Permalink"></a></h2><p>Julia divides types into three classes: primitive, composite, and abstract.</p><h3 id="Primitive-types"><a class="docs-heading-anchor" href="#Primitive-types">Primitive types</a><a id="Primitive-types-1"></a><a class="docs-heading-anchor-permalink" href="#Primitive-types" title="Permalink"></a></h3><p>Citing the <img src="https://docs.julialang.org/en/v1/manual/types/#Primitive-Types" alt="documentation"/>: <em>A primitive type is a concrete type whose data consists of plain old bits. Classic examples of primitive types are integers and floating-point values. Unlike most languages, Julia lets you declare your own primitive types, rather than providing only a fixed set of built-in ones. In fact, the standard primitive types are all defined in the language itself.</em></p><p>The definition of primitive types look as follows</p><pre><code class="language-julia hljs">primitive type Float16 &lt;: AbstractFloat 16 end
primitive type Float32 &lt;: AbstractFloat 32 end
primitive type Float64 &lt;: AbstractFloat 64 end</code></pre><p>and they are mainly used to jump-start julia&#39;s type system. It rarely make a sense to define a special primitive type, as it make sense only if you define special functions operating on its bits, which makes mostly sense if you want to expose special operations provided by underlying CPU / LLVM compiler. For example <code>+</code> for <code>Int32</code> is different from <code>+</code> for <code>Float32</code> as they call a different intrinsic operation. You can inspect this jump-starting of type system by yourself by inspecting Julia&#39;s source.</p><pre><code class="language-julia hljs">julia&gt; @which +(1,2)
+(x::T, y::T) where T&lt;:Union{Int128, Int16, Int32, Int64, Int8, UInt128, UInt16, UInt32, UInt64, UInt8} in Base at int.jl:87</code></pre><p>At <code>int.jl:87</code></p><pre><code class="language-julia hljs">(+)(x::T, y::T) where {T&lt;:BitInteger} = add_int(x, y)</code></pre><p>we seen that <code>+</code> of integers is calling function <code>add_int(x, y)</code>, which is defined in a core part of the compiler in <code>Intrinsics.cpp</code> (yes, in C++).</p><p>From Julia docs: <em>Core is the module that contains all identifiers considered &quot;built in&quot; to the language, i.e. part of the core language and not libraries. Every module implicitly specifies using Core, since you can&#39;t do anything without those definitions.</em></p><p>Primitive types are rarely used, and they will not be used in this course. We mention them for the sake of completness and refer reader to the official Documentation (and source code of Julia).</p><h3 id="composite_types"><a class="docs-heading-anchor" href="#composite_types">Composite types</a><a id="composite_types-1"></a><a class="docs-heading-anchor-permalink" href="#composite_types" title="Permalink"></a></h3><p>The composite types are similar to <code>struct</code> in C (they even have the same memory layout). It is not a great idea to think about them as objects (in OOP sense), because objects tie together <em>data</em> and <em>functions</em> over owned data. Contrary in Julia (as in C), the function operates over data, but are not tied to them. Composite types are a workhorses of Julia&#39;s type system, as most user-defined types are composite.</p><p>The composite type is defined as</p><pre><code class="language-julia hljs">struct PositionF64
  x::Float64
  y::Float64
end</code></pre><p>which defines a structure with two fields <code>x</code> and <code>y</code> of type <code>Float64</code>. Julia compiler creates a default constructor, where both (but generally all) arguments are converted using <code>(convert(Float64, x), convert(Float64, y)</code> to the correct type. This means that we can construct a PositionF64 with numbers of different type that are convertable to Float64, e.g. <code>PositionF64(1,1//2)</code> but we cannot construct <code>PositionF64</code> where fields would be of different type (e.g. <code>Int</code>, <code>Float32</code>, etc.).</p><p>Composite types do not have to have a specified type, e.g.</p><pre><code class="language-julia hljs">struct VaguePosition
  x
  y
end</code></pre><p>which would work as the definition above and allows to store different values in <code>x</code>, for example <code>String</code>. But it would limit compiler&#39;s ability to specialize, which can have a negative impact on the performance. For example</p><pre><code class="language-julia hljs">using BenchmarkTools
move(a::T, b::T) where {T} = T(a.x + b.x, a.y + b.y)
x = [PositionF64(rand(), rand()) for _ in 1:100]
y = [VaguePosition(rand(), rand()) for _ in 1:100]
@btime reduce(move, x);
@btime reduce(move, y);
nothing #hide</code></pre><p>The same holds if the Composite type contains field with AbstractType, for example</p><pre><code class="language-julia hljs">struct LessVaguePosition
  x::Real
  y::Real
end
z = [LessVaguePosition(rand(), rand()) for _ in 1:100];
@btime reduce(move, z);
nothing #hide</code></pre><p>While from the perspective of generating optimal code, both definitions are equally informative to the compiler as it cannot assume anything about the code, the <code>LessVaguePosition</code> will ensure that the position will contain only numbers, hence catching trivial errors like instantiating <code>VaguePosition</code> with non-numeric types for which arithmetic operators will not be defined (recall the discussion on the beggining) of the lecture.</p><p>A recommended way to have <strong>flexibility</strong> in definitions of the type while being able to generate optimal code is a <strong>parametrization</strong> of the type definition. This is achieved by replacing types with a some variable (typically a single uppercase character) and decorating in definition by specifying different type in curly brackets. For example</p><pre><code class="language-julia hljs">struct PositionT{T}
  x::T
  y::T
end
u = [PositionT(rand(), rand()) for _ in 1:100];
@btime reduce(move, u);
nothing #hide</code></pre><p>Notice that the compiler can take advantage of specializing for differen types (which does not have effect as in modern processrs have addition of Float and Int takes the same time).</p><pre><code class="language-julia hljs">v = [PositionT(rand(1:100), rand(1:100)) for _ in 1:100];
@btime reduce(move, v);
nothing #hide</code></pre><p>The above definition suffers the same problem as <code>VaguePosition</code>, which is that it allows us to instantiate the <code>PositionT</code> with non-numeric types, e.g. <code>String</code>. We can resolve this by restricting the types <code>T</code> can attain as</p><pre><code class="language-julia hljs">struct Position{T&lt;:Real}
  x::T
  y::T
end</code></pre><p>which will throw error if we try to initialize it with <code>Position(&quot;1.0&quot;, &quot;2.0&quot;)</code>.</p><p>All structs defined above are immutable (as we have seen above in the case of <code>Tuple</code>), which means that one cannot change a field (unless the struct wraps a container, like and array, which allows that). For example this raises an error</p><pre><code class="language-julia hljs">a = Position(1, 2)
a.x = 2</code></pre><p>If one needs to make a struct mutable, use the keyword <code>mutable</code> as follows</p><pre><code class="language-julia hljs">mutable struct MutablePosition{T}
  x::T
  y::T
end

a = MutablePosition(1e0, 2e0)
a.x = 2</code></pre><p>but there might be performance penalty in some cases (not observable at this simple demo).</p><h3 id="Abstract-Type"><a class="docs-heading-anchor" href="#Abstract-Type">Abstract Type</a><a id="Abstract-Type-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Type" title="Permalink"></a></h3><p>(<img src="https://docs.julialang.org/en/v1/manual/types/#man-abstract-types" alt="Julia documentation"/>) Abstract types cannot be instantiated, which means that we cannot create a variable that would have an abstract type (try <code>typeof(Number(1f0))</code>). Also, Abstract types cannot have any fields, therefore there is no composition (there are lengty discussions of why this is so, one of the most definite arguments of creators is that Abstrat types with fields frequently lead to children types not using some fields (consider circle vs. ellipse)).</p><p>The most important use of abstract type is for structuring the code and defining general functions (called methods) over semantically similar entities with different implementation.</p><p>An abstract types are defined by preceding a definition of a type (declared using <code>struct</code> keyword) with a keyword <code>abstract</code>. For example following set of abstract types defines part of julia&#39;s number systems.</p><pre><code class="language-julia hljs">abstract type Number end
abstract type Real     &lt;: Number end
abstract type AbstractFloat &lt;: Real end
abstract type Integer  &lt;: Real end
abstract type Signed   &lt;: Integer end
abstract type Unsigned &lt;: Integer end</code></pre><p>The <code>&lt;:</code> means &quot;is a subtype of&quot; and it is used in declarations where the right-hand is an immediate sypertype of a given type (<code>Integer</code> has an immediate supertype <code>Real</code>.) The abstract type <code>Number</code> is derived from <code>Any</code> which is a default supertype of any type (this means all subtypes are derived from <code>Any</code>).</p><p>The type hiearchy is used for defining general functions, that are known to provide a correct output on all subtypes of a given abstract type. For example a <code>sgn</code> function can be defined for <strong>all</strong> real numbers as</p><pre><code class="language-julia hljs">sgn(x::Real) = x &gt; 0 ? 1 : x &lt; 0 ? -1 : 0</code></pre><p>and we know it would be correct for all real numbers. This means that if anyone creates a new subtype of <code>Real</code>, the above function can be used. This also means that <strong>it is expected</strong> that comparison operations are defined for any real numbers.</p><p>For unsigned numbers, the <code>sgn</code> can be simplified, as it is sufficient to verify if they are different (greated) then zeros, therefore the function can read</p><pre><code class="language-julia hljs">sgn(x::Unsigned) = Int(x &gt; 0)</code></pre><p>and again, it applies to all numbers derived from <code>Unsigned</code>. Recall that <code>Unsigned &lt;: Integer &lt;: Real,</code> how does Julia decides, which version of the function <code>sgn</code> to use for <code>UInt8(0)</code>? It chooses the most specific version, and therefore for <code>sgn(UInt8(0))</code> it will use <code>sgn(x::Unsinged)</code>. If the compiler cannot decide, typically it encounters an ambiguity, it throws an error and recommend which function you should define to resolve it.</p><p>The above behavior allows to define default &quot;fallback&quot; implementations and while allowing to specialize for sub-types. A usual example is a matrix multiplication, which has a generic (and slow) implementation with many specializations, which can take advantage of structure (sparse, banded), or of optimized implementations (e.g. blas implementation for dense matrices with eltype <code>Float32</code> and <code>Float64</code>).</p><p>Again, Julia does not make a difference between abstract types defined in <code>Base</code> libraries shipped with the language and those defined by you (the user). All are treated the same.</p><p>Like Composite types, Abstract types can have parameters. For example Julia defines an array of arbitrary dimension <code>N</code> and type <code>T</code> of its items as</p><pre><code class="language-julia hljs">abstract type AbstractArray{T,N} end</code></pre><p>Different <code>T</code> and <code>N</code> gives rise to different variants of <code>AbstractArrays</code>, therefore <code>AbstractArray{Float32,2}</code> is different from <code>AbstractArray{Float64,2}</code> and from <code>AbstractArray{Float64,1}.</code> Note that these are still <code>Abstract</code> types, which means you cannot instantiate them. They purpose is</p><ul><li>to allow to define operations for broad class of concrete types</li><li>to inform compiler about constant values, which can be used</li></ul><p>For convenience, you can name some important partially instantiated Abstract types, for example <code>AbstractVector</code> as</p><pre><code class="language-julia hljs">const AbstractVector{T} = AbstractArray{T,1}</code></pre><p>is defined in <code>array.jl:23</code> (in Julia 1.6.2), which allows us to define for example general prescription for <code>dot</code> product of two abstract vectors as</p><pre><code class="language-julia hljs">function dot(a::AbstractVector, b::AbstractVector)
  @assert length(a) == length(b)
  mapreduce(*, +, a, b)
end</code></pre><p>You can verify that the above general function can be compiled to a performant code if specialized for a particular arguments.</p><pre><code class="language-julia hljs">@code_native mapreduce(*,+, [1,2,3], [1,2,3])</code></pre><h2 id="How-types-are-used-in-function-definitions"><a class="docs-heading-anchor" href="#How-types-are-used-in-function-definitions">How types are used in function definitions</a><a id="How-types-are-used-in-function-definitions-1"></a><a class="docs-heading-anchor-permalink" href="#How-types-are-used-in-function-definitions" title="Permalink"></a></h2><h3 id="Terminology"><a class="docs-heading-anchor" href="#Terminology">Terminology</a><a id="Terminology-1"></a><a class="docs-heading-anchor-permalink" href="#Terminology" title="Permalink"></a></h3><ul><li>A <em>function</em> refers to a set of &quot;methods&quot; for a different</li></ul><p>combination of type parameters (a term function can be therefore considered as refering to a mere <strong>name</strong>). A <em>method</em> defining different behavior for different type of arguments are also called specializations. For example</p><pre><code class="language-julia hljs">move(a, b) = Position(a.x + b.x, a.y + b.y)
move(a::Position, b::Position) = Position(a.x + b.x, a.y + b.y)
move(a::Vector{&lt;:Position}, b::Vector{&lt;:Position}) = move.(a,b)</code></pre><p><code>move</code> refers to function, where <code>move(a::Position, b::Position)</code> and <code>move(a::Vector{&lt;:Position}, b::Vector{&lt;:Position})</code> are methods. When different behavior on different types is defined by a programmer, as shown above, we call about <em>implementation specialization</em>. There is another type of specialization, called <em>compiler specialization</em>, which occurs when the compiler generates different functions for you from a single method. For example for</p><pre><code class="language-julia hljs">move(Position(1,1), Position(2,2))
move(Position(1.0,1.0), Position(2.0,2.0))</code></pre><p>the compiler has to generate two methods, since in the first case it will be adding <code>Int64</code>s while in the latter it will be adding <code>Float64</code>s (and it needs to use different intrinsics, which you can check using <code>@code_native  move(Position(1,1), Position(2,2))</code> and <code>@code_native move(Position(1.0,1.0), Position(2.0,2.0))</code>).</p><pre><code class="language-julia hljs">### How Julia compiler works?</code></pre><p>Compiled function is a &quot;blob&quot; of <strong>native code</strong> living in a particular memory location. When Julia calls a function, it needs to pick a right block corresponding to a function with particular type of parameters. Calling a function involves therefore involves</p><ul><li>preparing parameters</li><li>finding a right block corresponding to a function with particular type of parameters.</li></ul><p>The process can be made during runtime (when code is executing) or during compile time (when code is compiled) and everything in between.</p><p>An interesting intermediate is called Union-Splitting, which happens when there is just a little bit of uncertainty. Julia will do something like</p><pre><code class="language-julia hljs">argtypes = typeof(args)
push!(execution_stack, args)
if T == Tuple{Int, Bool}
  @goto compiled_blob_1234
else # the only other option is Tuple{Float64, Bool}
  @goto compiled_blob_1236
end</code></pre><p>Example: Consider following definitions</p><pre><code class="language-julia hljs">move(a::Position, by::Position) = Position(a.x + by.x, a.y + by.y)
move(a::Vector{&lt;:Position}, by::Vector{&lt;:Position}) = move.(a, by)
move(a::Vector{&lt;:Position}, by::Position) = move.(a, by)</code></pre><p>and function call</p><pre><code class="language-julia hljs">a = Position(1.0, 1.0)
by = Position(2.0, 2.0)
move(a, by)</code></pre><ol><li>The compiler knows that you want to call function <code>move</code></li><li>The compiler tries to infer type of arguments, the result can be viewed using <code>typeof(a)</code> / <code>typef(b)</code></li><li>The compiler looks of he has already specialized (compiled) a version of <code>move</code> for give  types of parameters.</li></ol><p>4a. If the method has been specialized, it is called adter arguments are prepared. 4b. If the method has not been specialized, the compiler find a method instance corresponding     to type of parameters, compile it (and cache with all method instances called witihn this     method), and execute it. If the compiler determines that the arguments are abstract, it has to perform the above procedure within the function, which has negative effect on the performance, as the above procedure can be slow, especially for methods with many arguments (e.g. 30ns for a method with one argument, 100 ns for method with two arguements).</p><p>In the above process, the step, where Julia looks for a method instance with corresponding parameters can be very confusing. The rest of this lecture will focus on this. For those who want to know more, we recommend !(talk of  Francesco Zappa Nardelli)[https://www.youtube.com/watch?v=Y95fAipREHQ] and / or the talk of !(Jan Vitek)[https://www.youtube.com/watch?v=LT4AP7CUMAw].</p><p>When Julia needs to specialize a method instance, in needs to find it among multiple definitions. A single function can have many method instances, see for example <code>methods(+)</code> which lists all methods instances of <code>+</code> function. How Julia select the proper one?</p><ol><li>It finds all methods where type of arguments match or are subtypes of restrictions on arguments in the method definition.</li><li>If there are multiple matches, the compiler selects the most specific definition.</li><li>If the compiler cannot decide, which method instance to choose, it throws an error.</li></ol><p>Finding method instances for current  a  can be very confusing, especially for begginers, as there are some confusing behaviors.</p><h3 id="Frequent-problems"><a class="docs-heading-anchor" href="#Frequent-problems">Frequent problems</a><a id="Frequent-problems-1"></a><a class="docs-heading-anchor-permalink" href="#Frequent-problems" title="Permalink"></a></h3><ol><li><strong>Why the following fails?</strong></li></ol><pre><code class="language-julia hljs">foo(a::Vector{Real}) = println(&quot;Vector{Real}&quot;)
foo([1.0,2,3])</code></pre><p>Julia&#39;s type system is <strong>invariant</strong>, which means that <code>Vector{Real}</code> is different from <code>Vector{Float64}</code> and from <code>Vector{Float32}</code>, even though <code>Float64</code> and <code>Float32</code> are sub-types of <code>Real</code>. Therefore <code>typeof([1.0,2,3])</code> isa <code>Vector{Float64}</code> which is not subtype of <code>Vector{Real}.</code> For <strong>covariant</strong> languages, this would be true. For more information on variance in computer languages, see !()[https://en.wikipedia.org/wiki/Covariance<em>and</em>contravariance<em>(computer</em>science)]. If de above definition of <code>foo</code> should be applicable to all vectors which has elements of subtype of <code>Real</code> we have define it as</p><pre><code class="language-julia hljs">foo(a::Vector{T}) where {T&lt;:Real} = println(&quot;Vector{T} where {T&lt;:Real}&quot;)</code></pre><p>or equivalently but more tersely as</p><pre><code class="language-julia hljs">foo(a::Vector{&lt;:Real}) = println(&quot;Vector{T} where {T&lt;:Real}&quot;)</code></pre><ol><li><strong>Diagonal rule</strong></li></ol><p>rule says that the type repeat in method signature, it has to be a concrete type. Consider for example the function below</p><pre><code class="language-julia hljs">move(a::T, b::T) where {T&lt;:Position}</code></pre><p>we cannot call it with <code>move(Position(1.0,2.0), Position(1,2))</code>, since in this case <code>Position(1.0,2.0)</code> is of type <code>Position{Float64}</code> while <code>Position(1,2)</code> is of type <code>Position{Int64}</code>.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../lecture_01/hw/">« Homework</a><a class="docs-footer-nextpage" href="../lab/">Lab »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.6 on <span class="colophon-date" title="Sunday 3 October 2021 17:29">Sunday 3 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
