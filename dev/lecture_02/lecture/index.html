<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Lecture · Scientific Programming in Julia</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://JuliaTeachingCTU.github.io/Scientific-Programming-in-Julia/lecture_02/lecture/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Scientific Programming in Julia logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Scientific Programming in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Scientific Programming in Julia</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">1: Introduction</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_01/motivation/">Motivation</a></li><li><a class="tocitem" href="../../lecture_01/outline/">Outline</a></li><li><a class="tocitem" href="../../lecture_01/hw/">HOMEWORK</a></li><li><a class="tocitem" href="../../lecture_01/labs/">LABS</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">2: The power of Type System &amp; multiple dispatch</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Lecture</a><ul class="internal"><li><a class="tocitem" href="#Structuring-the-code"><span>Structuring the code</span></a></li><li><a class="tocitem" href="#Intention-of-use-and-restrictions-on-compilers"><span>Intention of use and restrictions on compilers</span></a></li><li class="toplevel"><a class="tocitem" href="#The-type-system"><span>The type system</span></a></li><li><a class="tocitem" href="#Julia-is-dynamicaly-typed"><span>Julia is dynamicaly typed</span></a></li><li><a class="tocitem" href="#Types-of-types"><span>Types of types</span></a></li><li><a class="tocitem" href="#Pevnak&#39;s-idea"><span>Pevnak&#39;s idea</span></a></li></ul></li><li><a class="tocitem" href="../lab/">Lab</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">3: Design patterns</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_03/lab/">Lab</a></li></ul></li><li><span class="tocitem">4: Packages development, environments, etc...</span></li><li><span class="tocitem">5: Benchmarking, profiling, and performance gotchas</span></li><li><span class="tocitem">6: Language introspection</span></li><li><input class="collapse-toggle" id="menuitem-8" type="checkbox"/><label class="tocitem" for="menuitem-8"><span class="docs-label">7: Macros</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lecture_07/macros/">Macros</a></li></ul></li><li><span class="tocitem">8: Introduction to automatic differentiation</span></li><li><span class="tocitem">9: Manipulating intermediate representation</span></li><li><span class="tocitem">10: Different levels of parallel programming</span></li><li><span class="tocitem">11: Julia for GPU programming</span></li><li><span class="tocitem">12: Uncertainty propagation in ODE</span></li><li><span class="tocitem">13: Learning ODE from data</span></li><li><a class="tocitem" href="../../how_to_submit_hw/">How to submit homeworks</a></li><li><a class="tocitem" href="../../howto/">How To ...</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">2: The power of Type System &amp; multiple dispatch</a></li><li class="is-active"><a href>Lecture</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Lecture</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaTeachingCTU/Scientific-Programming-in-Julia/blob/master/docs/src/lecture_02/lecture.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Motivation"><a class="docs-heading-anchor" href="#Motivation">Motivation</a><a id="Motivation-1"></a><a class="docs-heading-anchor-permalink" href="#Motivation" title="Permalink"></a></h1><p>Before going into details about Julia type system, we spent few minutes motivating the two main role of type system, which is (i) structuring the code and (ii) and communicating to the compiler your intentions how the type will be used. While the first aspect is very important for the convenience of programmer and possible abstraction in the language, the latter aspect is very important for speed. </p><p>What Wikipedia tells about type and type system?</p><p><em>In computer science and computer programming, a <strong>data type</strong> or simply <strong>type</strong> is an attribute of data which tells the compiler or interpreter how the programmer intends to use the data (see <img src="https://en.wikipedia.org/wiki/Data_type]" alt="wiki"/>).</em> </p><p><em>A <strong>type system</strong> is a logical system comprising a set of rules that assigns a property called a type to the various constructs of a computer program, such as variables, expressions, functions or modules. These types formalize and enforce the otherwise implicit categories the programmer uses for algebraic data types, data structures, or other components (see <img src="https://en.wikipedia.org/wiki/Type_system]" alt="wiki"/>).</em></p><h2 id="Structuring-the-code"><a class="docs-heading-anchor" href="#Structuring-the-code">Structuring the code</a><a id="Structuring-the-code-1"></a><a class="docs-heading-anchor-permalink" href="#Structuring-the-code" title="Permalink"></a></h2><p>The main role is therefore aiding help to <strong>structure</strong> the code and impose semantic restriction. Consider for example two types with the same definition but different names.</p><pre><code class="language-julia hljs">struct Dog
	name::String
end

struct Cat
	name::String
end</code></pre><p>This allows us to define functions applicable only to the corresponding type</p><pre><code class="language-julia hljs">bark(dog::Dog) = println(dog.name, &quot; has barked.&quot;)
meow(cat::Cat) = println(cat.name, &quot; have meowed.&quot;)</code></pre><p>and therefore the compiler (or interpretter) enforces that dog can only <code>bark</code> and never <code>meow</code> and vice versa can cat only <code>meow</code>. In this sense, it ensures that <code>bark(cat)</code> and <code>meow(dog)</code> never happen. Unlike if we define  those functions as </p><pre><code class="language-julia hljs">bark(dog::String) = println(dog.name, &quot; has barked.&quot;)
meow(cat::String) = println(cat.name, &quot; have meowed.&quot;)</code></pre><h2 id="Intention-of-use-and-restrictions-on-compilers"><a class="docs-heading-anchor" href="#Intention-of-use-and-restrictions-on-compilers">Intention of use and restrictions on compilers</a><a id="Intention-of-use-and-restrictions-on-compilers-1"></a><a class="docs-heading-anchor-permalink" href="#Intention-of-use-and-restrictions-on-compilers" title="Permalink"></a></h2><p>The <em>intention of use</em> in types is tightly related to how efficient code can compiler produce for that given intention. As an example, consider a following two variables <code>a</code> and <code>b</code> and function <code>inc</code> which increments the content by one and return the array.</p><pre><code class="language-julia hljs">a = [1, 2, 3]
b = (1, 2, 3)
inc(x) = x .+ 1</code></pre><p>The variable <code>a</code> is an array of <code>Int64</code>s, whereas <code>b</code> is a Tuple of <code>Int64</code>. Now if we look, how compiler compiles each version, you will see a striking difference</p><pre><code class="language-julia hljs">@code_native inc(a)
@code_native inc(b)</code></pre><p>On my i5-8279U CPU, the difference is visible in performance</p><pre><code class="language-julia hljs">using BenchmarkTools
julia&gt; @btime inc($(a));
  36.779 ns (1 allocation: 112 bytes)

julia&gt; @btime inc($(b));
  0.036 ns (0 allocations: 0 bytes)</code></pre><p>(as will be seen later, the difference in speed comes mainly from the memory allocation).  For fun you can also test the speed of not type stable code</p><pre><code class="language-julia hljs">c = Vector{Number}([1, 2, 3])
julia&gt; @btime inc($(c));
  865.304 ns (9 allocations: 464 bytes)</code></pre><p>Does it mean that we should always use <code>Tuples</code> instead of <code>Arrays</code>? Surely not, it is just that each is better for different use-case. Arrays allows us for example to reuse space, which Tuples do not permit. For example</p><pre><code class="language-julia hljs">inc!(x) = x .= x .+ 1</code></pre><p>will work for <code>a</code> but not for <code>b</code>, as Tuples are &quot;immutable&quot;. This gives the compiler freedom to allocate (typically on Stack), while arrays are (at the time of writing) allocated strinctly on heap (needless to say that non-allocating version <code>inc!</code> of <code>inc</code> is much faster).</p><h1 id="The-type-system"><a class="docs-heading-anchor" href="#The-type-system">The type system</a><a id="The-type-system-1"></a><a class="docs-heading-anchor-permalink" href="#The-type-system" title="Permalink"></a></h1><h2 id="Julia-is-dynamicaly-typed"><a class="docs-heading-anchor" href="#Julia-is-dynamicaly-typed">Julia is dynamicaly typed</a><a id="Julia-is-dynamicaly-typed-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-is-dynamicaly-typed" title="Permalink"></a></h2><p>Julia&#39;s type system is dynamic, which means that all types are resolved during runtime. But, if the compiler can infer type of all variables of a function, it can specialize it leading to a very efficient code. Consider again the above example</p><pre><code class="nohighlight hljs">a = [1,2,3]
c = Vector{Number}([1,2,3])
inc!(x) = x .= x .+ 1</code></pre><p>where in case of calling <code>inc(a)</code>, the compiler precisely knows types of items of <code>a</code> (all are <code>Int64</code>, which allow it to compile <code>inc(a)</code> for a vector if Integers. In case of <code>c</code>, the compiler does not know, what to expect, therefore he has to create a generic version of <code>inc</code> where for each item he has to decide the type. This way more complex leading to drop in performance</p><pre><code class="language-julia hljs">julia&gt; @btime inc!($(a))
  4.322 ns (0 allocations: 0 bytes)
julia&gt; @btime inc!($(c))
  132.294 ns (6 allocations: 96 bytes)  </code></pre><h2 id="Types-of-types"><a class="docs-heading-anchor" href="#Types-of-types">Types of types</a><a id="Types-of-types-1"></a><a class="docs-heading-anchor-permalink" href="#Types-of-types" title="Permalink"></a></h2><p>Julia divides types into three classes.</p><h3 id="Abstract-Type"><a class="docs-heading-anchor" href="#Abstract-Type">Abstract Type</a><a id="Abstract-Type-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Type" title="Permalink"></a></h3><p>(<img src="https://docs.julialang.org/en/v1/manual/types/#man-abstract-types" alt="Julia documentation"/>) Abstract types cannot be instantiated, which means that we cannot create a variable that would have an abstract type (try <code>typeof(Number(1f0))</code>). The most important use of abstract type is for structuring the code and defining general functions over semantically similar entities with different implementation. </p><p>An abstract type is define by preceding a definition of a type (declared using <code>struct</code> keyword) with a keyword <code>abstract</code>. For example following set of abstract types defines the part number system in julia.</p><pre><code class="language-julia hljs">abstract type Number end
abstract type Real     &lt;: Number end
abstract type AbstractFloat &lt;: Real end
abstract type Integer  &lt;: Real end
abstract type Signed   &lt;: Integer end
abstract type Unsigned &lt;: Integer end</code></pre><p>The &lt;: means &quot;is a subtype of&quot; and it is used in declarations where the right-hand is an immediate sypertype of a given type (<code>Integer</code> has an immediate supertype <code>Real</code>.) The abstract type <code>Number</code> is derived from <code>Any</code> which is a default supertype of any type (this means all subtypes are derived from <code>Any</code>).  </p><p>Recall the structure is used mainly for defining functions, that are known to provide a correct output on all subtypes of a given abstract type. Consider for example a <code>sgn</code> function, which can be defined as </p><pre><code class="language-julia hljs">sgn(x::Real) = x &gt; 0 ? 1 : x &lt; 0 ? -1 : 0
sgn(x::Unsigned) = Int(x &gt; 0)</code></pre><p>and where the first function is defined for any subtype of a real, where the latter is used for subtypes of Unsigned.</p><pre><code class="language-markdown hljs">!!! info &quot;Header&quot;

How does the julia decides which function to use when two possible function definitions are possible? For example `sgn(UInt8(0))` can call a definition `sgn(x::Real)` or a definition `sgn(x::Unsigned)`. The answer is that it chooses the most specific version, and therefore for `sgn(UInt8(0))` it takes `sgn(x::Unsinged)`. If the compiler cannot decide, it throws an error.</code></pre><p>A hierarchy of abstract types allows to define default implementation of some function over subtypes and specialize it for concrete types. A prime example is matrix multiplication, which has a generic implementation with many specializations for various types of matrices (sparse, dense, banded, etc.)</p><p>All abstract types, except <code>Any</code> are defined by core libraries. This means that Julia does not make a difference between abstract types that are shipped with the language and those defined by the user. All are treated the same.</p><p>Abstract types can have parameters, for we have for example </p><pre><code class="language-julia hljs">abstract struct AbstractArray{T,N} end</code></pre><p>which defines arrays of arbitrary dimentions with an element type <code>T</code>. Naturaly <code>AbstractArray{Float32,2}</code> is different from <code>AbstractArray{Float64,2}</code> and from <code>AbstractArray{Real,2}</code> (more on this later).</p><h3 id="Primitive-types"><a class="docs-heading-anchor" href="#Primitive-types">Primitive types</a><a id="Primitive-types-1"></a><a class="docs-heading-anchor-permalink" href="#Primitive-types" title="Permalink"></a></h3><p>Citing the <img src="https://docs.julialang.org/en/v1/manual/types/#Primitive-Types" alt="documentation"/>: <em>A primitive type is a concrete type whose data consists of plain old bits. Classic examples of primitive types are integers and floating-point values. Unlike most languages, Julia lets you declare your own primitive types, rather than providing only a fixed set of built-in ones. In fact, the standard primitive types are all defined in the language itself:</em></p><pre><code class="language-julia hljs">primitive type Float16 &lt;: AbstractFloat 16 end
primitive type Float32 &lt;: AbstractFloat 32 end
primitive type Float64 &lt;: AbstractFloat 64 end</code></pre><p>We refer the reader to the original documentation, as we will not use them. They are mentioned to assure the reader that there is very little in Julia of what is not defined in it.</p><h3 id="composite_types"><a class="docs-heading-anchor" href="#composite_types">Composite types</a><a id="composite_types-1"></a><a class="docs-heading-anchor-permalink" href="#composite_types" title="Permalink"></a></h3><p>The composite types are similar to <code>struct</code> in C (they even have the same memory layout). It is not a great idea to think about them as objects (in OOP sense), because objects tie together <em>data</em> and <em>functions</em> over the data. Contrary in Julia (and in C), the function operates over data, but are not tied to them. Composite types are a powerhorse of Julia&#39;s type system, as most user-defined types are composite.</p><p>The composite type is defined as</p><pre><code class="language-julia hljs">struct Position
  x::Float64
  y::Float64
end</code></pre><p>which defines a structure with two fields <code>x</code> and <code>y</code> of type <code>Float64</code>. Julia compiler creates a default constructor, where both (but generally all) arguments are converted using <code>(convert(Float64, x), convert(Float64, y)</code> to the correct type. This means that we can construct a Position with numbers of different type that are convertable to Float, e.g. <code>Position(1,1//2)</code>.</p><p>Composite types do not have to have a specified type, e.g.</p><pre><code class="language-julia hljs">struct VaguePosition
  x 
  y 
end</code></pre><p>which would work as the definition above and allows to store different values in <code>x</code>, for example <code>String</code>. But it would limit compiler&#39;s ability to specialize, which can have a negative impact on the performance. For example</p><pre><code class="language-julia hljs">using BenchmarkTools
move(a::T, b::T) where {T} = T(a.x + b.x, a.y + b.y)
x = [Position(rand(), rand()) for _ in 1:100]
y = [VaguePosition(rand(), rand()) for _ in 1:100]
julia&gt; @btime reduce(move, x);
  114.105 ns (1 allocation: 32 bytes)

julia&gt; @btime reduce(move, y);
  3.879 μs (199 allocations: 3.12 KiB)</code></pre><p>The same holds if the Composite type contains field with AbstractType, for example</p><pre><code class="language-julia hljs">struct LessVaguePosition
  x::Real
  y::Real 
end
z = [LessVaguePosition(rand(), rand()) for _ in 1:100];
julia&gt; @btime reduce(move, z);
  16.260 μs (496 allocations: 9.31 KiB)</code></pre><p>A recommended way to fix this is to parametrize the struct is to parametrize the type definition as follows</p><pre><code class="language-julia hljs">struct Position2{T}
  x::T
  y::T 
end
u = [Position2(rand(), rand()) for _ in 1:100];
julia&gt; @btime reduce(move, u);
  110.043 ns (1 allocation: 32 bytes)</code></pre><p>and notice that the compiler can take advantage of specializing for differenty types (which does not have effect as in modern processrs have addition of Float and Int takes the same time)</p><pre><code class="language-julia hljs">v = [Position2(rand(1:100), rand(1:100)) for _ in 1:100];
@btime reduce(move, v);
  110.043 ns (1 allocation: 32 bytes)</code></pre><p>All structs defined above are immutable (as we have seen above in the case of <code>Tuple</code>), which means that one cannot change a field (unless the struct wraps a container, like and array, which allows that). For example this raises an error</p><pre><code class="language-julia hljs">a = Position(1, 2)
a.x = 2</code></pre><p>If one needs to make a struct mutable, use the keyword <code>mutable</code> as follows</p><pre><code class="language-julia hljs">mutable struct MutablePosition{T}
  x::T
  y::T

end

a = MutablePosition(1e0, 2e0)
a.x = 2</code></pre><p>but there might be some performance penalty(not observable at this simple demo).</p><h3 id="Type-hierarchy"><a class="docs-heading-anchor" href="#Type-hierarchy">Type hierarchy</a><a id="Type-hierarchy-1"></a><a class="docs-heading-anchor-permalink" href="#Type-hierarchy" title="Permalink"></a></h3><p>Depending on the variance of the type constructor, the subtyping relation of the simple types may be either preserved, reversed, or ignored for the respective complex types. In the OCaml programming language, for example, &quot;list of Cat&quot; is a subtype of &quot;list of Animal&quot; because the list type constructor is covariant. This means that the subtyping relation of the simple types are preserved for the complex types. </p><p>On the other hand, &quot;function from Animal to String&quot; is a subtype of &quot;function from Cat to String&quot; because the function type constructor is contravariant in the parameter type. Here the subtyping relation of the simple types is reversed for the complex types. </p><h3 id="The-power-of-Type-System-\\-and-multiple-dispatch"><a class="docs-heading-anchor" href="#The-power-of-Type-System-\\-and-multiple-dispatch">The power of Type System \&amp; multiple dispatch</a><a id="The-power-of-Type-System-\\-and-multiple-dispatch-1"></a><a class="docs-heading-anchor-permalink" href="#The-power-of-Type-System-\\-and-multiple-dispatch" title="Permalink"></a></h3><ul><li>Zero cost abstraction the compiler has information about types and can freely inline <code>x |&gt; identity |&gt; identity |&gt; identity |&gt; identity |&gt; identity</code></li></ul><pre><code class="language-julia hljs">julia&gt; f(x) = x |&gt; identity |&gt; identity |&gt; identity |&gt; identity |&gt; identity
@code_lowered f(1)
@code_lowered f(1)</code></pre><ul><li>Why the type system is important for efficiency</li><li>Bad practices </li><li><strong>LABS:</strong><ul><li>Number type-tree</li><li>Design Interval Aritmetics (for ODES)</li></ul></li></ul><h3 id="VS-NOtes:"><a class="docs-heading-anchor" href="#VS-NOtes:">VS NOtes:</a><a id="VS-NOtes:-1"></a><a class="docs-heading-anchor-permalink" href="#VS-NOtes:" title="Permalink"></a></h3><p>Basics:</p><ul><li>type hierarchy</li><li>subtyping</li><li>Unions</li></ul><h2 id="Pevnak&#39;s-idea"><a class="docs-heading-anchor" href="#Pevnak&#39;s-idea">Pevnak&#39;s idea</a><a id="Pevnak&#39;s-idea-1"></a><a class="docs-heading-anchor-permalink" href="#Pevnak&#39;s-idea" title="Permalink"></a></h2><ul><li>Type hierarchy and rationale behind</li></ul><pre><code class="nohighlight hljs">* Why I cannot create an abstract struct with fields.
* Why a type cannot subtype more than one types
* How the type matching system works and what are the rules (Would take Jan Vitek&#39;s lecture or earlier) https://youtu.be/Y95fAipREHQ?t=958c</code></pre><ul><li>What types do in practice and how it matters?</li></ul><pre><code class="nohighlight hljs">* Allow to structure the program (example two types with the same memory layout (even empty) specializes methods)
* Provides an information how to arrange variables in computer memory
* Inform compiler how things can be stored (possibly on stack (bit types) vs strictly on heap (arrays))
* Inform compiler about what is known (mutable vs non-mutable structs). Explain that when things are mutable, they have to be &quot;boxed&quot;, meaning the variable is on stack and the structure contains pointer. 
* The effect of not strictly typed structs, where the type inference of objects is left to runtime</code></pre><ul><li>Performance gotchas</li></ul><pre><code class="nohighlight hljs">- Why global is slow and how `const` comes to rescue</code></pre><ul><li>Show the above with @code<em>typed, @code</em>native and @btime the effects, such that they can see that.</li></ul><ul><li>Stefans&#39;s C++ example of overloading https://discourse.julialang.org/t/claim-false-julia-isnt-multiple-dispatch-but-overloading/42370/16</li></ul><p>_ Discussion about multiple inheritance https://github.com/JuliaLang/julia/issues/5</p><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><ul><li>why <code>Vector{AbstractFloat}</code> is a bad idea, while <code>Vector{Float64}</code> is a good one?</li><li>why <code>Vector{AbstractFloat}</code> is different to <code>Vector{&lt;:AbstractFloat}</code> or <code>Vector{T} where {T&lt;:AbstractFloat}</code> </li></ul><h3 id="Why-[1,2,3]-is-not-a-Vector{Number}"><a class="docs-heading-anchor" href="#Why-[1,2,3]-is-not-a-Vector{Number}">Why [1,2,3] is not a Vector{Number}</a><a id="Why-[1,2,3]-is-not-a-Vector{Number}-1"></a><a class="docs-heading-anchor-permalink" href="#Why-[1,2,3]-is-not-a-Vector{Number}" title="Permalink"></a></h3><p>Vector{Number} is a concrete type, and [1, 2, 3] has type Vector{Int}, which is also a concrete type. One concrete type is never a subtype of another concrete type, they are the leaves of the type tree.</p><p>Vector{Number} is concrete, even though Number is not a concrete type. That’s because it has a concrete implementation which can store all types that are subtypes of Number, it has a specific memory layout etc. On the other hand, AbstractVector{Int} is the other way around and not a concrete type, because the container is abstract even though the element is concrete.</p><p>What you can do instead is [1, 2, 3] isa Vector{&lt;:Number} which is true. That’s because &lt;:Number is a sort of placeholder which means “any type which is a subtype of Number”. This is often needed for dispatching on containers where you want to allow set of element types. f(x::Vector{Number}) can take only arguments of type Vector{Number}, whereas g(x::Vector{&lt;:Number}) can take e.g. Vector{Int}, Vector{Float64}, Vector{Real}, Vector{Number}, etc.</p><h3 id="Optional-stuff"><a class="docs-heading-anchor" href="#Optional-stuff">Optional stuff</a><a id="Optional-stuff-1"></a><a class="docs-heading-anchor-permalink" href="#Optional-stuff" title="Permalink"></a></h3><h3 id="Alignment-in-the-memory"><a class="docs-heading-anchor" href="#Alignment-in-the-memory">Alignment in the memory</a><a id="Alignment-in-the-memory-1"></a><a class="docs-heading-anchor-permalink" href="#Alignment-in-the-memory" title="Permalink"></a></h3><ul><li>Super-importnat for speed, cache utilization</li><li>Know if you are row or column major </li><li>Vector{Vector{Float}} is a really bad idea over </li></ul><h3 id="A-Headache-examples"><a class="docs-heading-anchor" href="#A-Headache-examples">A Headache examples</a><a id="A-Headache-examples-1"></a><a class="docs-heading-anchor-permalink" href="#A-Headache-examples" title="Permalink"></a></h3><ul><li>This is a great example for type resolution.</li></ul><pre><code class="language-julia hljs">function Base.reduce(::typeof(hcat), xs::Vector{TV})  where {T, L, TV&lt;:OneHotLike{T, L}}
  OneHotMatrix(reduce(vcat, map(_indices, xs)), L)
end</code></pre><h3 id="Turning-multiple-distpatch-to-single-dispatch"><a class="docs-heading-anchor" href="#Turning-multiple-distpatch-to-single-dispatch">Turning multiple-distpatch to single dispatch</a><a id="Turning-multiple-distpatch-to-single-dispatch-1"></a><a class="docs-heading-anchor-permalink" href="#Turning-multiple-distpatch-to-single-dispatch" title="Permalink"></a></h3><p>https://stackoverflow.com/questions/39133424/how-to-create-a-single-dispatch-object-oriented-class-in-julia-that-behaves-l/39150509#39150509</p><h3 id="conversion-among-variables"><a class="docs-heading-anchor" href="#conversion-among-variables">conversion among variables</a><a id="conversion-among-variables-1"></a><a class="docs-heading-anchor-permalink" href="#conversion-among-variables" title="Permalink"></a></h3><p>reinterpret(Float32, ref_sketch)</p><h3 id="Trivia"><a class="docs-heading-anchor" href="#Trivia">Trivia</a><a id="Trivia-1"></a><a class="docs-heading-anchor-permalink" href="#Trivia" title="Permalink"></a></h3><p>why this is true Vector{Int} &lt;: AbstractVector{&lt;:Any} why this is false Vector{Int} &lt;: Vector{Any} why this is true Vector{Int} &lt;: Vector{&lt;:Any}</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../lecture_01/labs/">« LABS</a><a class="docs-footer-nextpage" href="../lab/">Lab »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Wednesday 25 August 2021 10:01">Wednesday 25 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
